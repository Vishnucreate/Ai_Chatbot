This page intentionally left blank

crazy-readers.blogspot.com

Artificial Intelligence
A Modern Approach
Third Edition

crazy-readers.blogspot.com

PRENTICE HALL SERIES
IN ARTIFICIAL INTELLIGENCE
Stuart Russell and Peter Norvig, Editors

F ORSYTH & P ONCE
G RAHAM
J URAFSKY & M ARTIN
N EAPOLITAN
RUSSELL & N ORVIG

Computer Vision: A Modern Approach
ANSI Common Lisp
Speech and Language Processing, 2nd ed.
Learning Bayesian Networks
Artificial Intelligence: A Modern Approach, 3rd ed.

Artificial Intelligence
A Modern Approach
Third Edition
Stuart J. Russell and Peter Norvig

Contributing writers:
Ernest Davis
Douglas D. Edwards
David Forsyth
Nicholas J. Hay
Jitendra M. Malik
Vibhu Mittal
Mehran Sahami
Sebastian Thrun

Upper Saddle River Boston Columbus San Francisco New York
Indianapolis London Toronto Sydney Singapore Tokyo Montreal
Dubai Madrid Hong Kong Mexico City Munich Paris Amsterdam Cape Town

Vice President and Editorial Director, ECS: Marcia J. Horton
Editor-in-Chief: Michael Hirsch
Executive Editor: Tracy Dunkelberger
Assistant Editor: Melinda Haggerty
Editorial Assistant: Allison Michael
Vice President, Production: Vince O’Brien
Senior Managing Editor: Scott Disanno
Production Editor: Jane Bonnell
Senior Operations Supervisor: Alan Fischer
Operations Specialist: Lisa McDowell
Marketing Manager: Erin Davis
Marketing Assistant: Mack Patterson
Cover Designers: Kirsten Sims and Geoffrey Cassar
Cover Images: Stan Honda/Getty, Library of Congress, NASA, National Museum of Rome,
Peter Norvig, Ian Parker, Shutterstock, Time Life/Getty
Interior Designers: Stuart Russell and Peter Norvig
Copy Editor: Mary Lou Nohr
Art Editor: Greg Dulles
Media Editor: Daniel Sandin
Media Project Manager: Danielle Leone
c 2010, 2003, 1995 by Pearson Education, Inc.,
Copyright 
Upper Saddle River, New Jersey 07458.
All rights reserved. Manufactured in the United States of America. This publication is protected by
Copyright and permissions should be obtained from the publisher prior to any prohibited reproduction,
storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical,
photocopying, recording, or likewise. To obtain permission(s) to use materials from this work, please
submit a written request to Pearson Higher Education, Permissions Department, 1 Lake Street, Upper
Saddle River, NJ 07458.
The author and publisher of this book have used their best efforts in preparing this book. These
efforts include the development, research, and testing of the theories and programs to determine their
effectiveness. The author and publisher make no warranty of any kind, expressed or implied, with
regard to these programs or the documentation contained in this book. The author and publisher shall
not be liable in any event for incidental or consequential damages in connection with, or arising out
of, the furnishing, performance, or use of these programs.
Library of Congress Cataloging-in-Publication Data on File

10 9 8 7 6 5 4 3 2 1
ISBN-13: 978-0-13-604259-4
ISBN-10:
0-13-604259-7

For Loy, Gordon, Lucy, George, and Isaac — S.J.R.
For Kris, Isabella, and Juliet — P.N.

Preface
Artificial Intelligence (AI) is a big field, and this is a big book. We have tried to explore the
full breadth of the field, which encompasses logic, probability, and continuous mathematics;
perception, reasoning, learning, and action; and everything from microelectronic devices to
robotic planetary explorers. The book is also big because we go into some depth.
The subtitle of this book is “A Modern Approach.” The intended meaning of this rather
empty phrase is that we have tried to synthesize what is now known into a common framework, rather than trying to explain each subfield of AI in its own historical context. We
apologize to those whose subfields are, as a result, less recognizable.

New to this edition
This edition captures the changes in AI that have taken place since the last edition in 2003.
There have been important applications of AI technology, such as the widespread deployment of practical speech recognition, machine translation, autonomous vehicles, and household robotics. There have been algorithmic landmarks, such as the solution of the game of
checkers. And there has been a great deal of theoretical progress, particularly in areas such
as probabilistic reasoning, machine learning, and computer vision. Most important from our
point of view is the continued evolution in how we think about the field, and thus how we
organize the book. The major changes are as follows:
• We place more emphasis on partially observable and nondeterministic environments,
especially in the nonprobabilistic settings of search and planning. The concepts of
belief state (a set of possible worlds) and state estimation (maintaining the belief state)
are introduced in these settings; later in the book, we add probabilities.
• In addition to discussing the types of environments and types of agents, we now cover
in more depth the types of representations that an agent can use. We distinguish among
atomic representations (in which each state of the world is treated as a black box),
factored representations (in which a state is a set of attribute/value pairs), and structured
representations (in which the world consists of objects and relations between them).
• Our coverage of planning goes into more depth on contingent planning in partially
observable environments and includes a new approach to hierarchical planning.
• We have added new material on first-order probabilistic models, including open-universe
models for cases where there is uncertainty as to what objects exist.
• We have completely rewritten the introductory machine-learning chapter, stressing a
wider variety of more modern learning algorithms and placing them on a firmer theoretical footing.
• We have expanded coverage of Web search and information extraction, and of techniques for learning from very large data sets.
• 20% of the citations in this edition are to works published after 2003.
• We estimate that about 20% of the material is brand new. The remaining 80% reflects
older work but has been largely rewritten to present a more unified picture of the field.
vii

viii

Preface

Overview of the book

NEW TERM

The main unifying theme is the idea of an intelligent agent. We define AI as the study of
agents that receive percepts from the environment and perform actions. Each such agent implements a function that maps percept sequences to actions, and we cover different ways to
represent these functions, such as reactive agents, real-time planners, and decision-theoretic
systems. We explain the role of learning as extending the reach of the designer into unknown
environments, and we show how that role constrains agent design, favoring explicit knowledge representation and reasoning. We treat robotics and vision not as independently defined
problems, but as occurring in the service of achieving goals. We stress the importance of the
task environment in determining the appropriate agent design.
Our primary aim is to convey the ideas that have emerged over the past fifty years of AI
research and the past two millennia of related work. We have tried to avoid excessive formality in the presentation of these ideas while retaining precision. We have included pseudocode
algorithms to make the key ideas concrete; our pseudocode is described in Appendix B.
This book is primarily intended for use in an undergraduate course or course sequence.
The book has 27 chapters, each requiring about a week’s worth of lectures, so working
through the whole book requires a two-semester sequence. A one-semester course can use
selected chapters to suit the interests of the instructor and students. The book can also be
used in a graduate-level course (perhaps with the addition of some of the primary sources
suggested in the bibliographical notes). Sample syllabi are available at the book’s Web site,
aima.cs.berkeley.edu. The only prerequisite is familiarity with basic concepts of
computer science (algorithms, data structures, complexity) at a sophomore level. Freshman
calculus and linear algebra are useful for some of the topics; the required mathematical background is supplied in Appendix A.
Exercises are given at the end of each chapter. Exercises requiring significant programming are marked with a keyboard icon. These exercises can best be solved by taking
advantage of the code repository at aima.cs.berkeley.edu. Some of them are large
enough to be considered term projects. A number of exercises require some investigation of
the literature; these are marked with a book icon.
Throughout the book, important points are marked with a pointing icon. We have included an extensive index of around 6,000 items to make it easy to find things in the book.
Wherever a new term is first defined, it is also marked in the margin.

About the Web site
aima.cs.berkeley.edu, the Web site for the book, contains
• implementations of the algorithms in the book in several programming languages,
• a list of over 1000 schools that have used the book, many with links to online course
materials and syllabi,
• an annotated list of over 800 links to sites around the Web with useful AI content,
• a chapter-by-chapter list of supplementary material and links,
• instructions on how to join a discussion group for the book,

Preface

ix
• instructions on how to contact the authors with questions or comments,
• instructions on how to report errors in the book, in the likely event that some exist, and
• slides and other materials for instructors.

About the cover
The cover depicts the final position from the decisive game 6 of the 1997 match between
chess champion Garry Kasparov and program D EEP B LUE . Kasparov, playing Black, was
forced to resign, making this the first time a computer had beaten a world champion in a
chess match. Kasparov is shown at the top. To his left is the Asimo humanoid robot and
to his right is Thomas Bayes (1702–1761), whose ideas about probability as a measure of
belief underlie much of modern AI technology. Below that we see a Mars Exploration Rover,
a robot that landed on Mars in 2004 and has been exploring the planet ever since. To the
right is Alan Turing (1912–1954), whose fundamental work defined the fields of computer
science in general and artificial intelligence in particular. At the bottom is Shakey (1966–
1972), the first robot to combine perception, world-modeling, planning, and learning. With
Shakey is project leader Charles Rosen (1917–2002). At the bottom right is Aristotle (384
B . C .–322 B . C .), who pioneered the study of logic; his work was state of the art until the 19th
century (copy of a bust by Lysippos). At the bottom left, lightly screened behind the authors’
names, is a planning algorithm by Aristotle from De Motu Animalium in the original Greek.
Behind the title is a portion of the CPSC Bayesian network for medical diagnosis (Pradhan
et al., 1994). Behind the chess board is part of a Bayesian logic model for detecting nuclear
explosions from seismic signals.
Credits: Stan Honda/Getty (Kasparaov), Library of Congress (Bayes), NASA (Mars
rover), National Museum of Rome (Aristotle), Peter Norvig (book), Ian Parker (Berkeley
skyline), Shutterstock (Asimo, Chess pieces), Time Life/Getty (Shakey, Turing).

Acknowledgments
This book would not have been possible without the many contributors whose names did not
make it to the cover. Jitendra Malik and David Forsyth wrote Chapter 24 (computer vision)
and Sebastian Thrun wrote Chapter 25 (robotics). Vibhu Mittal wrote part of Chapter 22
(natural language). Nick Hay, Mehran Sahami, and Ernest Davis wrote some of the exercises.
Zoran Duric (George Mason), Thomas C. Henderson (Utah), Leon Reznik (RIT), Michael
Gourley (Central Oklahoma) and Ernest Davis (NYU) reviewed the manuscript and made
helpful suggestions. We thank Ernie Davis in particular for his tireless ability to read multiple
drafts and help improve the book. Nick Hay whipped the bibliography into shape and on
deadline stayed up to 5:30 AM writing code to make the book better. Jon Barron formatted
and improved the diagrams in this edition, while Tim Huang, Mark Paskin, and Cynthia
Bruyns helped with diagrams and algorithms in previous editions. Ravi Mohan and Ciaran
O’Reilly wrote and maintain the Java code examples on the Web site. John Canny wrote
the robotics chapter for the first edition and Douglas Edwards researched the historical notes.
Tracy Dunkelberger, Allison Michael, Scott Disanno, and Jane Bonnell at Pearson tried their
best to keep us on schedule and made many helpful suggestions. Most helpful of all has

x

Preface
been Julie Sussman, P. P. A ., who read every chapter and provided extensive improvements. In
previous editions we had proofreaders who would tell us when we left out a comma and said
which when we meant that; Julie told us when we left out a minus sign and said xi when we
meant xj . For every typo or confusing explanation that remains in the book, rest assured that
Julie has fixed at least five. She persevered even when a power failure forced her to work by
lantern light rather than LCD glow.
Stuart would like to thank his parents for their support and encouragement and his
wife, Loy Sheflott, for her endless patience and boundless wisdom. He hopes that Gordon,
Lucy, George, and Isaac will soon be reading this book after they have forgiven him for
working so long on it. RUGS (Russell’s Unusual Group of Students) have been unusually
helpful, as always.
Peter would like to thank his parents (Torsten and Gerda) for getting him started,
and his wife (Kris), children (Bella and Juliet), colleagues, and friends for encouraging and
tolerating him through the long hours of writing and longer hours of rewriting.
We both thank the librarians at Berkeley, Stanford, and NASA and the developers of
CiteSeer, Wikipedia, and Google, who have revolutionized the way we do research. We can’t
acknowledge all the people who have used the book and made suggestions, but we would like
to note the especially helpful comments of Gagan Aggarwal, Eyal Amir, Ion Androutsopoulos, Krzysztof Apt, Warren Haley Armstrong, Ellery Aziel, Jeff Van Baalen, Darius Bacon,
Brian Baker, Shumeet Baluja, Don Barker, Tony Barrett, James Newton Bass, Don Beal,
Howard Beck, Wolfgang Bibel, John Binder, Larry Bookman, David R. Boxall, Ronen Brafman, John Bresina, Gerhard Brewka, Selmer Bringsjord, Carla Brodley, Chris Brown, Emma
Brunskill, Wilhelm Burger, Lauren Burka, Carlos Bustamante, Joao Cachopo, Murray Campbell, Norman Carver, Emmanuel Castro, Anil Chakravarthy, Dan Chisarick, Berthe Choueiry,
Roberto Cipolla, David Cohen, James Coleman, Julie Ann Comparini, Corinna Cortes, Gary
Cottrell, Ernest Davis, Tom Dean, Rina Dechter, Tom Dietterich, Peter Drake, Chuck Dyer,
Doug Edwards, Robert Egginton, Asma’a El-Budrawy, Barbara Engelhardt, Kutluhan Erol,
Oren Etzioni, Hana Filip, Douglas Fisher, Jeffrey Forbes, Ken Ford, Eric Fosler-Lussier,
John Fosler, Jeremy Frank, Alex Franz, Bob Futrelle, Marek Galecki, Stefan Gerberding,
Stuart Gill, Sabine Glesner, Seth Golub, Gosta Grahne, Russ Greiner, Eric Grimson, Barbara Grosz, Larry Hall, Steve Hanks, Othar Hansson, Ernst Heinz, Jim Hendler, Christoph
Herrmann, Paul Hilfinger, Robert Holte, Vasant Honavar, Tim Huang, Seth Hutchinson, Joost
Jacob, Mark Jelasity, Magnus Johansson, Istvan Jonyer, Dan Jurafsky, Leslie Kaelbling, Keiji
Kanazawa, Surekha Kasibhatla, Simon Kasif, Henry Kautz, Gernot Kerschbaumer, Max
Khesin, Richard Kirby, Dan Klein, Kevin Knight, Roland Koenig, Sven Koenig, Daphne
Koller, Rich Korf, Benjamin Kuipers, James Kurien, John Lafferty, John Laird, Gus Larsson, John Lazzaro, Jon LeBlanc, Jason Leatherman, Frank Lee, Jon Lehto, Edward Lim,
Phil Long, Pierre Louveaux, Don Loveland, Sridhar Mahadevan, Tony Mancill, Jim Martin,
Andy Mayer, John McCarthy, David McGrane, Jay Mendelsohn, Risto Miikkulanien, Brian
Milch, Steve Minton, Vibhu Mittal, Mehryar Mohri, Leora Morgenstern, Stephen Muggleton,
Kevin Murphy, Ron Musick, Sung Myaeng, Eric Nadeau, Lee Naish, Pandu Nayak, Bernhard
Nebel, Stuart Nelson, XuanLong Nguyen, Nils Nilsson, Illah Nourbakhsh, Ali Nouri, Arthur
Nunes-Harwitt, Steve Omohundro, David Page, David Palmer, David Parkes, Ron Parr, Mark

Preface

xi
Paskin, Tony Passera, Amit Patel, Michael Pazzani, Fernando Pereira, Joseph Perla, Wim Pijls, Ira Pohl, Martha Pollack, David Poole, Bruce Porter, Malcolm Pradhan, Bill Pringle, Lorraine Prior, Greg Provan, William Rapaport, Deepak Ravichandran, Ioannis Refanidis, Philip
Resnik, Francesca Rossi, Sam Roweis, Richard Russell, Jonathan Schaeffer, Richard Scherl,
Hinrich Schuetze, Lars Schuster, Bart Selman, Soheil Shams, Stuart Shapiro, Jude Shavlik, Yoram Singer, Satinder Singh, Daniel Sleator, David Smith, Bryan So, Robert Sproull,
Lynn Stein, Larry Stephens, Andreas Stolcke, Paul Stradling, Devika Subramanian, Marek
Suchenek, Rich Sutton, Jonathan Tash, Austin Tate, Bas Terwijn, Olivier Teytaud, Michael
Thielscher, William Thompson, Sebastian Thrun, Eric Tiedemann, Mark Torrance, Randall
Upham, Paul Utgoff, Peter van Beek, Hal Varian, Paulina Varshavskaya, Sunil Vemuri, Vandi
Verma, Ubbo Visser, Jim Waldo, Toby Walsh, Bonnie Webber, Dan Weld, Michael Wellman,
Kamin Whitehouse, Michael Dean White, Brian Williams, David Wolfe, Jason Wolfe, Bill
Woods, Alden Wright, Jay Yagnik, Mark Yasuda, Richard Yen, Eliezer Yudkowsky, Weixiong
Zhang, Ming Zhao, Shlomo Zilberstein, and our esteemed colleague Anonymous Reviewer.

About the Authors
Stuart Russell was born in 1962 in Portsmouth, England. He received his B.A. with firstclass honours in physics from Oxford University in 1982, and his Ph.D. in computer science
from Stanford in 1986. He then joined the faculty of the University of California at Berkeley,
where he is a professor of computer science, director of the Center for Intelligent Systems,
and holder of the Smith–Zadeh Chair in Engineering. In 1990, he received the Presidential
Young Investigator Award of the National Science Foundation, and in 1995 he was cowinner
of the Computers and Thought Award. He was a 1996 Miller Professor of the University of
California and was appointed to a Chancellor’s Professorship in 2000. In 1998, he gave the
Forsythe Memorial Lectures at Stanford University. He is a Fellow and former Executive
Council member of the American Association for Artificial Intelligence. He has published
over 100 papers on a wide range of topics in artificial intelligence. His other books include
The Use of Knowledge in Analogy and Induction and (with Eric Wefald) Do the Right Thing:
Studies in Limited Rationality.
Peter Norvig is currently Director of Research at Google, Inc., and was the director responsible for the core Web search algorithms from 2002 to 2005. He is a Fellow of the American
Association for Artificial Intelligence and the Association for Computing Machinery. Previously, he was head of the Computational Sciences Division at NASA Ames Research Center,
where he oversaw NASA’s research and development in artificial intelligence and robotics,
and chief scientist at Junglee, where he helped develop one of the first Internet information
extraction services. He received a B.S. in applied mathematics from Brown University and
a Ph.D. in computer science from the University of California at Berkeley. He received the
Distinguished Alumni and Engineering Innovation awards from Berkeley and the Exceptional
Achievement Medal from NASA. He has been a professor at the University of Southern California and a research faculty member at Berkeley. His other books are Paradigms of AI
Programming: Case Studies in Common Lisp and Verbmobil: A Translation System for Faceto-Face Dialog and Intelligent Help Systems for UNIX.

xii

Contents
I Artificial Intelligence
1 Introduction
1.1
What Is AI? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2
The Foundations of Artificial Intelligence . . . . . . . . . . . . . . . . . .
1.3
The History of Artificial Intelligence . . . . . . . . . . . . . . . . . . . .
1.4
The State of the Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.5
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

1
1
5
16
28
29

2 Intelligent Agents
2.1
Agents and Environments . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2
Good Behavior: The Concept of Rationality . . . . . . . . . . . . . . . .
2.3
The Nature of Environments . . . . . . . . . . . . . . . . . . . . . . . . .
2.4
The Structure of Agents . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.5
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

34
34
36
40
46
59

II Problem-solving
3 Solving Problems by Searching
3.1
Problem-Solving Agents . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2
Example Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3
Searching for Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4
Uninformed Search Strategies . . . . . . . . . . . . . . . . . . . . . . . .
3.5
Informed (Heuristic) Search Strategies . . . . . . . . . . . . . . . . . . .
3.6
Heuristic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.7
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

64
64
69
75
81
92
102
108

4 Beyond Classical Search
4.1
Local Search Algorithms and Optimization Problems . . . . . . . . . . .
4.2
Local Search in Continuous Spaces . . . . . . . . . . . . . . . . . . . . .
4.3
Searching with Nondeterministic Actions . . . . . . . . . . . . . . . . . .
4.4
Searching with Partial Observations . . . . . . . . . . . . . . . . . . . . .
4.5
Online Search Agents and Unknown Environments . . . . . . . . . . . .
4.6
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

120
120
129
133
138
147
153

5 Adversarial Search
5.1
Games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2
Optimal Decisions in Games . . . . . . . . . . . . . . . . . . . . . . . .
5.3
Alpha–Beta Pruning . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.4
Imperfect Real-Time Decisions . . . . . . . . . . . . . . . . . . . . . . .
5.5
Stochastic Games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

161
161
163
167
171
177

xiii

xiv

Contents
5.6
5.7
5.8
5.9

Partially Observable Games . . . . . . . . . . . . . . . . . . . . . . . . .
State-of-the-Art Game Programs . . . . . . . . . . . . . . . . . . . . . .
Alternative Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . .
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

180
185
187
189

6 Constraint Satisfaction Problems
6.1
Defining Constraint Satisfaction Problems . . . . . . . . . . . . . . . . .
6.2
Constraint Propagation: Inference in CSPs . . . . . . . . . . . . . . . . .
6.3
Backtracking Search for CSPs . . . . . . . . . . . . . . . . . . . . . . . .
6.4
Local Search for CSPs . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.5
The Structure of Problems . . . . . . . . . . . . . . . . . . . . . . . . . .
6.6
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

202
202
208
214
220
222
227

III Knowledge, reasoning, and planning
7 Logical Agents
7.1
Knowledge-Based Agents . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2
The Wumpus World . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.3
Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.4
Propositional Logic: A Very Simple Logic . . . . . . . . . . . . . . . . .
7.5
Propositional Theorem Proving . . . . . . . . . . . . . . . . . . . . . . .
7.6
Effective Propositional Model Checking . . . . . . . . . . . . . . . . . .
7.7
Agents Based on Propositional Logic . . . . . . . . . . . . . . . . . . . .
7.8
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

234
235
236
240
243
249
259
265
274

8 First-Order Logic
8.1
Representation Revisited . . . . . . . . . . . . . . . . . . . . . . . . . .
8.2
Syntax and Semantics of First-Order Logic . . . . . . . . . . . . . . . . .
8.3
Using First-Order Logic . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.4
Knowledge Engineering in First-Order Logic . . . . . . . . . . . . . . . .
8.5
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

285
285
290
300
307
313

9 Inference in First-Order Logic
9.1
Propositional vs. First-Order Inference . . . . . . . . . . . . . . . . . . .
9.2
Unification and Lifting . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.3
Forward Chaining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.4
Backward Chaining . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.5
Resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.6
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

322
322
325
330
337
345
357

10 Classical Planning
10.1 Definition of Classical Planning . . . . . . . . . . . . . . . . . . . . . . .
10.2 Algorithms for Planning as State-Space Search . . . . . . . . . . . . . . .
10.3 Planning Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

366
366
373
379

Contents

xv
10.4
10.5
10.6

Other Classical Planning Approaches . . . . . . . . . . . . . . . . . . . .
Analysis of Planning Approaches . . . . . . . . . . . . . . . . . . . . . .
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

387
392
393

11 Planning and Acting in the Real World
11.1 Time, Schedules, and Resources . . . . . . . . . . . . . . . . . . . . . . .
11.2 Hierarchical Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.3 Planning and Acting in Nondeterministic Domains . . . . . . . . . . . . .
11.4 Multiagent Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.5 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

401
401
406
415
425
430

12 Knowledge Representation
12.1 Ontological Engineering . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.2 Categories and Objects . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.3 Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.4 Mental Events and Mental Objects . . . . . . . . . . . . . . . . . . . . .
12.5 Reasoning Systems for Categories . . . . . . . . . . . . . . . . . . . . .
12.6 Reasoning with Default Information . . . . . . . . . . . . . . . . . . . .
12.7 The Internet Shopping World . . . . . . . . . . . . . . . . . . . . . . . .
12.8 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

437
437
440
446
450
453
458
462
467

IV Uncertain knowledge and reasoning
13 Quantifying Uncertainty
13.1 Acting under Uncertainty . . . . . . . . . . . . . . . . . . . . . . . . . .
13.2 Basic Probability Notation . . . . . . . . . . . . . . . . . . . . . . . . . .
13.3 Inference Using Full Joint Distributions . . . . . . . . . . . . . . . . . . .
13.4 Independence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13.5 Bayes’ Rule and Its Use . . . . . . . . . . . . . . . . . . . . . . . . . . .
13.6 The Wumpus World Revisited . . . . . . . . . . . . . . . . . . . . . . . .
13.7 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

480
480
483
490
494
495
499
503

14 Probabilistic Reasoning
14.1 Representing Knowledge in an Uncertain Domain . . . . . . . . . . . . .
14.2 The Semantics of Bayesian Networks . . . . . . . . . . . . . . . . . . . .
14.3 Efficient Representation of Conditional Distributions . . . . . . . . . . . .
14.4 Exact Inference in Bayesian Networks . . . . . . . . . . . . . . . . . . .
14.5 Approximate Inference in Bayesian Networks . . . . . . . . . . . . . . .
14.6 Relational and First-Order Probability Models . . . . . . . . . . . . . . .
14.7 Other Approaches to Uncertain Reasoning . . . . . . . . . . . . . . . . .
14.8 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

510
510
513
518
522
530
539
546
551

15 Probabilistic Reasoning over Time
15.1 Time and Uncertainty . . . . . . . . . . . . . . . . . . . . . . . . . . . .

566
566

xvi

Contents
15.2
15.3
15.4
15.5
15.6
15.7

Inference in Temporal Models . . . . . . . . . . . . . . . . . . . . . . . .
Hidden Markov Models . . . . . . . . . . . . . . . . . . . . . . . . . . .
Kalman Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Dynamic Bayesian Networks . . . . . . . . . . . . . . . . . . . . . . . .
Keeping Track of Many Objects . . . . . . . . . . . . . . . . . . . . . . .
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

570
578
584
590
599
603

16 Making Simple Decisions
16.1 Combining Beliefs and Desires under Uncertainty . . . . . . . . . . . . .
16.2 The Basis of Utility Theory . . . . . . . . . . . . . . . . . . . . . . . . .
16.3 Utility Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.4 Multiattribute Utility Functions . . . . . . . . . . . . . . . . . . . . . . .
16.5 Decision Networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.6 The Value of Information . . . . . . . . . . . . . . . . . . . . . . . . . .
16.7 Decision-Theoretic Expert Systems . . . . . . . . . . . . . . . . . . . . .
16.8 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

610
610
611
615
622
626
628
633
636

17 Making Complex Decisions
17.1 Sequential Decision Problems . . . . . . . . . . . . . . . . . . . . . . . .
17.2 Value Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.3 Policy Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.4 Partially Observable MDPs . . . . . . . . . . . . . . . . . . . . . . . . .
17.5 Decisions with Multiple Agents: Game Theory . . . . . . . . . . . . . . .
17.6 Mechanism Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.7 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

645
645
652
656
658
666
679
684

V

Learning

18 Learning from Examples
18.1 Forms of Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.2 Supervised Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.3 Learning Decision Trees . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.4 Evaluating and Choosing the Best Hypothesis . . . . . . . . . . . . . . .
18.5 The Theory of Learning . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.6 Regression and Classification with Linear Models . . . . . . . . . . . . .
18.7 Artificial Neural Networks . . . . . . . . . . . . . . . . . . . . . . . . .
18.8 Nonparametric Models . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.9 Support Vector Machines . . . . . . . . . . . . . . . . . . . . . . . . . .
18.10 Ensemble Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.11 Practical Machine Learning . . . . . . . . . . . . . . . . . . . . . . . . .
18.12 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

693
693
695
697
708
713
717
727
737
744
748
753
757

19 Knowledge in Learning
19.1 A Logical Formulation of Learning . . . . . . . . . . . . . . . . . . . . .

768
768

Contents

xvii
19.2
19.3
19.4
19.5
19.6

Knowledge in Learning . . . . . . . . . . . . . . . . . . . . . . . . . . .
Explanation-Based Learning . . . . . . . . . . . . . . . . . . . . . . . .
Learning Using Relevance Information . . . . . . . . . . . . . . . . . . .
Inductive Logic Programming . . . . . . . . . . . . . . . . . . . . . . . .
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

777
780
784
788
797

20 Learning Probabilistic Models
20.1 Statistical Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.2 Learning with Complete Data . . . . . . . . . . . . . . . . . . . . . . . .
20.3 Learning with Hidden Variables: The EM Algorithm . . . . . . . . . . . .
20.4 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

802
802
806
816
825

21 Reinforcement Learning
21.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.2 Passive Reinforcement Learning . . . . . . . . . . . . . . . . . . . . . .
21.3 Active Reinforcement Learning . . . . . . . . . . . . . . . . . . . . . . .
21.4 Generalization in Reinforcement Learning . . . . . . . . . . . . . . . . .
21.5 Policy Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.6 Applications of Reinforcement Learning . . . . . . . . . . . . . . . . . .
21.7 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

830
830
832
839
845
848
850
853

VI Communicating, perceiving, and acting
22 Natural Language Processing
22.1 Language Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.2 Text Classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.3 Information Retrieval . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.4 Information Extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.5 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

860
860
865
867
873
882

23 Natural Language for Communication
23.1 Phrase Structure Grammars . . . . . . . . . . . . . . . . . . . . . . . . .
23.2 Syntactic Analysis (Parsing) . . . . . . . . . . . . . . . . . . . . . . . . .
23.3 Augmented Grammars and Semantic Interpretation . . . . . . . . . . . .
23.4 Machine Translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23.5 Speech Recognition . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23.6 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

888
888
892
897
907
912
918

24 Perception
24.1 Image Formation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24.2 Early Image-Processing Operations . . . . . . . . . . . . . . . . . . . . .
24.3 Object Recognition by Appearance . . . . . . . . . . . . . . . . . . . . .
24.4 Reconstructing the 3D World . . . . . . . . . . . . . . . . . . . . . . . .
24.5 Object Recognition from Structural Information . . . . . . . . . . . . . .

928
929
935
942
947
957

xviii

Contents
24.6
24.7

Using Vision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

961
965

25 Robotics
971
25.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 971
25.2 Robot Hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 973
25.3 Robotic Perception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 978
25.4 Planning to Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 986
25.5 Planning Uncertain Movements . . . . . . . . . . . . . . . . . . . . . . . 993
25.6 Moving . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 997
25.7 Robotic Software Architectures . . . . . . . . . . . . . . . . . . . . . . . 1003
25.8 Application Domains . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1006
25.9 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . . 1010

VII Conclusions
26 Philosophical Foundations
26.1 Weak AI: Can Machines Act Intelligently? . . . . . . . . . . . . . . . . .
26.2 Strong AI: Can Machines Really Think? . . . . . . . . . . . . . . . . . .
26.3 The Ethics and Risks of Developing Artificial Intelligence . . . . . . . . .
26.4 Summary, Bibliographical and Historical Notes, Exercises . . . . . . . . .

1020
1020
1026
1034
1040

27 AI: The Present and Future
27.1 Agent Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27.2 Agent Architectures . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27.3 Are We Going in the Right Direction? . . . . . . . . . . . . . . . . . . .
27.4 What If AI Does Succeed? . . . . . . . . . . . . . . . . . . . . . . . . .

1044
1044
1047
1049
1051

A Mathematical background
A.1 Complexity Analysis and O() Notation . . . . . . . . . . . . . . . . . . .
A.2 Vectors, Matrices, and Linear Algebra . . . . . . . . . . . . . . . . . . .
A.3 Probability Distributions . . . . . . . . . . . . . . . . . . . . . . . . . . .

1053
1053
1055
1057

B Notes on Languages and Algorithms
B.1 Defining Languages with Backus–Naur Form (BNF) . . . . . . . . . . . .
B.2 Describing Algorithms with Pseudocode . . . . . . . . . . . . . . . . . .
B.3 Online Help . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1060
1060
1061
1062

Bibliography

1063

Index

1095

1

INTRODUCTION

In which we try to explain why we consider artificial intelligence to be a subject
most worthy of study, and in which we try to decide what exactly it is, this being a
good thing to decide before embarking.

INTELLIGENCE

ARTIFICIAL
INTELLIGENCE

1.1

RATIONALITY

We call ourselves Homo sapiens—man the wise—because our intelligence is so important
to us. For thousands of years, we have tried to understand how we think; that is, how a mere
handful of matter can perceive, understand, predict, and manipulate a world far larger and
more complicated than itself. The field of artificial intelligence, or AI, goes further still: it
attempts not just to understand but also to build intelligent entities.
AI is one of the newest fields in science and engineering. Work started in earnest soon
after World War II, and the name itself was coined in 1956. Along with molecular biology,
AI is regularly cited as the “field I would most like to be in” by scientists in other disciplines.
A student in physics might reasonably feel that all the good ideas have already been taken by
Galileo, Newton, Einstein, and the rest. AI, on the other hand, still has openings for several
full-time Einsteins and Edisons.
AI currently encompasses a huge variety of subfields, ranging from the general (learning
and perception) to the specific, such as playing chess, proving mathematical theorems, writing
poetry, driving a car on a crowded street, and diagnosing diseases. AI is relevant to any
intellectual task; it is truly a universal field.

W HAT I S AI?
We have claimed that AI is exciting, but we have not said what it is. In Figure 1.1 we see
eight definitions of AI, laid out along two dimensions. The definitions on top are concerned
with thought processes and reasoning, whereas the ones on the bottom address behavior. The
definitions on the left measure success in terms of fidelity to human performance, whereas
the ones on the right measure against an ideal performance measure, called rationality. A
system is rational if it does the “right thing,” given what it knows.
Historically, all four approaches to AI have been followed, each by different people
with different methods. A human-centered approach must be in part an empirical science, in1

2

Chapter 1.

Introduction

Thinking Humanly

Thinking Rationally

“The exciting new effort to make computers think . . . machines with minds, in the
full and literal sense.” (Haugeland, 1985)

“The study of mental faculties through the
use of computational models.”
(Charniak and McDermott, 1985)

“[The automation of] activities that we
associate with human thinking, activities
such as decision-making, problem solving, learning . . .” (Bellman, 1978)

“The study of the computations that make
it possible to perceive, reason, and act.”
(Winston, 1992)

Acting Humanly

Acting Rationally

“The art of creating machines that perform functions that require intelligence
when performed by people.” (Kurzweil,
1990)

“Computational Intelligence is the study
of the design of intelligent agents.” (Poole
et al., 1998)

“The study of how to make computers do
things at which, at the moment, people are
better.” (Rich and Knight, 1991)

“AI . . . is concerned with intelligent behavior in artifacts.” (Nilsson, 1998)

Figure 1.1

Some definitions of artificial intelligence, organized into four categories.

volving observations and hypotheses about human behavior. A rationalist1 approach involves
a combination of mathematics and engineering. The various group have both disparaged and
helped each other. Let us look at the four approaches in more detail.

1.1.1 Acting humanly: The Turing Test approach
TURING TEST

The Turing Test, proposed by Alan Turing (1950), was designed to provide a satisfactory
operational definition of intelligence. A computer passes the test if a human interrogator, after
posing some written questions, cannot tell whether the written responses come from a person
or from a computer. Chapter 26 discusses the details of the test and whether a computer would
really be intelligent if it passed. For now, we note that programming a computer to pass a
rigorously applied test provides plenty to work on. The computer would need to possess the
following capabilities:
• natural language processing to enable it to communicate successfully in English;
• knowledge representation to store what it knows or hears;
• automated reasoning to use the stored information to answer questions and to draw
new conclusions;
• machine learning to adapt to new circumstances and to detect and extrapolate patterns.

NATURAL LANGUAGE
PROCESSING
KNOWLEDGE
REPRESENTATION
AUTOMATED
REASONING

MACHINE LEARNING
1

By distinguishing between human and rational behavior, we are not suggesting that humans are necessarily
“irrational” in the sense of “emotionally unstable” or “insane.” One merely need note that we are not perfect:
not all chess players are grandmasters; and, unfortunately, not everyone gets an A on the exam. Some systematic
errors in human reasoning are cataloged by Kahneman et al. (1982).

Section 1.1.

TOTAL TURING TEST

What Is AI?

3

Turing’s test deliberately avoided direct physical interaction between the interrogator and the
computer, because physical simulation of a person is unnecessary for intelligence. However,
the so-called total Turing Test includes a video signal so that the interrogator can test the
subject’s perceptual abilities, as well as the opportunity for the interrogator to pass physical
objects “through the hatch.” To pass the total Turing Test, the computer will need

COMPUTER VISION

• computer vision to perceive objects, and

ROBOTICS

• robotics to manipulate objects and move about.
These six disciplines compose most of AI, and Turing deserves credit for designing a test
that remains relevant 60 years later. Yet AI researchers have devoted little effort to passing
the Turing Test, believing that it is more important to study the underlying principles of intelligence than to duplicate an exemplar. The quest for “artificial flight” succeeded when the
Wright brothers and others stopped imitating birds and started using wind tunnels and learning about aerodynamics. Aeronautical engineering texts do not define the goal of their field
as making “machines that fly so exactly like pigeons that they can fool even other pigeons.”

1.1.2 Thinking humanly: The cognitive modeling approach

COGNITIVE SCIENCE

If we are going to say that a given program thinks like a human, we must have some way of
determining how humans think. We need to get inside the actual workings of human minds.
There are three ways to do this: through introspection—trying to catch our own thoughts as
they go by; through psychological experiments—observing a person in action; and through
brain imaging—observing the brain in action. Once we have a sufficiently precise theory of
the mind, it becomes possible to express the theory as a computer program. If the program’s
input–output behavior matches corresponding human behavior, that is evidence that some of
the program’s mechanisms could also be operating in humans. For example, Allen Newell
and Herbert Simon, who developed GPS, the “General Problem Solver” (Newell and Simon,
1961), were not content merely to have their program solve problems correctly. They were
more concerned with comparing the trace of its reasoning steps to traces of human subjects
solving the same problems. The interdisciplinary field of cognitive science brings together
computer models from AI and experimental techniques from psychology to construct precise
and testable theories of the human mind.
Cognitive science is a fascinating field in itself, worthy of several textbooks and at least
one encyclopedia (Wilson and Keil, 1999). We will occasionally comment on similarities or
differences between AI techniques and human cognition. Real cognitive science, however, is
necessarily based on experimental investigation of actual humans or animals. We will leave
that for other books, as we assume the reader has only a computer for experimentation.
In the early days of AI there was often confusion between the approaches: an author
would argue that an algorithm performs well on a task and that it is therefore a good model
of human performance, or vice versa. Modern authors separate the two kinds of claims;
this distinction has allowed both AI and cognitive science to develop more rapidly. The two
fields continue to fertilize each other, most notably in computer vision, which incorporates
neurophysiological evidence into computational models.

4

Chapter 1.

Introduction

1.1.3 Thinking rationally: The “laws of thought” approach
SYLLOGISM

LOGIC

LOGICIST

The Greek philosopher Aristotle was one of the first to attempt to codify “right thinking,” that
is, irrefutable reasoning processes. His syllogisms provided patterns for argument structures
that always yielded correct conclusions when given correct premises—for example, “Socrates
is a man; all men are mortal; therefore, Socrates is mortal.” These laws of thought were
supposed to govern the operation of the mind; their study initiated the field called logic.
Logicians in the 19th century developed a precise notation for statements about all kinds
of objects in the world and the relations among them. (Contrast this with ordinary arithmetic
notation, which provides only for statements about numbers.) By 1965, programs existed
that could, in principle, solve any solvable problem described in logical notation. (Although
if no solution exists, the program might loop forever.) The so-called logicist tradition within
artificial intelligence hopes to build on such programs to create intelligent systems.
There are two main obstacles to this approach. First, it is not easy to take informal
knowledge and state it in the formal terms required by logical notation, particularly when
the knowledge is less than 100% certain. Second, there is a big difference between solving
a problem “in principle” and solving it in practice. Even problems with just a few hundred
facts can exhaust the computational resources of any computer unless it has some guidance
as to which reasoning steps to try first. Although both of these obstacles apply to any attempt
to build computational reasoning systems, they appeared first in the logicist tradition.

1.1.4 Acting rationally: The rational agent approach
AGENT

RATIONAL AGENT

An agent is just something that acts (agent comes from the Latin agere, to do). Of course,
all computer programs do something, but computer agents are expected to do more: operate
autonomously, perceive their environment, persist over a prolonged time period, adapt to
change, and create and pursue goals. A rational agent is one that acts so as to achieve the
best outcome or, when there is uncertainty, the best expected outcome.
In the “laws of thought” approach to AI, the emphasis was on correct inferences. Making correct inferences is sometimes part of being a rational agent, because one way to act
rationally is to reason logically to the conclusion that a given action will achieve one’s goals
and then to act on that conclusion. On the other hand, correct inference is not all of rationality; in some situations, there is no provably correct thing to do, but something must still be
done. There are also ways of acting rationally that cannot be said to involve inference. For
example, recoiling from a hot stove is a reflex action that is usually more successful than a
slower action taken after careful deliberation.
All the skills needed for the Turing Test also allow an agent to act rationally. Knowledge
representation and reasoning enable agents to reach good decisions. We need to be able to
generate comprehensible sentences in natural language to get by in a complex society. We
need learning not only for erudition, but also because it improves our ability to generate
effective behavior.
The rational-agent approach has two advantages over the other approaches. First, it
is more general than the “laws of thought” approach because correct inference is just one
of several possible mechanisms for achieving rationality. Second, it is more amenable to

Section 1.2.

LIMITED
RATIONALITY

1.2

The Foundations of Artificial Intelligence

5

scientific development than are approaches based on human behavior or human thought. The
standard of rationality is mathematically well defined and completely general, and can be
“unpacked” to generate agent designs that provably achieve it. Human behavior, on the other
hand, is well adapted for one specific environment and is defined by, well, the sum total
of all the things that humans do. This book therefore concentrates on general principles
of rational agents and on components for constructing them. We will see that despite the
apparent simplicity with which the problem can be stated, an enormous variety of issues
come up when we try to solve it. Chapter 2 outlines some of these issues in more detail.
One important point to keep in mind: We will see before too long that achieving perfect
rationality—always doing the right thing—is not feasible in complicated environments. The
computational demands are just too high. For most of the book, however, we will adopt the
working hypothesis that perfect rationality is a good starting point for analysis. It simplifies
the problem and provides the appropriate setting for most of the foundational material in
the field. Chapters 5 and 17 deal explicitly with the issue of limited rationality—acting
appropriately when there is not enough time to do all the computations one might like.

T HE F OUNDATIONS OF A RTIFICIAL I NTELLIGENCE
In this section, we provide a brief history of the disciplines that contributed ideas, viewpoints,
and techniques to AI. Like any history, this one is forced to concentrate on a small number
of people, events, and ideas and to ignore others that also were important. We organize the
history around a series of questions. We certainly would not wish to give the impression that
these questions are the only ones the disciplines address or that the disciplines have all been
working toward AI as their ultimate fruition.

1.2.1 Philosophy
• Can formal rules be used to draw valid conclusions?
• How does the mind arise from a physical brain?
• Where does knowledge come from?
• How does knowledge lead to action?
Aristotle (384–322 B . C .), whose bust appears on the front cover of this book, was the first
to formulate a precise set of laws governing the rational part of the mind. He developed an
informal system of syllogisms for proper reasoning, which in principle allowed one to generate conclusions mechanically, given initial premises. Much later, Ramon Lull (d. 1315) had
the idea that useful reasoning could actually be carried out by a mechanical artifact. Thomas
Hobbes (1588–1679) proposed that reasoning was like numerical computation, that “we add
and subtract in our silent thoughts.” The automation of computation itself was already well
under way. Around 1500, Leonardo da Vinci (1452–1519) designed but did not build a mechanical calculator; recent reconstructions have shown the design to be functional. The first
known calculating machine was constructed around 1623 by the German scientist Wilhelm
Schickard (1592–1635), although the Pascaline, built in 1642 by Blaise Pascal (1623–1662),

6

RATIONALISM
DUALISM

MATERIALISM

EMPIRICISM

INDUCTION

LOGICAL POSITIVISM
OBSERVATION
SENTENCES
CONFIRMATION
THEORY

Chapter 1.

Introduction

is more famous. Pascal wrote that “the arithmetical machine produces effects which appear
nearer to thought than all the actions of animals.” Gottfried Wilhelm Leibniz (1646–1716)
built a mechanical device intended to carry out operations on concepts rather than numbers,
but its scope was rather limited. Leibniz did surpass Pascal by building a calculator that
could add, subtract, multiply, and take roots, whereas the Pascaline could only add and subtract. Some speculated that machines might not just do calculations but actually be able to
think and act on their own. In his 1651 book Leviathan, Thomas Hobbes suggested the idea
of an “artificial animal,” arguing “For what is the heart but a spring; and the nerves, but so
many strings; and the joints, but so many wheels.”
It’s one thing to say that the mind operates, at least in part, according to logical rules, and
to build physical systems that emulate some of those rules; it’s another to say that the mind
itself is such a physical system. René Descartes (1596–1650) gave the first clear discussion
of the distinction between mind and matter and of the problems that arise. One problem with
a purely physical conception of the mind is that it seems to leave little room for free will:
if the mind is governed entirely by physical laws, then it has no more free will than a rock
“deciding” to fall toward the center of the earth. Descartes was a strong advocate of the power
of reasoning in understanding the world, a philosophy now called rationalism, and one that
counts Aristotle and Leibnitz as members. But Descartes was also a proponent of dualism.
He held that there is a part of the human mind (or soul or spirit) that is outside of nature,
exempt from physical laws. Animals, on the other hand, did not possess this dual quality;
they could be treated as machines. An alternative to dualism is materialism, which holds
that the brain’s operation according to the laws of physics constitutes the mind. Free will is
simply the way that the perception of available choices appears to the choosing entity.
Given a physical mind that manipulates knowledge, the next problem is to establish
the source of knowledge. The empiricism movement, starting with Francis Bacon’s (1561–
1626) Novum Organum,2 is characterized by a dictum of John Locke (1632–1704): “Nothing
is in the understanding, which was not first in the senses.” David Hume’s (1711–1776) A
Treatise of Human Nature (Hume, 1739) proposed what is now known as the principle of
induction: that general rules are acquired by exposure to repeated associations between their
elements. Building on the work of Ludwig Wittgenstein (1889–1951) and Bertrand Russell
(1872–1970), the famous Vienna Circle, led by Rudolf Carnap (1891–1970), developed the
doctrine of logical positivism. This doctrine holds that all knowledge can be characterized by
logical theories connected, ultimately, to observation sentences that correspond to sensory
inputs; thus logical positivism combines rationalism and empiricism.3 The confirmation theory of Carnap and Carl Hempel (1905–1997) attempted to analyze the acquisition of knowledge from experience. Carnap’s book The Logical Structure of the World (1928) defined an
explicit computational procedure for extracting knowledge from elementary experiences. It
was probably the first theory of mind as a computational process.
2

The Novum Organum is an update of Aristotle’s Organon, or instrument of thought. Thus Aristotle can be
seen as both an empiricist and a rationalist.
3 In this picture, all meaningful statements can be verified or falsified either by experimentation or by analysis
of the meaning of the words. Because this rules out most of metaphysics, as was the intention, logical positivism
was unpopular in some circles.

Section 1.2.

The Foundations of Artificial Intelligence

7

The final element in the philosophical picture of the mind is the connection between
knowledge and action. This question is vital to AI because intelligence requires action as well
as reasoning. Moreover, only by understanding how actions are justified can we understand
how to build an agent whose actions are justifiable (or rational). Aristotle argued (in De Motu
Animalium) that actions are justified by a logical connection between goals and knowledge of
the action’s outcome (the last part of this extract also appears on the front cover of this book,
in the original Greek):
But how does it happen that thinking is sometimes accompanied by action and sometimes
not, sometimes by motion, and sometimes not? It looks as if almost the same thing
happens as in the case of reasoning and making inferences about unchanging objects. But
in that case the end is a speculative proposition . . . whereas here the conclusion which
results from the two premises is an action. . . . I need covering; a cloak is a covering. I
need a cloak. What I need, I have to make; I need a cloak. I have to make a cloak. And
the conclusion, the “I have to make a cloak,” is an action.

In the Nicomachean Ethics (Book III. 3, 1112b), Aristotle further elaborates on this topic,
suggesting an algorithm:
We deliberate not about ends, but about means. For a doctor does not deliberate whether
he shall heal, nor an orator whether he shall persuade, . . . They assume the end and
consider how and by what means it is attained, and if it seems easily and best produced
thereby; while if it is achieved by one means only they consider how it will be achieved
by this and by what means this will be achieved, till they come to the first cause, . . . and
what is last in the order of analysis seems to be first in the order of becoming. And if we
come on an impossibility, we give up the search, e.g., if we need money and this cannot
be got; but if a thing appears possible we try to do it.

Aristotle’s algorithm was implemented 2300 years later by Newell and Simon in their GPS
program. We would now call it a regression planning system (see Chapter 10).
Goal-based analysis is useful, but does not say what to do when several actions will
achieve the goal or when no action will achieve it completely. Antoine Arnauld (1612–1694)
correctly described a quantitative formula for deciding what action to take in cases like this
(see Chapter 16). John Stuart Mill’s (1806–1873) book Utilitarianism (Mill, 1863) promoted
the idea of rational decision criteria in all spheres of human activity. The more formal theory
of decisions is discussed in the following section.

1.2.2 Mathematics
• What are the formal rules to draw valid conclusions?
• What can be computed?
• How do we reason with uncertain information?
Philosophers staked out some of the fundamental ideas of AI, but the leap to a formal science
required a level of mathematical formalization in three fundamental areas: logic, computation, and probability.
The idea of formal logic can be traced back to the philosophers of ancient Greece, but
its mathematical development really began with the work of George Boole (1815–1864), who

8

ALGORITHM

INCOMPLETENESS
THEOREM

COMPUTABLE

TRACTABILITY

NP-COMPLETENESS

Chapter 1.

Introduction

worked out the details of propositional, or Boolean, logic (Boole, 1847). In 1879, Gottlob
Frege (1848–1925) extended Boole’s logic to include objects and relations, creating the firstorder logic that is used today.4 Alfred Tarski (1902–1983) introduced a theory of reference
that shows how to relate the objects in a logic to objects in the real world.
The next step was to determine the limits of what could be done with logic and computation. The first nontrivial algorithm is thought to be Euclid’s algorithm for computing
greatest common divisors. The word algorithm (and the idea of studying them) comes from
al-Khowarazmi, a Persian mathematician of the 9th century, whose writings also introduced
Arabic numerals and algebra to Europe. Boole and others discussed algorithms for logical
deduction, and, by the late 19th century, efforts were under way to formalize general mathematical reasoning as logical deduction. In 1930, Kurt Gödel (1906–1978) showed that there
exists an effective procedure to prove any true statement in the first-order logic of Frege and
Russell, but that first-order logic could not capture the principle of mathematical induction
needed to characterize the natural numbers. In 1931, Gödel showed that limits on deduction do exist. His incompleteness theorem showed that in any formal theory as strong as
Peano arithmetic (the elementary theory of natural numbers), there are true statements that
are undecidable in the sense that they have no proof within the theory.
This fundamental result can also be interpreted as showing that some functions on the
integers cannot be represented by an algorithm—that is, they cannot be computed. This
motivated Alan Turing (1912–1954) to try to characterize exactly which functions are computable—capable of being computed. This notion is actually slightly problematic because
the notion of a computation or effective procedure really cannot be given a formal definition.
However, the Church–Turing thesis, which states that the Turing machine (Turing, 1936) is
capable of computing any computable function, is generally accepted as providing a sufficient
definition. Turing also showed that there were some functions that no Turing machine can
compute. For example, no machine can tell in general whether a given program will return
an answer on a given input or run forever.
Although decidability and computability are important to an understanding of computation, the notion of tractability has had an even greater impact. Roughly speaking, a problem
is called intractable if the time required to solve instances of the problem grows exponentially
with the size of the instances. The distinction between polynomial and exponential growth
in complexity was first emphasized in the mid-1960s (Cobham, 1964; Edmonds, 1965). It is
important because exponential growth means that even moderately large instances cannot be
solved in any reasonable time. Therefore, one should strive to divide the overall problem of
generating intelligent behavior into tractable subproblems rather than intractable ones.
How can one recognize an intractable problem? The theory of NP-completeness, pioneered by Steven Cook (1971) and Richard Karp (1972), provides a method. Cook and Karp
showed the existence of large classes of canonical combinatorial search and reasoning problems that are NP-complete. Any problem class to which the class of NP-complete problems
can be reduced is likely to be intractable. (Although it has not been proved that NP-complete
4

Frege’s proposed notation for first-order logic—an arcane combination of textual and geometric features—
never became popular.

Section 1.2.

PROBABILITY

The Foundations of Artificial Intelligence

9

problems are necessarily intractable, most theoreticians believe it.) These results contrast
with the optimism with which the popular press greeted the first computers—“Electronic
Super-Brains” that were “Faster than Einstein!” Despite the increasing speed of computers,
careful use of resources will characterize intelligent systems. Put crudely, the world is an
extremely large problem instance! Work in AI has helped explain why some instances of
NP-complete problems are hard, yet others are easy (Cheeseman et al., 1991).
Besides logic and computation, the third great contribution of mathematics to AI is the
theory of probability. The Italian Gerolamo Cardano (1501–1576) first framed the idea of
probability, describing it in terms of the possible outcomes of gambling events. In 1654,
Blaise Pascal (1623–1662), in a letter to Pierre Fermat (1601–1665), showed how to predict the future of an unfinished gambling game and assign average payoffs to the gamblers.
Probability quickly became an invaluable part of all the quantitative sciences, helping to deal
with uncertain measurements and incomplete theories. James Bernoulli (1654–1705), Pierre
Laplace (1749–1827), and others advanced the theory and introduced new statistical methods. Thomas Bayes (1702–1761), who appears on the front cover of this book, proposed
a rule for updating probabilities in the light of new evidence. Bayes’ rule underlies most
modern approaches to uncertain reasoning in AI systems.

1.2.3 Economics
• How should we make decisions so as to maximize payoff?
• How should we do this when others may not go along?
• How should we do this when the payoff may be far in the future?

UTILITY

DECISION THEORY

GAME THEORY

The science of economics got its start in 1776, when Scottish philosopher Adam Smith
(1723–1790) published An Inquiry into the Nature and Causes of the Wealth of Nations.
While the ancient Greeks and others had made contributions to economic thought, Smith was
the first to treat it as a science, using the idea that economies can be thought of as consisting of individual agents maximizing their own economic well-being. Most people think of
economics as being about money, but economists will say that they are really studying how
people make choices that lead to preferred outcomes. When McDonald’s offers a hamburger
for a dollar, they are asserting that they would prefer the dollar and hoping that customers will
prefer the hamburger. The mathematical treatment of “preferred outcomes” or utility was
first formalized by Léon Walras (pronounced “Valrasse”) (1834-1910) and was improved by
Frank Ramsey (1931) and later by John von Neumann and Oskar Morgenstern in their book
The Theory of Games and Economic Behavior (1944).
Decision theory, which combines probability theory with utility theory, provides a formal and complete framework for decisions (economic or otherwise) made under uncertainty—
that is, in cases where probabilistic descriptions appropriately capture the decision maker’s
environment. This is suitable for “large” economies where each agent need pay no attention
to the actions of other agents as individuals. For “small” economies, the situation is much
more like a game: the actions of one player can significantly affect the utility of another
(either positively or negatively). Von Neumann and Morgenstern’s development of game
theory (see also Luce and Raiffa, 1957) included the surprising result that, for some games,

10

OPERATIONS
RESEARCH

SATISFICING

Chapter 1.

Introduction

a rational agent should adopt policies that are (or least appear to be) randomized. Unlike decision theory, game theory does not offer an unambiguous prescription for selecting actions.
For the most part, economists did not address the third question listed above, namely,
how to make rational decisions when payoffs from actions are not immediate but instead result from several actions taken in sequence. This topic was pursued in the field of operations
research, which emerged in World War II from efforts in Britain to optimize radar installations, and later found civilian applications in complex management decisions. The work of
Richard Bellman (1957) formalized a class of sequential decision problems called Markov
decision processes, which we study in Chapters 17 and 21.
Work in economics and operations research has contributed much to our notion of rational agents, yet for many years AI research developed along entirely separate paths. One
reason was the apparent complexity of making rational decisions. The pioneering AI researcher Herbert Simon (1916–2001) won the Nobel Prize in economics in 1978 for his early
work showing that models based on satisficing—making decisions that are “good enough,”
rather than laboriously calculating an optimal decision—gave a better description of actual
human behavior (Simon, 1947). Since the 1990s, there has been a resurgence of interest in
decision-theoretic techniques for agent systems (Wellman, 1995).

1.2.4 Neuroscience
• How do brains process information?
NEUROSCIENCE

NEURON

Neuroscience is the study of the nervous system, particularly the brain. Although the exact
way in which the brain enables thought is one of the great mysteries of science, the fact that it
does enable thought has been appreciated for thousands of years because of the evidence that
strong blows to the head can lead to mental incapacitation. It has also long been known that
human brains are somehow different; in about 335 B . C . Aristotle wrote, “Of all the animals,
man has the largest brain in proportion to his size.” 5 Still, it was not until the middle of the
18th century that the brain was widely recognized as the seat of consciousness. Before then,
candidate locations included the heart and the spleen.
Paul Broca’s (1824–1880) study of aphasia (speech deficit) in brain-damaged patients
in 1861 demonstrated the existence of localized areas of the brain responsible for specific
cognitive functions. In particular, he showed that speech production was localized to the
portion of the left hemisphere now called Broca’s area. 6 By that time, it was known that
the brain consisted of nerve cells, or neurons, but it was not until 1873 that Camillo Golgi
(1843–1926) developed a staining technique allowing the observation of individual neurons
in the brain (see Figure 1.2). This technique was used by Santiago Ramon y Cajal (1852–
1934) in his pioneering studies of the brain’s neuronal structures.7 Nicolas Rashevsky (1936,
1938) was the first to apply mathematical models to the study of the nervous sytem.
5

Since then, it has been discovered that the tree shrew (Scandentia) has a higher ratio of brain to body mass.
Many cite Alexander Hood (1824) as a possible prior source.
7 Golgi persisted in his belief that the brain’s functions were carried out primarily in a continuous medium in
which neurons were embedded, whereas Cajal propounded the “neuronal doctrine.” The two shared the Nobel
prize in 1906 but gave mutually antagonistic acceptance speeches.
6

Section 1.2.

The Foundations of Artificial Intelligence

11

Axonal arborization
Axon from another cell
Synapse
Dendrite

Axon

Nucleus
Synapses
Cell body or Soma

Figure 1.2 The parts of a nerve cell or neuron. Each neuron consists of a cell body,
or soma, that contains a cell nucleus. Branching out from the cell body are a number of
fibers called dendrites and a single long fiber called the axon. The axon stretches out for a
long distance, much longer than the scale in this diagram indicates. Typically, an axon is
1 cm long (100 times the diameter of the cell body), but can reach up to 1 meter. A neuron
makes connections with 10 to 100,000 other neurons at junctions called synapses. Signals are
propagated from neuron to neuron by a complicated electrochemical reaction. The signals
control brain activity in the short term and also enable long-term changes in the connectivity
of neurons. These mechanisms are thought to form the basis for learning in the brain. Most
information processing goes on in the cerebral cortex, the outer layer of the brain. The basic
organizational unit appears to be a column of tissue about 0.5 mm in diameter, containing
about 20,000 neurons and extending the full depth of the cortex about 4 mm in humans).

We now have some data on the mapping between areas of the brain and the parts of the
body that they control or from which they receive sensory input. Such mappings are able to
change radically over the course of a few weeks, and some animals seem to have multiple
maps. Moreover, we do not fully understand how other areas can take over functions when
one area is damaged. There is almost no theory on how an individual memory is stored.
The measurement of intact brain activity began in 1929 with the invention by Hans
Berger of the electroencephalograph (EEG). The recent development of functional magnetic
resonance imaging (fMRI) (Ogawa et al., 1990; Cabeza and Nyberg, 2001) is giving neuroscientists unprecedentedly detailed images of brain activity, enabling measurements that
correspond in interesting ways to ongoing cognitive processes. These are augmented by
advances in single-cell recording of neuron activity. Individual neurons can be stimulated
electrically, chemically, or even optically (Han and Boyden, 2007), allowing neuronal input–
output relationships to be mapped. Despite these advances, we are still a long way from
understanding how cognitive processes actually work.
The truly amazing conclusion is that a collection of simple cells can lead to thought,
action, and consciousness or, in the pithy words of John Searle (1992), brains cause minds.

12

Chapter 1.
Supercomputer
104 CPUs, 1012 transistors
1014 bits RAM
1015 bits disk
Cycle time
10−9 sec
Operations/sec
1015
Memory updates/sec 1014
Computational units
Storage units

Introduction

Personal Computer

Human Brain

4 CPUs, 109 transistors
1011 bits RAM
1013 bits disk
10−9 sec
1010
1010

1011 neurons
1011 neurons
1014 synapses
10−3 sec
1017
1014

Figure 1.3 A crude comparison of the raw computational resources available to the IBM
B LUE G ENE supercomputer, a typical personal computer of 2008, and the human brain. The
brain’s numbers are essentially fixed, whereas the supercomputer’s numbers have been increasing by a factor of 10 every 5 years or so, allowing it to achieve rough parity with the
brain. The personal computer lags behind on all metrics except cycle time.

SINGULARITY

The only real alternative theory is mysticism: that minds operate in some mystical realm that
is beyond physical science.
Brains and digital computers have somewhat different properties. Figure 1.3 shows that
computers have a cycle time that is a million times faster than a brain. The brain makes up
for that with far more storage and interconnection than even a high-end personal computer,
although the largest supercomputers have a capacity that is similar to the brain’s. (It should
be noted, however, that the brain does not seem to use all of its neurons simultaneously.)
Futurists make much of these numbers, pointing to an approaching singularity at which
computers reach a superhuman level of performance (Vinge, 1993; Kurzweil, 2005), but the
raw comparisons are not especially informative. Even with a computer of virtually unlimited
capacity, we still would not know how to achieve the brain’s level of intelligence.

1.2.5 Psychology
• How do humans and animals think and act?

BEHAVIORISM

The origins of scientific psychology are usually traced to the work of the German physicist Hermann von Helmholtz (1821–1894) and his student Wilhelm Wundt (1832–1920).
Helmholtz applied the scientific method to the study of human vision, and his Handbook
of Physiological Optics is even now described as “the single most important treatise on the
physics and physiology of human vision” (Nalwa, 1993, p.15). In 1879, Wundt opened the
first laboratory of experimental psychology, at the University of Leipzig. Wundt insisted
on carefully controlled experiments in which his workers would perform a perceptual or associative task while introspecting on their thought processes. The careful controls went a
long way toward making psychology a science, but the subjective nature of the data made
it unlikely that an experimenter would ever disconfirm his or her own theories. Biologists
studying animal behavior, on the other hand, lacked introspective data and developed an objective methodology, as described by H. S. Jennings (1906) in his influential work Behavior of
the Lower Organisms. Applying this viewpoint to humans, the behaviorism movement, led
by John Watson (1878–1958), rejected any theory involving mental processes on the grounds

Section 1.2.

COGNITIVE
PSYCHOLOGY

The Foundations of Artificial Intelligence

13

that introspection could not provide reliable evidence. Behaviorists insisted on studying only
objective measures of the percepts (or stimulus) given to an animal and its resulting actions
(or response). Behaviorism discovered a lot about rats and pigeons but had less success at
understanding humans.
Cognitive psychology, which views the brain as an information-processing device,
can be traced back at least to the works of William James (1842–1910). Helmholtz also
insisted that perception involved a form of unconscious logical inference. The cognitive
viewpoint was largely eclipsed by behaviorism in the United States, but at Cambridge’s Applied Psychology Unit, directed by Frederic Bartlett (1886–1969), cognitive modeling was
able to flourish. The Nature of Explanation, by Bartlett’s student and successor Kenneth
Craik (1943), forcefully reestablished the legitimacy of such “mental” terms as beliefs and
goals, arguing that they are just as scientific as, say, using pressure and temperature to talk
about gases, despite their being made of molecules that have neither. Craik specified the
three key steps of a knowledge-based agent: (1) the stimulus must be translated into an internal representation, (2) the representation is manipulated by cognitive processes to derive new
internal representations, and (3) these are in turn retranslated back into action. He clearly
explained why this was a good design for an agent:
If the organism carries a “small-scale model” of external reality and of its own possible
actions within its head, it is able to try out various alternatives, conclude which is the best
of them, react to future situations before they arise, utilize the knowledge of past events
in dealing with the present and future, and in every way to react in a much fuller, safer,
and more competent manner to the emergencies which face it. (Craik, 1943)

After Craik’s death in a bicycle accident in 1945, his work was continued by Donald Broadbent, whose book Perception and Communication (1958) was one of the first works to model
psychological phenomena as information processing. Meanwhile, in the United States, the
development of computer modeling led to the creation of the field of cognitive science. The
field can be said to have started at a workshop in September 1956 at MIT. (We shall see that
this is just two months after the conference at which AI itself was “born.”) At the workshop,
George Miller presented The Magic Number Seven, Noam Chomsky presented Three Models
of Language, and Allen Newell and Herbert Simon presented The Logic Theory Machine.
These three influential papers showed how computer models could be used to address the
psychology of memory, language, and logical thinking, respectively. It is now a common
(although far from universal) view among psychologists that “a cognitive theory should be
like a computer program” (Anderson, 1980); that is, it should describe a detailed informationprocessing mechanism whereby some cognitive function might be implemented.

1.2.6 Computer engineering
• How can we build an efficient computer?
For artificial intelligence to succeed, we need two things: intelligence and an artifact. The
computer has been the artifact of choice. The modern digital electronic computer was invented independently and almost simultaneously by scientists in three countries embattled in

14

Chapter 1.

Introduction

World War II. The first operational computer was the electromechanical Heath Robinson,8
built in 1940 by Alan Turing’s team for a single purpose: deciphering German messages. In
1943, the same group developed the Colossus, a powerful general-purpose machine based
on vacuum tubes.9 The first operational programmable computer was the Z-3, the invention of Konrad Zuse in Germany in 1941. Zuse also invented floating-point numbers and the
first high-level programming language, Plankalkül. The first electronic computer, the ABC,
was assembled by John Atanasoff and his student Clifford Berry between 1940 and 1942
at Iowa State University. Atanasoff’s research received little support or recognition; it was
the ENIAC, developed as part of a secret military project at the University of Pennsylvania
by a team including John Mauchly and John Eckert, that proved to be the most influential
forerunner of modern computers.
Since that time, each generation of computer hardware has brought an increase in speed
and capacity and a decrease in price. Performance doubled every 18 months or so until around
2005, when power dissipation problems led manufacturers to start multiplying the number of
CPU cores rather than the clock speed. Current expectations are that future increases in power
will come from massive parallelism—a curious convergence with the properties of the brain.
Of course, there were calculating devices before the electronic computer. The earliest
automated machines, dating from the 17th century, were discussed on page 6. The first programmable machine was a loom, devised in 1805 by Joseph Marie Jacquard (1752–1834),
that used punched cards to store instructions for the pattern to be woven. In the mid-19th
century, Charles Babbage (1792–1871) designed two machines, neither of which he completed. The Difference Engine was intended to compute mathematical tables for engineering
and scientific projects. It was finally built and shown to work in 1991 at the Science Museum
in London (Swade, 2000). Babbage’s Analytical Engine was far more ambitious: it included
addressable memory, stored programs, and conditional jumps and was the first artifact capable of universal computation. Babbage’s colleague Ada Lovelace, daughter of the poet Lord
Byron, was perhaps the world’s first programmer. (The programming language Ada is named
after her.) She wrote programs for the unfinished Analytical Engine and even speculated that
the machine could play chess or compose music.
AI also owes a debt to the software side of computer science, which has supplied the
operating systems, programming languages, and tools needed to write modern programs (and
papers about them). But this is one area where the debt has been repaid: work in AI has pioneered many ideas that have made their way back to mainstream computer science, including
time sharing, interactive interpreters, personal computers with windows and mice, rapid development environments, the linked list data type, automatic storage management, and key
concepts of symbolic, functional, declarative, and object-oriented programming.

8 Heath Robinson was a cartoonist famous for his depictions of whimsical and absurdly complicated contraptions for everyday tasks such as buttering toast.
9 In the postwar period, Turing wanted to use these computers for AI research—for example, one of the first
chess programs (Turing et al., 1953). His efforts were blocked by the British government.

Section 1.2.

The Foundations of Artificial Intelligence

15

1.2.7 Control theory and cybernetics
• How can artifacts operate under their own control?

CONTROL THEORY

CYBERNETICS

HOMEOSTATIC

OBJECTIVE
FUNCTION

Ktesibios of Alexandria (c. 250 B . C .) built the first self-controlling machine: a water clock
with a regulator that maintained a constant flow rate. This invention changed the definition
of what an artifact could do. Previously, only living things could modify their behavior in
response to changes in the environment. Other examples of self-regulating feedback control
systems include the steam engine governor, created by James Watt (1736–1819), and the
thermostat, invented by Cornelis Drebbel (1572–1633), who also invented the submarine.
The mathematical theory of stable feedback systems was developed in the 19th century.
The central figure in the creation of what is now called control theory was Norbert
Wiener (1894–1964). Wiener was a brilliant mathematician who worked with Bertrand Russell, among others, before developing an interest in biological and mechanical control systems
and their connection to cognition. Like Craik (who also used control systems as psychological
models), Wiener and his colleagues Arturo Rosenblueth and Julian Bigelow challenged the
behaviorist orthodoxy (Rosenblueth et al., 1943). They viewed purposive behavior as arising from a regulatory mechanism trying to minimize “error”—the difference between current
state and goal state. In the late 1940s, Wiener, along with Warren McCulloch, Walter Pitts,
and John von Neumann, organized a series of influential conferences that explored the new
mathematical and computational models of cognition. Wiener’s book Cybernetics (1948) became a bestseller and awoke the public to the possibility of artificially intelligent machines.
Meanwhile, in Britain, W. Ross Ashby (Ashby, 1940) pioneered similar ideas. Ashby, Alan
Turing, Grey Walter, and others formed the Ratio Club for “those who had Wiener’s ideas
before Wiener’s book appeared.” Ashby’s Design for a Brain (1948, 1952) elaborated on his
idea that intelligence could be created by the use of homeostatic devices containing appropriate feedback loops to achieve stable adaptive behavior.
Modern control theory, especially the branch known as stochastic optimal control, has
as its goal the design of systems that maximize an objective function over time. This roughly
matches our view of AI: designing systems that behave optimally. Why, then, are AI and
control theory two different fields, despite the close connections among their founders? The
answer lies in the close coupling between the mathematical techniques that were familiar to
the participants and the corresponding sets of problems that were encompassed in each world
view. Calculus and matrix algebra, the tools of control theory, lend themselves to systems that
are describable by fixed sets of continuous variables, whereas AI was founded in part as a way
to escape from the these perceived limitations. The tools of logical inference and computation
allowed AI researchers to consider problems such as language, vision, and planning that fell
completely outside the control theorist’s purview.

1.2.8 Linguistics
• How does language relate to thought?
In 1957, B. F. Skinner published Verbal Behavior. This was a comprehensive, detailed account of the behaviorist approach to language learning, written by the foremost expert in

16

Chapter 1.

COMPUTATIONAL
LINGUISTICS

1.3

Introduction

the field. But curiously, a review of the book became as well known as the book itself, and
served to almost kill off interest in behaviorism. The author of the review was the linguist
Noam Chomsky, who had just published a book on his own theory, Syntactic Structures.
Chomsky pointed out that the behaviorist theory did not address the notion of creativity in
language—it did not explain how a child could understand and make up sentences that he or
she had never heard before. Chomsky’s theory—based on syntactic models going back to the
Indian linguist Panini (c. 350 B . C .)—could explain this, and unlike previous theories, it was
formal enough that it could in principle be programmed.
Modern linguistics and AI, then, were “born” at about the same time, and grew up
together, intersecting in a hybrid field called computational linguistics or natural language
processing. The problem of understanding language soon turned out to be considerably more
complex than it seemed in 1957. Understanding language requires an understanding of the
subject matter and context, not just an understanding of the structure of sentences. This might
seem obvious, but it was not widely appreciated until the 1960s. Much of the early work in
knowledge representation (the study of how to put knowledge into a form that a computer
can reason with) was tied to language and informed by research in linguistics, which was
connected in turn to decades of work on the philosophical analysis of language.

T HE H ISTORY OF A RTIFICIAL I NTELLIGENCE
With the background material behind us, we are ready to cover the development of AI itself.

1.3.1 The gestation of artificial intelligence (1943–1955)

HEBBIAN LEARNING

The first work that is now generally recognized as AI was done by Warren McCulloch and
Walter Pitts (1943). They drew on three sources: knowledge of the basic physiology and
function of neurons in the brain; a formal analysis of propositional logic due to Russell and
Whitehead; and Turing’s theory of computation. They proposed a model of artificial neurons
in which each neuron is characterized as being “on” or “off,” with a switch to “on” occurring
in response to stimulation by a sufficient number of neighboring neurons. The state of a
neuron was conceived of as “factually equivalent to a proposition which proposed its adequate
stimulus.” They showed, for example, that any computable function could be computed by
some network of connected neurons, and that all the logical connectives (and, or, not, etc.)
could be implemented by simple net structures. McCulloch and Pitts also suggested that
suitably defined networks could learn. Donald Hebb (1949) demonstrated a simple updating
rule for modifying the connection strengths between neurons. His rule, now called Hebbian
learning, remains an influential model to this day.
Two undergraduate students at Harvard, Marvin Minsky and Dean Edmonds, built the
first neural network computer in 1950. The S NARC, as it was called, used 3000 vacuum
tubes and a surplus automatic pilot mechanism from a B-24 bomber to simulate a network of
40 neurons. Later, at Princeton, Minsky studied universal computation in neural networks.
His Ph.D. committee was skeptical about whether this kind of work should be considered

Section 1.3.

The History of Artificial Intelligence

17

mathematics, but von Neumann reportedly said, “If it isn’t now, it will be someday.” Minsky
was later to prove influential theorems showing the limitations of neural network research.
There were a number of early examples of work that can be characterized as AI, but
Alan Turing’s vision was perhaps the most influential. He gave lectures on the topic as early
as 1947 at the London Mathematical Society and articulated a persuasive agenda in his 1950
article “Computing Machinery and Intelligence.” Therein, he introduced the Turing Test,
machine learning, genetic algorithms, and reinforcement learning. He proposed the Child
Programme idea, explaining “Instead of trying to produce a programme to simulate the adult
mind, why not rather try to produce one which simulated the child’s?”

1.3.2 The birth of artificial intelligence (1956)
Princeton was home to another influential figure in AI, John McCarthy. After receiving his
PhD there in 1951 and working for two years as an instructor, McCarthy moved to Stanford and then to Dartmouth College, which was to become the official birthplace of the field.
McCarthy convinced Minsky, Claude Shannon, and Nathaniel Rochester to help him bring
together U.S. researchers interested in automata theory, neural nets, and the study of intelligence. They organized a two-month workshop at Dartmouth in the summer of 1956. The
proposal states:10
We propose that a 2 month, 10 man study of artificial intelligence be carried
out during the summer of 1956 at Dartmouth College in Hanover, New Hampshire. The study is to proceed on the basis of the conjecture that every aspect of
learning or any other feature of intelligence can in principle be so precisely described that a machine can be made to simulate it. An attempt will be made to find
how to make machines use language, form abstractions and concepts, solve kinds
of problems now reserved for humans, and improve themselves. We think that a
significant advance can be made in one or more of these problems if a carefully
selected group of scientists work on it together for a summer.
There were 10 attendees in all, including Trenchard More from Princeton, Arthur Samuel
from IBM, and Ray Solomonoff and Oliver Selfridge from MIT.
Two researchers from Carnegie Tech, 11 Allen Newell and Herbert Simon, rather stole
the show. Although the others had ideas and in some cases programs for particular applications such as checkers, Newell and Simon already had a reasoning program, the Logic
Theorist (LT), about which Simon claimed, “We have invented a computer program capable
of thinking non-numerically, and thereby solved the venerable mind–body problem.”12 Soon
after the workshop, the program was able to prove most of the theorems in Chapter 2 of Rus10 This was the first official usage of McCarthy’s term artificial intelligence. Perhaps “computational rationality”
would have been more precise and less threatening, but “AI” has stuck. At the 50th anniversary of the Dartmouth
conference, McCarthy stated that he resisted the terms “computer” or “computational” in deference to Norbert
Weiner, who was promoting analog cybernetic devices rather than digital computers.
11 Now Carnegie Mellon University (CMU).
12 Newell and Simon also invented a list-processing language, IPL, to write LT. They had no compiler and
translated it into machine code by hand. To avoid errors, they worked in parallel, calling out binary numbers to
each other as they wrote each instruction to make sure they agreed.

18

Chapter 1.

Introduction

sell and Whitehead’s Principia Mathematica. Russell was reportedly delighted when Simon
showed him that the program had come up with a proof for one theorem that was shorter than
the one in Principia. The editors of the Journal of Symbolic Logic were less impressed; they
rejected a paper coauthored by Newell, Simon, and Logic Theorist.
The Dartmouth workshop did not lead to any new breakthroughs, but it did introduce
all the major figures to each other. For the next 20 years, the field would be dominated by
these people and their students and colleagues at MIT, CMU, Stanford, and IBM.
Looking at the proposal for the Dartmouth workshop (McCarthy et al., 1955), we can
see why it was necessary for AI to become a separate field. Why couldn’t all the work done
in AI have taken place under the name of control theory or operations research or decision
theory, which, after all, have objectives similar to those of AI? Or why isn’t AI a branch
of mathematics? The first answer is that AI from the start embraced the idea of duplicating
human faculties such as creativity, self-improvement, and language use. None of the other
fields were addressing these issues. The second answer is methodology. AI is the only one
of these fields that is clearly a branch of computer science (although operations research does
share an emphasis on computer simulations), and AI is the only field to attempt to build
machines that will function autonomously in complex, changing environments.

1.3.3 Early enthusiasm, great expectations (1952–1969)

PHYSICAL SYMBOL
SYSTEM

The early years of AI were full of successes—in a limited way. Given the primitive computers and programming tools of the time and the fact that only a few years earlier computers
were seen as things that could do arithmetic and no more, it was astonishing whenever a computer did anything remotely clever. The intellectual establishment, by and large, preferred to
believe that “a machine can never do X.” (See Chapter 26 for a long list of X’s gathered
by Turing.) AI researchers naturally responded by demonstrating one X after another. John
McCarthy referred to this period as the “Look, Ma, no hands!” era.
Newell and Simon’s early success was followed up with the General Problem Solver,
or GPS. Unlike Logic Theorist, this program was designed from the start to imitate human
problem-solving protocols. Within the limited class of puzzles it could handle, it turned out
that the order in which the program considered subgoals and possible actions was similar to
that in which humans approached the same problems. Thus, GPS was probably the first program to embody the “thinking humanly” approach. The success of GPS and subsequent programs as models of cognition led Newell and Simon (1976) to formulate the famous physical
symbol system hypothesis, which states that “a physical symbol system has the necessary and
sufficient means for general intelligent action.” What they meant is that any system (human
or machine) exhibiting intelligence must operate by manipulating data structures composed
of symbols. We will see later that this hypothesis has been challenged from many directions.
At IBM, Nathaniel Rochester and his colleagues produced some of the first AI programs. Herbert Gelernter (1959) constructed the Geometry Theorem Prover, which was
able to prove theorems that many students of mathematics would find quite tricky. Starting
in 1952, Arthur Samuel wrote a series of programs for checkers (draughts) that eventually
learned to play at a strong amateur level. Along the way, he disproved the idea that comput-

Section 1.3.

LISP

MICROWORLD

The History of Artificial Intelligence

19

ers can do only what they are told to: his program quickly learned to play a better game than
its creator. The program was demonstrated on television in February 1956, creating a strong
impression. Like Turing, Samuel had trouble finding computer time. Working at night, he
used machines that were still on the testing floor at IBM’s manufacturing plant. Chapter 5
covers game playing, and Chapter 21 explains the learning techniques used by Samuel.
John McCarthy moved from Dartmouth to MIT and there made three crucial contributions in one historic year: 1958. In MIT AI Lab Memo No. 1, McCarthy defined the high-level
language Lisp, which was to become the dominant AI programming language for the next 30
years. With Lisp, McCarthy had the tool he needed, but access to scarce and expensive computing resources was also a serious problem. In response, he and others at MIT invented time
sharing. Also in 1958, McCarthy published a paper entitled Programs with Common Sense,
in which he described the Advice Taker, a hypothetical program that can be seen as the first
complete AI system. Like the Logic Theorist and Geometry Theorem Prover, McCarthy’s
program was designed to use knowledge to search for solutions to problems. But unlike the
others, it was to embody general knowledge of the world. For example, he showed how
some simple axioms would enable the program to generate a plan to drive to the airport. The
program was also designed to accept new axioms in the normal course of operation, thereby
allowing it to achieve competence in new areas without being reprogrammed. The Advice
Taker thus embodied the central principles of knowledge representation and reasoning: that
it is useful to have a formal, explicit representation of the world and its workings and to be
able to manipulate that representation with deductive processes. It is remarkable how much
of the 1958 paper remains relevant today.
1958 also marked the year that Marvin Minsky moved to MIT. His initial collaboration
with McCarthy did not last, however. McCarthy stressed representation and reasoning in formal logic, whereas Minsky was more interested in getting programs to work and eventually
developed an anti-logic outlook. In 1963, McCarthy started the AI lab at Stanford. His plan
to use logic to build the ultimate Advice Taker was advanced by J. A. Robinson’s discovery in 1965 of the resolution method (a complete theorem-proving algorithm for first-order
logic; see Chapter 9). Work at Stanford emphasized general-purpose methods for logical
reasoning. Applications of logic included Cordell Green’s question-answering and planning
systems (Green, 1969b) and the Shakey robotics project at the Stanford Research Institute
(SRI). The latter project, discussed further in Chapter 25, was the first to demonstrate the
complete integration of logical reasoning and physical activity.
Minsky supervised a series of students who chose limited problems that appeared to
require intelligence to solve. These limited domains became known as microworlds. James
Slagle’s S AINT program (1963) was able to solve closed-form calculus integration problems
typical of first-year college courses. Tom Evans’s A NALOGY program (1968) solved geometric analogy problems that appear in IQ tests. Daniel Bobrow’s S TUDENT program (1967)
solved algebra story problems, such as the following:
If the number of customers Tom gets is twice the square of 20 percent of the number
of advertisements he runs, and the number of advertisements he runs is 45, what is the
number of customers Tom gets?

20

Chapter 1.

Introduction

Blue

Red
Red

Green
Blue

Green
Green

Red

Figure 1.4 A scene from the blocks world. S HRDLU (Winograd, 1972) has just completed
the command “Find a block which is taller than the one you are holding and put it in the box.”

The most famous microworld was the blocks world, which consists of a set of solid blocks
placed on a tabletop (or more often, a simulation of a tabletop), as shown in Figure 1.4.
A typical task in this world is to rearrange the blocks in a certain way, using a robot hand
that can pick up one block at a time. The blocks world was home to the vision project of
David Huffman (1971), the vision and constraint-propagation work of David Waltz (1975),
the learning theory of Patrick Winston (1970), the natural-language-understanding program
of Terry Winograd (1972), and the planner of Scott Fahlman (1974).
Early work building on the neural networks of McCulloch and Pitts also flourished.
The work of Winograd and Cowan (1963) showed how a large number of elements could
collectively represent an individual concept, with a corresponding increase in robustness and
parallelism. Hebb’s learning methods were enhanced by Bernie Widrow (Widrow and Hoff,
1960; Widrow, 1962), who called his networks adalines, and by Frank Rosenblatt (1962)
with his perceptrons. The perceptron convergence theorem (Block et al., 1962) says that
the learning algorithm can adjust the connection strengths of a perceptron to match any input
data, provided such a match exists. These topics are covered in Chapter 20.

1.3.4 A dose of reality (1966–1973)
From the beginning, AI researchers were not shy about making predictions of their coming
successes. The following statement by Herbert Simon in 1957 is often quoted:
It is not my aim to surprise or shock you—but the simplest way I can summarize is to say
that there are now in the world machines that think, that learn and that create. Moreover,

Section 1.3.

The History of Artificial Intelligence

21

their ability to do these things is going to increase rapidly until—in a visible future—the
range of problems they can handle will be coextensive with the range to which the human
mind has been applied.

MACHINE EVOLUTION
GENETIC
ALGORITHM

Terms such as “visible future” can be interpreted in various ways, but Simon also made
more concrete predictions: that within 10 years a computer would be chess champion, and
a significant mathematical theorem would be proved by machine. These predictions came
true (or approximately true) within 40 years rather than 10. Simon’s overconfidence was due
to the promising performance of early AI systems on simple examples. In almost all cases,
however, these early systems turned out to fail miserably when tried out on wider selections
of problems and on more difficult problems.
The first kind of difficulty arose because most early programs knew nothing of their
subject matter; they succeeded by means of simple syntactic manipulations. A typical story
occurred in early machine translation efforts, which were generously funded by the U.S. National Research Council in an attempt to speed up the translation of Russian scientific papers
in the wake of the Sputnik launch in 1957. It was thought initially that simple syntactic transformations based on the grammars of Russian and English, and word replacement from an
electronic dictionary, would suffice to preserve the exact meanings of sentences. The fact is
that accurate translation requires background knowledge in order to resolve ambiguity and
establish the content of the sentence. The famous retranslation of “the spirit is willing but
the flesh is weak” as “the vodka is good but the meat is rotten” illustrates the difficulties encountered. In 1966, a report by an advisory committee found that “there has been no machine
translation of general scientific text, and none is in immediate prospect.” All U.S. government
funding for academic translation projects was canceled. Today, machine translation is an imperfect but widely used tool for technical, commercial, government, and Internet documents.
The second kind of difficulty was the intractability of many of the problems that AI was
attempting to solve. Most of the early AI programs solved problems by trying out different
combinations of steps until the solution was found. This strategy worked initially because
microworlds contained very few objects and hence very few possible actions and very short
solution sequences. Before the theory of computational complexity was developed, it was
widely thought that “scaling up” to larger problems was simply a matter of faster hardware
and larger memories. The optimism that accompanied the development of resolution theorem
proving, for example, was soon dampened when researchers failed to prove theorems involving more than a few dozen facts. The fact that a program can find a solution in principle does
not mean that the program contains any of the mechanisms needed to find it in practice.
The illusion of unlimited computational power was not confined to problem-solving
programs. Early experiments in machine evolution (now called genetic algorithms) (Friedberg, 1958; Friedberg et al., 1959) were based on the undoubtedly correct belief that by
making an appropriate series of small mutations to a machine-code program, one can generate a program with good performance for any particular task. The idea, then, was to try
random mutations with a selection process to preserve mutations that seemed useful. Despite thousands of hours of CPU time, almost no progress was demonstrated. Modern genetic
algorithms use better representations and have shown more success.

22

Chapter 1.

Introduction

Failure to come to grips with the “combinatorial explosion” was one of the main criticisms of AI contained in the Lighthill report (Lighthill, 1973), which formed the basis for the
decision by the British government to end support for AI research in all but two universities.
(Oral tradition paints a somewhat different and more colorful picture, with political ambitions
and personal animosities whose description is beside the point.)
A third difficulty arose because of some fundamental limitations on the basic structures
being used to generate intelligent behavior. For example, Minsky and Papert’s book Perceptrons (1969) proved that, although perceptrons (a simple form of neural network) could be
shown to learn anything they were capable of representing, they could represent very little. In
particular, a two-input perceptron (restricted to be simpler than the form Rosenblatt originally
studied) could not be trained to recognize when its two inputs were different. Although their
results did not apply to more complex, multilayer networks, research funding for neural-net
research soon dwindled to almost nothing. Ironically, the new back-propagation learning algorithms for multilayer networks that were to cause an enormous resurgence in neural-net
research in the late 1980s were actually discovered first in 1969 (Bryson and Ho, 1969).

1.3.5 Knowledge-based systems: The key to power? (1969–1979)

WEAK METHOD

The picture of problem solving that had arisen during the first decade of AI research was of
a general-purpose search mechanism trying to string together elementary reasoning steps to
find complete solutions. Such approaches have been called weak methods because, although
general, they do not scale up to large or difficult problem instances. The alternative to weak
methods is to use more powerful, domain-specific knowledge that allows larger reasoning
steps and can more easily handle typically occurring cases in narrow areas of expertise. One
might say that to solve a hard problem, you have to almost know the answer already.
The D ENDRAL program (Buchanan et al., 1969) was an early example of this approach.
It was developed at Stanford, where Ed Feigenbaum (a former student of Herbert Simon),
Bruce Buchanan (a philosopher turned computer scientist), and Joshua Lederberg (a Nobel
laureate geneticist) teamed up to solve the problem of inferring molecular structure from the
information provided by a mass spectrometer. The input to the program consists of the elementary formula of the molecule (e.g., C6 H13 NO2 ) and the mass spectrum giving the masses
of the various fragments of the molecule generated when it is bombarded by an electron beam.
For example, the mass spectrum might contain a peak at m = 15, corresponding to the mass
of a methyl (CH3 ) fragment.
The naive version of the program generated all possible structures consistent with the
formula, and then predicted what mass spectrum would be observed for each, comparing this
with the actual spectrum. As one might expect, this is intractable for even moderate-sized
molecules. The D ENDRAL researchers consulted analytical chemists and found that they
worked by looking for well-known patterns of peaks in the spectrum that suggested common
substructures in the molecule. For example, the following rule is used to recognize a ketone
(C=O) subgroup (which weighs 28):
if there are two peaks at x1 and x2 such that
(a) x1 + x2 = M + 28 (M is the mass of the whole molecule);

Section 1.3.

The History of Artificial Intelligence

23

(b) x1 − 28 is a high peak;
(c) x2 − 28 is a high peak;
(d) At least one of x1 and x2 is high.
then there is a ketone subgroup

Recognizing that the molecule contains a particular substructure reduces the number of possible candidates enormously. D ENDRAL was powerful because
All the relevant theoretical knowledge to solve these problems has been mapped over from
its general form in the [spectrum prediction component] (“first principles”) to efficient
special forms (“cookbook recipes”). (Feigenbaum et al., 1971)

EXPERT SYSTEMS

CERTAINTY FACTOR

The significance of D ENDRAL was that it was the first successful knowledge-intensive system: its expertise derived from large numbers of special-purpose rules. Later systems also
incorporated the main theme of McCarthy’s Advice Taker approach—the clean separation of
the knowledge (in the form of rules) from the reasoning component.
With this lesson in mind, Feigenbaum and others at Stanford began the Heuristic Programming Project (HPP) to investigate the extent to which the new methodology of expert
systems could be applied to other areas of human expertise. The next major effort was in
the area of medical diagnosis. Feigenbaum, Buchanan, and Dr. Edward Shortliffe developed
M YCIN to diagnose blood infections. With about 450 rules, M YCIN was able to perform
as well as some experts, and considerably better than junior doctors. It also contained two
major differences from D ENDRAL. First, unlike the D ENDRAL rules, no general theoretical
model existed from which the M YCIN rules could be deduced. They had to be acquired from
extensive interviewing of experts, who in turn acquired them from textbooks, other experts,
and direct experience of cases. Second, the rules had to reflect the uncertainty associated with
medical knowledge. M YCIN incorporated a calculus of uncertainty called certainty factors
(see Chapter 14), which seemed (at the time) to fit well with how doctors assessed the impact
of evidence on the diagnosis.
The importance of domain knowledge was also apparent in the area of understanding
natural language. Although Winograd’s S HRDLU system for understanding natural language
had engendered a good deal of excitement, its dependence on syntactic analysis caused some
of the same problems as occurred in the early machine translation work. It was able to
overcome ambiguity and understand pronoun references, but this was mainly because it was
designed specifically for one area—the blocks world. Several researchers, including Eugene
Charniak, a fellow graduate student of Winograd’s at MIT, suggested that robust language
understanding would require general knowledge about the world and a general method for
using that knowledge.
At Yale, linguist-turned-AI-researcher Roger Schank emphasized this point, claiming,
“There is no such thing as syntax,” which upset a lot of linguists but did serve to start a useful
discussion. Schank and his students built a series of programs (Schank and Abelson, 1977;
Wilensky, 1978; Schank and Riesbeck, 1981; Dyer, 1983) that all had the task of understanding natural language. The emphasis, however, was less on language per se and more on
the problems of representing and reasoning with the knowledge required for language understanding. The problems included representing stereotypical situations (Cullingford, 1981),

24

FRAMES

Chapter 1.

Introduction

describing human memory organization (Rieger, 1976; Kolodner, 1983), and understanding
plans and goals (Wilensky, 1983).
The widespread growth of applications to real-world problems caused a concurrent increase in the demands for workable knowledge representation schemes. A large number
of different representation and reasoning languages were developed. Some were based on
logic—for example, the Prolog language became popular in Europe, and the P LANNER family in the United States. Others, following Minsky’s idea of frames (1975), adopted a more
structured approach, assembling facts about particular object and event types and arranging
the types into a large taxonomic hierarchy analogous to a biological taxonomy.

1.3.6 AI becomes an industry (1980–present)
The first successful commercial expert system, R1, began operation at the Digital Equipment
Corporation (McDermott, 1982). The program helped configure orders for new computer
systems; by 1986, it was saving the company an estimated $40 million a year. By 1988,
DEC’s AI group had 40 expert systems deployed, with more on the way. DuPont had 100 in
use and 500 in development, saving an estimated $10 million a year. Nearly every major U.S.
corporation had its own AI group and was either using or investigating expert systems.
In 1981, the Japanese announced the “Fifth Generation” project, a 10-year plan to build
intelligent computers running Prolog. In response, the United States formed the Microelectronics and Computer Technology Corporation (MCC) as a research consortium designed to
assure national competitiveness. In both cases, AI was part of a broad effort, including chip
design and human-interface research. In Britain, the Alvey report reinstated the funding that
was cut by the Lighthill report.13 In all three countries, however, the projects never met their
ambitious goals.
Overall, the AI industry boomed from a few million dollars in 1980 to billions of dollars
in 1988, including hundreds of companies building expert systems, vision systems, robots,
and software and hardware specialized for these purposes. Soon after that came a period
called the “AI Winter,” in which many companies fell by the wayside as they failed to deliver
on extravagant promises.

1.3.7 The return of neural networks (1986–present)
BACK-PROPAGATION

CONNECTIONIST

In the mid-1980s at least four different groups reinvented the back-propagation learning
algorithm first found in 1969 by Bryson and Ho. The algorithm was applied to many learning problems in computer science and psychology, and the widespread dissemination of the
results in the collection Parallel Distributed Processing (Rumelhart and McClelland, 1986)
caused great excitement.
These so-called connectionist models of intelligent systems were seen by some as direct competitors both to the symbolic models promoted by Newell and Simon and to the
logicist approach of McCarthy and others (Smolensky, 1988). It might seem obvious that
at some level humans manipulate symbols—in fact, Terrence Deacon’s book The Symbolic
13 To save embarrassment, a new field called IKBS (Intelligent Knowledge-Based Systems) was invented because

Artificial Intelligence had been officially canceled.

Section 1.3.

The History of Artificial Intelligence

25

Species (1997) suggests that this is the defining characteristic of humans—but the most ardent connectionists questioned whether symbol manipulation had any real explanatory role in
detailed models of cognition. This question remains unanswered, but the current view is that
connectionist and symbolic approaches are complementary, not competing. As occurred with
the separation of AI and cognitive science, modern neural network research has bifurcated
into two fields, one concerned with creating effective network architectures and algorithms
and understanding their mathematical properties, the other concerned with careful modeling
of the empirical properties of actual neurons and ensembles of neurons.

1.3.8 AI adopts the scientific method (1987–present)
Recent years have seen a revolution in both the content and the methodology of work in
artificial intelligence.14 It is now more common to build on existing theories than to propose
brand-new ones, to base claims on rigorous theorems or hard experimental evidence rather
than on intuition, and to show relevance to real-world applications rather than toy examples.
AI was founded in part as a rebellion against the limitations of existing fields like control
theory and statistics, but now it is embracing those fields. As David McAllester (1998) put it:
In the early period of AI it seemed plausible that new forms of symbolic computation,
e.g., frames and semantic networks, made much of classical theory obsolete. This led to
a form of isolationism in which AI became largely separated from the rest of computer
science. This isolationism is currently being abandoned. There is a recognition that
machine learning should not be isolated from information theory, that uncertain reasoning
should not be isolated from stochastic modeling, that search should not be isolated from
classical optimization and control, and that automated reasoning should not be isolated
from formal methods and static analysis.

HIDDEN MARKOV
MODELS

In terms of methodology, AI has finally come firmly under the scientific method. To be accepted, hypotheses must be subjected to rigorous empirical experiments, and the results must
be analyzed statistically for their importance (Cohen, 1995). It is now possible to replicate
experiments by using shared repositories of test data and code.
The field of speech recognition illustrates the pattern. In the 1970s, a wide variety of
different architectures and approaches were tried. Many of these were rather ad hoc and
fragile, and were demonstrated on only a few specially selected examples. In recent years,
approaches based on hidden Markov models (HMMs) have come to dominate the area. Two
aspects of HMMs are relevant. First, they are based on a rigorous mathematical theory. This
has allowed speech researchers to build on several decades of mathematical results developed
in other fields. Second, they are generated by a process of training on a large corpus of
real speech data. This ensures that the performance is robust, and in rigorous blind tests the
HMMs have been improving their scores steadily. Speech technology and the related field of
handwritten character recognition are already making the transition to widespread industrial
14 Some have characterized this change as a victory of the neats—those who think that AI theories should be

grounded in mathematical rigor—over the scruffies—those who would rather try out lots of ideas, write some
programs, and then assess what seems to be working. Both approaches are important. A shift toward neatness
implies that the field has reached a level of stability and maturity. Whether that stability will be disrupted by a
new scruffy idea is another question.

26

DATA MINING

BAYESIAN NETWORK

Chapter 1.

Introduction

and consumer applications. Note that there is no scientific claim that humans use HMMs to
recognize speech; rather, HMMs provide a mathematical framework for understanding the
problem and support the engineering claim that they work well in practice.
Machine translation follows the same course as speech recognition. In the 1950s there
was initial enthusiasm for an approach based on sequences of words, with models learned
according to the principles of information theory. That approach fell out of favor in the
1960s, but returned in the late 1990s and now dominates the field.
Neural networks also fit this trend. Much of the work on neural nets in the 1980s was
done in an attempt to scope out what could be done and to learn how neural nets differ from
“traditional” techniques. Using improved methodology and theoretical frameworks, the field
arrived at an understanding in which neural nets can now be compared with corresponding
techniques from statistics, pattern recognition, and machine learning, and the most promising
technique can be applied to each application. As a result of these developments, so-called
data mining technology has spawned a vigorous new industry.
Judea Pearl’s (1988) Probabilistic Reasoning in Intelligent Systems led to a new acceptance of probability and decision theory in AI, following a resurgence of interest epitomized
by Peter Cheeseman’s (1985) article “In Defense of Probability.” The Bayesian network
formalism was invented to allow efficient representation of, and rigorous reasoning with,
uncertain knowledge. This approach largely overcomes many problems of the probabilistic
reasoning systems of the 1960s and 1970s; it now dominates AI research on uncertain reasoning and expert systems. The approach allows for learning from experience, and it combines
the best of classical AI and neural nets. Work by Judea Pearl (1982a) and by Eric Horvitz and
David Heckerman (Horvitz and Heckerman, 1986; Horvitz et al., 1986) promoted the idea of
normative expert systems: ones that act rationally according to the laws of decision theory
and do not try to imitate the thought steps of human experts. The WindowsTM operating system includes several normative diagnostic expert systems for correcting problems. Chapters
13 to 16 cover this area.
Similar gentle revolutions have occurred in robotics, computer vision, and knowledge
representation. A better understanding of the problems and their complexity properties, combined with increased mathematical sophistication, has led to workable research agendas and
robust methods. Although increased formalization and specialization led fields such as vision
and robotics to become somewhat isolated from “mainstream” AI in the 1990s, this trend has
reversed in recent years as tools from machine learning in particular have proved effective for
many problems. The process of reintegration is already yielding significant benefits

1.3.9 The emergence of intelligent agents (1995–present)
Perhaps encouraged by the progress in solving the subproblems of AI, researchers have also
started to look at the “whole agent” problem again. The work of Allen Newell, John Laird,
and Paul Rosenbloom on S OAR (Newell, 1990; Laird et al., 1987) is the best-known example
of a complete agent architecture. One of the most important environments for intelligent
agents is the Internet. AI systems have become so common in Web-based applications that
the “-bot” suffix has entered everyday language. Moreover, AI technologies underlie many

Section 1.3.

HUMAN-LEVEL AI

ARTIFICIAL GENERAL
INTELLIGENCE

FRIENDLY AI

The History of Artificial Intelligence

27

Internet tools, such as search engines, recommender systems, and Web site aggregators.
One consequence of trying to build complete agents is the realization that the previously
isolated subfields of AI might need to be reorganized somewhat when their results are to be
tied together. In particular, it is now widely appreciated that sensory systems (vision, sonar,
speech recognition, etc.) cannot deliver perfectly reliable information about the environment.
Hence, reasoning and planning systems must be able to handle uncertainty. A second major
consequence of the agent perspective is that AI has been drawn into much closer contact
with other fields, such as control theory and economics, that also deal with agents. Recent
progress in the control of robotic cars has derived from a mixture of approaches ranging from
better sensors, control-theoretic integration of sensing, localization and mapping, as well as
a degree of high-level planning.
Despite these successes, some influential founders of AI, including John McCarthy
(2007), Marvin Minsky (2007), Nils Nilsson (1995, 2005) and Patrick Winston (Beal and
Winston, 2009), have expressed discontent with the progress of AI. They think that AI should
put less emphasis on creating ever-improved versions of applications that are good at a specific task, such as driving a car, playing chess, or recognizing speech. Instead, they believe
AI should return to its roots of striving for, in Simon’s words, “machines that think, that learn
and that create.” They call the effort human-level AI or HLAI; their first symposium was in
2004 (Minsky et al., 2004). The effort will require very large knowledge bases; Hendler et al.
(1995) discuss where these knowledge bases might come from.
A related idea is the subfield of Artificial General Intelligence or AGI (Goertzel and
Pennachin, 2007), which held its first conference and organized the Journal of Artificial General Intelligence in 2008. AGI looks for a universal algorithm for learning and acting in
any environment, and has its roots in the work of Ray Solomonoff (1964), one of the attendees of the original 1956 Dartmouth conference. Guaranteeing that what we create is really
Friendly AI is also a concern (Yudkowsky, 2008; Omohundro, 2008), one we will return to
in Chapter 26.

1.3.10 The availability of very large data sets (2001–present)
Throughout the 60-year history of computer science, the emphasis has been on the algorithm
as the main subject of study. But some recent work in AI suggests that for many problems, it
makes more sense to worry about the data and be less picky about what algorithm to apply.
This is true because of the increasing availability of very large data sources: for example,
trillions of words of English and billions of images from the Web (Kilgarriff and Grefenstette,
2006); or billions of base pairs of genomic sequences (Collins et al., 2003).
One influential paper in this line was Yarowsky’s (1995) work on word-sense disambiguation: given the use of the word “plant” in a sentence, does that refer to flora or factory?
Previous approaches to the problem had relied on human-labeled examples combined with
machine learning algorithms. Yarowsky showed that the task can be done, with accuracy
above 96%, with no labeled examples at all. Instead, given a very large corpus of unannotated text and just the dictionary definitions of the two senses—“works, industrial plant” and
“flora, plant life”—one can label examples in the corpus, and from there bootstrap to learn

28

Chapter 1.

Introduction

new patterns that help label new examples. Banko and Brill (2001) show that techniques
like this perform even better as the amount of available text goes from a million words to a
billion and that the increase in performance from using more data exceeds any difference in
algorithm choice; a mediocre algorithm with 100 million words of unlabeled training data
outperforms the best known algorithm with 1 million words.
As another example, Hays and Efros (2007) discuss the problem of filling in holes in a
photograph. Suppose you use Photoshop to mask out an ex-friend from a group photo, but
now you need to fill in the masked area with something that matches the background. Hays
and Efros defined an algorithm that searches through a collection of photos to find something
that will match. They found the performance of their algorithm was poor when they used
a collection of only ten thousand photos, but crossed a threshold into excellent performance
when they grew the collection to two million photos.
Work like this suggests that the “knowledge bottleneck” in AI—the problem of how to
express all the knowledge that a system needs—may be solved in many applications by learning methods rather than hand-coded knowledge engineering, provided the learning algorithms
have enough data to go on (Halevy et al., 2009). Reporters have noticed the surge of new applications and have written that “AI Winter” may be yielding to a new Spring (Havenstein,
2005). As Kurzweil (2005) writes, “today, many thousands of AI applications are deeply
embedded in the infrastructure of every industry.”

1.4

T HE S TATE OF THE A RT
What can AI do today? A concise answer is difficult because there are so many activities in
so many subfields. Here we sample a few applications; others appear throughout the book.
Robotic vehicles: A driverless robotic car named S TANLEY sped through the rough
terrain of the Mojave dessert at 22 mph, finishing the 132-mile course first to win the 2005
DARPA Grand Challenge. S TANLEY is a Volkswagen Touareg outfitted with cameras, radar,
and laser rangefinders to sense the environment and onboard software to command the steering, braking, and acceleration (Thrun, 2006). The following year CMU’s B OSS won the Urban Challenge, safely driving in traffic through the streets of a closed Air Force base, obeying
traffic rules and avoiding pedestrians and other vehicles.
Speech recognition: A traveler calling United Airlines to book a flight can have the entire conversation guided by an automated speech recognition and dialog management system.
Autonomous planning and scheduling: A hundred million miles from Earth, NASA’s
Remote Agent program became the first on-board autonomous planning program to control
the scheduling of operations for a spacecraft (Jonsson et al., 2000). R EMOTE AGENT generated plans from high-level goals specified from the ground and monitored the execution of
those plans—detecting, diagnosing, and recovering from problems as they occurred. Successor program MAPGEN (Al-Chang et al., 2004) plans the daily operations for NASA’s Mars
Exploration Rovers, and MEXAR2 (Cesta et al., 2007) did mission planning—both logistics
and science planning—for the European Space Agency’s Mars Express mission in 2008.

Section 1.5.

Summary

29

Game playing: IBM’s D EEP B LUE became the first computer program to defeat the
world champion in a chess match when it bested Garry Kasparov by a score of 3.5 to 2.5 in
an exhibition match (Goodman and Keene, 1997). Kasparov said that he felt a “new kind of
intelligence” across the board from him. Newsweek magazine described the match as “The
brain’s last stand.” The value of IBM’s stock increased by $18 billion. Human champions
studied Kasparov’s loss and were able to draw a few matches in subsequent years, but the
most recent human-computer matches have been won convincingly by the computer.
Spam fighting: Each day, learning algorithms classify over a billion messages as spam,
saving the recipient from having to waste time deleting what, for many users, could comprise
80% or 90% of all messages, if not classified away by algorithms. Because the spammers are
continually updating their tactics, it is difficult for a static programmed approach to keep up,
and learning algorithms work best (Sahami et al., 1998; Goodman and Heckerman, 2004).
Logistics planning: During the Persian Gulf crisis of 1991, U.S. forces deployed a
Dynamic Analysis and Replanning Tool, DART (Cross and Walker, 1994), to do automated
logistics planning and scheduling for transportation. This involved up to 50,000 vehicles,
cargo, and people at a time, and had to account for starting points, destinations, routes, and
conflict resolution among all parameters. The AI planning techniques generated in hours
a plan that would have taken weeks with older methods. The Defense Advanced Research
Project Agency (DARPA) stated that this single application more than paid back DARPA’s
30-year investment in AI.
Robotics: The iRobot Corporation has sold over two million Roomba robotic vacuum
cleaners for home use. The company also deploys the more rugged PackBot to Iraq and
Afghanistan, where it is used to handle hazardous materials, clear explosives, and identify
the location of snipers.
Machine Translation: A computer program automatically translates from Arabic to
English, allowing an English speaker to see the headline “Ardogan Confirms That Turkey
Would Not Accept Any Pressure, Urging Them to Recognize Cyprus.” The program uses a
statistical model built from examples of Arabic-to-English translations and from examples of
English text totaling two trillion words (Brants et al., 2007). None of the computer scientists
on the team speak Arabic, but they do understand statistics and machine learning algorithms.
These are just a few examples of artificial intelligence systems that exist today. Not
magic or science fiction—but rather science, engineering, and mathematics, to which this
book provides an introduction.

1.5

S UMMARY
This chapter defines AI and establishes the cultural background against which it has developed. Some of the important points are as follows:
• Different people approach AI with different goals in mind. Two important questions to
ask are: Are you concerned with thinking or behavior? Do you want to model humans
or work from an ideal standard?

30

Chapter 1.

Introduction

• In this book, we adopt the view that intelligence is concerned mainly with rational
action. Ideally, an intelligent agent takes the best possible action in a situation. We
study the problem of building agents that are intelligent in this sense.
• Philosophers (going back to 400 B . C .) made AI conceivable by considering the ideas
that the mind is in some ways like a machine, that it operates on knowledge encoded in
some internal language, and that thought can be used to choose what actions to take.
• Mathematicians provided the tools to manipulate statements of logical certainty as well
as uncertain, probabilistic statements. They also set the groundwork for understanding
computation and reasoning about algorithms.
• Economists formalized the problem of making decisions that maximize the expected
outcome to the decision maker.
• Neuroscientists discovered some facts about how the brain works and the ways in which
it is similar to and different from computers.
• Psychologists adopted the idea that humans and animals can be considered informationprocessing machines. Linguists showed that language use fits into this model.
• Computer engineers provided the ever-more-powerful machines that make AI applications possible.
• Control theory deals with designing devices that act optimally on the basis of feedback
from the environment. Initially, the mathematical tools of control theory were quite
different from AI, but the fields are coming closer together.
• The history of AI has had cycles of success, misplaced optimism, and resulting cutbacks
in enthusiasm and funding. There have also been cycles of introducing new creative
approaches and systematically refining the best ones.
• AI has advanced more rapidly in the past decade because of greater use of the scientific
method in experimenting with and comparing approaches.
• Recent progress in understanding the theoretical basis for intelligence has gone hand in
hand with improvements in the capabilities of real systems. The subfields of AI have
become more integrated, and AI has found common ground with other disciplines.

B IBLIOGRAPHICAL AND H ISTORICAL N OTES
The methodological status of artificial intelligence is investigated in The Sciences of the Artificial, by Herb Simon (1981), which discusses research areas concerned with complex artifacts.
It explains how AI can be viewed as both science and mathematics. Cohen (1995) gives an
overview of experimental methodology within AI.
The Turing Test (Turing, 1950) is discussed by Shieber (1994), who severely criticizes
the usefulness of its instantiation in the Loebner Prize competition, and by Ford and Hayes
(1995), who argue that the test itself is not helpful for AI. Bringsjord (2008) gives advice for
a Turing Test judge. Shieber (2004) and Epstein et al. (2008) collect a number of essays on
the Turing Test. Artificial Intelligence: The Very Idea, by John Haugeland (1985), gives a

Exercises

31
readable account of the philosophical and practical problems of AI. Significant early papers
in AI are anthologized in the collections by Webber and Nilsson (1981) and by Luger (1995).
The Encyclopedia of AI (Shapiro, 1992) contains survey articles on almost every topic in
AI, as does Wikipedia. These articles usually provide a good entry point into the research
literature on each topic. An insightful and comprehensive history of AI is given by Nils
Nillson (2009), one of the early pioneers of the field.
The most recent work appears in the proceedings of the major AI conferences: the biennial International Joint Conference on AI (IJCAI), the annual European Conference on AI
(ECAI), and the National Conference on AI, more often known as AAAI, after its sponsoring
organization. The major journals for general AI are Artificial Intelligence, Computational
Intelligence, the IEEE Transactions on Pattern Analysis and Machine Intelligence, IEEE Intelligent Systems, and the electronic Journal of Artificial Intelligence Research. There are also
many conferences and journals devoted to specific areas, which we cover in the appropriate
chapters. The main professional societies for AI are the American Association for Artificial
Intelligence (AAAI), the ACM Special Interest Group in Artificial Intelligence (SIGART),
and the Society for Artificial Intelligence and Simulation of Behaviour (AISB). AAAI’s AI
Magazine contains many topical and tutorial articles, and its Web site, aaai.org, contains
news, tutorials, and background information.

E XERCISES
These exercises are intended to stimulate discussion, and some might be set as term projects.
Alternatively, preliminary attempts can be made now, and these attempts can be reviewed
after the completion of the book.
1.1 Define in your own words: (a) intelligence, (b) artificial intelligence, (c) agent, (d)
rationality, (e) logical reasoning.
1.2 Read Turing’s original paper on AI (Turing, 1950). In the paper, he discusses several
objections to his proposed enterprise and his test for intelligence. Which objections still carry
weight? Are his refutations valid? Can you think of new objections arising from developments since he wrote the paper? In the paper, he predicts that, by the year 2000, a computer
will have a 30% chance of passing a five-minute Turing Test with an unskilled interrogator.
What chance do you think a computer would have today? In another 50 years?
1.3

Are reflex actions (such as flinching from a hot stove) rational? Are they intelligent?

1.4 Suppose we extend Evans’s A NALOGY program so that it can score 200 on a standard
IQ test. Would we then have a program more intelligent than a human? Explain.
1.5 The neural structure of the sea slug Aplysia has been widely studied (first by Nobel
Laureate Eric Kandel) because it has only about 20,000 neurons, most of them large and
easily manipulated. Assuming that the cycle time for an Aplysia neuron is roughly the same
as for a human neuron, how does the computational power, in terms of memory updates per
second, compare with the high-end computer described in Figure 1.3?

32

Chapter 1.

Introduction

1.6 How could introspection—reporting on one’s inner thoughts—be inaccurate? Could I
be wrong about what I’m thinking? Discuss.
1.7

To what extent are the following computer systems instances of artificial intelligence:
• Supermarket bar code scanners.
• Web search engines.
• Voice-activated telephone menus.
• Internet routing algorithms that respond dynamically to the state of the network.

1.8 Many of the computational models of cognitive activities that have been proposed involve quite complex mathematical operations, such as convolving an image with a Gaussian
or finding a minimum of the entropy function. Most humans (and certainly all animals) never
learn this kind of mathematics at all, almost no one learns it before college, and almost no
one can compute the convolution of a function with a Gaussian in their head. What sense
does it make to say that the “vision system” is doing this kind of mathematics, whereas the
actual person has no idea how to do it?
1.9 Why would evolution tend to result in systems that act rationally? What goals are such
systems designed to achieve?
1.10

Is AI a science, or is it engineering? Or neither or both? Explain.

1.11 “Surely computers cannot be intelligent—they can do only what their programmers
tell them.” Is the latter statement true, and does it imply the former?
1.12 “Surely animals cannot be intelligent—they can do only what their genes tell them.”
Is the latter statement true, and does it imply the former?
1.13 “Surely animals, humans, and computers cannot be intelligent—they can do only what
their constituent atoms are told to do by the laws of physics.” Is the latter statement true, and
does it imply the former?
1.14 Examine the AI literature to discover whether the following tasks can currently be
solved by computers:
a. Playing a decent game of table tennis (Ping-Pong).
b. Driving in the center of Cairo, Egypt.
c. Driving in Victorville, California.
d. Buying a week’s worth of groceries at the market.
e. Buying a week’s worth of groceries on the Web.
f. Playing a decent game of bridge at a competitive level.
g. Discovering and proving new mathematical theorems.
h. Writing an intentionally funny story.
i. Giving competent legal advice in a specialized area of law.
j. Translating spoken English into spoken Swedish in real time.
k. Performing a complex surgical operation.

Exercises

33
For the currently infeasible tasks, try to find out what the difficulties are and predict when, if
ever, they will be overcome.
1.15 Various subfields of AI have held contests by defining a standard task and inviting researchers to do their best. Examples include the DARPA Grand Challenge for robotic cars,
The International Planning Competition, the Robocup robotic soccer league, the TREC information retrieval event, and contests in machine translation, speech recognition. Investigate
five of these contests, and describe the progress made over the years. To what degree have the
contests advanced toe state of the art in AI? Do what degree do they hurt the field by drawing
energy away from new ideas?

2

INTELLIGENT AGENTS

In which we discuss the nature of agents, perfect or otherwise, the diversity of
environments, and the resulting menagerie of agent types.

Chapter 1 identified the concept of rational agents as central to our approach to artificial
intelligence. In this chapter, we make this notion more concrete. We will see that the concept
of rationality can be applied to a wide variety of agents operating in any imaginable environment. Our plan in this book is to use this concept to develop a small set of design principles
for building successful agents—systems that can reasonably be called intelligent.
We begin by examining agents, environments, and the coupling between them. The
observation that some agents behave better than others leads naturally to the idea of a rational
agent—one that behaves as well as possible. How well an agent can behave depends on
the nature of the environment; some environments are more difficult than others. We give a
crude categorization of environments and show how properties of an environment influence
the design of suitable agents for that environment. We describe a number of basic “skeleton”
agent designs, which we flesh out in the rest of the book.

2.1

AGENTS AND E NVIRONMENTS

ENVIRONMENT
SENSOR
ACTUATOR

PERCEPT
PERCEPT SEQUENCE

An agent is anything that can be viewed as perceiving its environment through sensors and
acting upon that environment through actuators. This simple idea is illustrated in Figure 2.1.
A human agent has eyes, ears, and other organs for sensors and hands, legs, vocal tract, and so
on for actuators. A robotic agent might have cameras and infrared range finders for sensors
and various motors for actuators. A software agent receives keystrokes, file contents, and
network packets as sensory inputs and acts on the environment by displaying on the screen,
writing files, and sending network packets.
We use the term percept to refer to the agent’s perceptual inputs at any given instant. An
agent’s percept sequence is the complete history of everything the agent has ever perceived.
In general, an agent’s choice of action at any given instant can depend on the entire percept
sequence observed to date, but not on anything it hasn’t perceived. By specifying the agent’s
choice of action for every possible percept sequence, we have said more or less everything
34

Section 2.1.

Agents and Environments

Agent

35

Sensors

Percepts

Environment

?
Actuators

Figure 2.1

AGENT FUNCTION

AGENT PROGRAM

Actions

Agents interact with environments through sensors and actuators.

there is to say about the agent. Mathematically speaking, we say that an agent’s behavior is
described by the agent function that maps any given percept sequence to an action.
We can imagine tabulating the agent function that describes any given agent; for most
agents, this would be a very large table—infinite, in fact, unless we place a bound on the
length of percept sequences we want to consider. Given an agent to experiment with, we can,
in principle, construct this table by trying out all possible percept sequences and recording
which actions the agent does in response.1 The table is, of course, an external characterization
of the agent. Internally, the agent function for an artificial agent will be implemented by an
agent program. It is important to keep these two ideas distinct. The agent function is an
abstract mathematical description; the agent program is a concrete implementation, running
within some physical system.
To illustrate these ideas, we use a very simple example—the vacuum-cleaner world
shown in Figure 2.2. This world is so simple that we can describe everything that happens;
it’s also a made-up world, so we can invent many variations. This particular world has just two
locations: squares A and B. The vacuum agent perceives which square it is in and whether
there is dirt in the square. It can choose to move left, move right, suck up the dirt, or do
nothing. One very simple agent function is the following: if the current square is dirty, then
suck; otherwise, move to the other square. A partial tabulation of this agent function is shown
in Figure 2.3 and an agent program that implements it appears in Figure 2.8 on page 48.
Looking at Figure 2.3, we see that various vacuum-world agents can be defined simply
by filling in the right-hand column in various ways. The obvious question, then, is this: What
is the right way to fill out the table? In other words, what makes an agent good or bad,
intelligent or stupid? We answer these questions in the next section.
1 If the agent uses some randomization to choose its actions, then we would have to try each sequence many
times to identify the probability of each action. One might imagine that acting randomly is rather silly, but we
show later in this chapter that it can be very intelligent.

36

Chapter

A

Figure 2.2

2.

Intelligent Agents

B

A vacuum-cleaner world with just two locations.

Percept sequence

Action

[A, Clean]
[A, Dirty]
[B, Clean]
[B, Dirty]
[A, Clean], [A, Clean]
[A, Clean], [A, Dirty]
..
.

Right
Suck
Left
Suck
Right
Suck
..
.

[A, Clean], [A, Clean], [A, Clean]
[A, Clean], [A, Clean], [A, Dirty]
..
.

Right
Suck
..
.

Figure 2.3 Partial tabulation of a simple agent function for the vacuum-cleaner world
shown in Figure 2.2.

Before closing this section, we should emphasize that the notion of an agent is meant to
be a tool for analyzing systems, not an absolute characterization that divides the world into
agents and non-agents. One could view a hand-held calculator as an agent that chooses the
action of displaying “4” when given the percept sequence “2 + 2 =,” but such an analysis
would hardly aid our understanding of the calculator. In a sense, all areas of engineering can
be seen as designing artifacts that interact with the world; AI operates at (what the authors
consider to be) the most interesting end of the spectrum, where the artifacts have significant
computational resources and the task environment requires nontrivial decision making.

2.2

G OOD B EHAVIOR : T HE C ONCEPT OF R ATIONALITY

RATIONAL AGENT

A rational agent is one that does the right thing—conceptually speaking, every entry in the
table for the agent function is filled out correctly. Obviously, doing the right thing is better
than doing the wrong thing, but what does it mean to do the right thing?

Section 2.2.

PERFORMANCE
MEASURE

Good Behavior: The Concept of Rationality

We answer this age-old question in an age-old way: by considering the consequences
of the agent’s behavior. When an agent is plunked down in an environment, it generates a
sequence of actions according to the percepts it receives. This sequence of actions causes the
environment to go through a sequence of states. If the sequence is desirable, then the agent
has performed well. This notion of desirability is captured by a performance measure that
evaluates any given sequence of environment states.
Notice that we said environment states, not agent states. If we define success in terms
of agent’s opinion of its own performance, an agent could achieve perfect rationality simply
by deluding itself that its performance was perfect. Human agents in particular are notorious
for “sour grapes”—believing they did not really want something (e.g., a Nobel Prize) after
not getting it.
Obviously, there is not one fixed performance measure for all tasks and agents; typically,
a designer will devise one appropriate to the circumstances. This is not as easy as it sounds.
Consider, for example, the vacuum-cleaner agent from the preceding section. We might
propose to measure performance by the amount of dirt cleaned up in a single eight-hour shift.
With a rational agent, of course, what you ask for is what you get. A rational agent can
maximize this performance measure by cleaning up the dirt, then dumping it all on the floor,
then cleaning it up again, and so on. A more suitable performance measure would reward the
agent for having a clean floor. For example, one point could be awarded for each clean square
at each time step (perhaps with a penalty for electricity consumed and noise generated). As
a general rule, it is better to design performance measures according to what one actually
wants in the environment, rather than according to how one thinks the agent should behave.
Even when the obvious pitfalls are avoided, there remain some knotty issues to untangle.
For example, the notion of “clean floor” in the preceding paragraph is based on average
cleanliness over time. Yet the same average cleanliness can be achieved by two different
agents, one of which does a mediocre job all the time while the other cleans energetically but
takes long breaks. Which is preferable might seem to be a fine point of janitorial science, but
in fact it is a deep philosophical question with far-reaching implications. Which is better—
a reckless life of highs and lows, or a safe but humdrum existence? Which is better—an
economy where everyone lives in moderate poverty, or one in which some live in plenty
while others are very poor? We leave these questions as an exercise for the diligent reader.

2.2.1 Rationality
What is rational at any given time depends on four things:
• The performance measure that defines the criterion of success.
• The agent’s prior knowledge of the environment.
• The actions that the agent can perform.
• The agent’s percept sequence to date.
DEFINITION OF A
RATIONAL AGENT

37

This leads to a definition of a rational agent:
For each possible percept sequence, a rational agent should select an action that is expected to maximize its performance measure, given the evidence provided by the percept
sequence and whatever built-in knowledge the agent has.

38

Chapter

2.

Intelligent Agents

Consider the simple vacuum-cleaner agent that cleans a square if it is dirty and moves to the
other square if not; this is the agent function tabulated in Figure 2.3. Is this a rational agent?
That depends! First, we need to say what the performance measure is, what is known about
the environment, and what sensors and actuators the agent has. Let us assume the following:
• The performance measure awards one point for each clean square at each time step,
over a “lifetime” of 1000 time steps.
• The “geography” of the environment is known a priori (Figure 2.2) but the dirt distribution and the initial location of the agent are not. Clean squares stay clean and sucking
cleans the current square. The Left and Right actions move the agent left and right
except when this would take the agent outside the environment, in which case the agent
remains where it is.
• The only available actions are Left, Right, and Suck .
• The agent correctly perceives its location and whether that location contains dirt.
We claim that under these circumstances the agent is indeed rational; its expected performance is at least as high as any other agent’s. Exercise 2.2 asks you to prove this.
One can see easily that the same agent would be irrational under different circumstances. For example, once all the dirt is cleaned up, the agent will oscillate needlessly back
and forth; if the performance measure includes a penalty of one point for each movement left
or right, the agent will fare poorly. A better agent for this case would do nothing once it is
sure that all the squares are clean. If clean squares can become dirty again, the agent should
occasionally check and re-clean them if needed. If the geography of the environment is unknown, the agent will need to explore it rather than stick to squares A and B. Exercise 2.2
asks you to design agents for these cases.

2.2.2 Omniscience, learning, and autonomy
OMNISCIENCE

We need to be careful to distinguish between rationality and omniscience. An omniscient
agent knows the actual outcome of its actions and can act accordingly; but omniscience is
impossible in reality. Consider the following example: I am walking along the Champs
Elysées one day and I see an old friend across the street. There is no traffic nearby and I’m
not otherwise engaged, so, being rational, I start to cross the street. Meanwhile, at 33,000
feet, a cargo door falls off a passing airliner, 2 and before I make it to the other side of the
street I am flattened. Was I irrational to cross the street? It is unlikely that my obituary would
read “Idiot attempts to cross street.”
This example shows that rationality is not the same as perfection. Rationality maximizes expected performance, while perfection maximizes actual performance. Retreating
from a requirement of perfection is not just a question of being fair to agents. The point is
that if we expect an agent to do what turns out to be the best action after the fact, it will be
impossible to design an agent to fulfill this specification—unless we improve the performance
of crystal balls or time machines.
2

See N. Henderson, “New door latches urged for Boeing 747 jumbo jets,” Washington Post, August 24, 1989.

Section 2.2.

INFORMATION
GATHERING
EXPLORATION

LEARNING

AUTONOMY

Good Behavior: The Concept of Rationality

39

Our definition of rationality does not require omniscience, then, because the rational
choice depends only on the percept sequence to date. We must also ensure that we haven’t
inadvertently allowed the agent to engage in decidedly underintelligent activities. For example, if an agent does not look both ways before crossing a busy road, then its percept sequence
will not tell it that there is a large truck approaching at high speed. Does our definition of
rationality say that it’s now OK to cross the road? Far from it! First, it would not be rational
to cross the road given this uninformative percept sequence: the risk of accident from crossing without looking is too great. Second, a rational agent should choose the “looking” action
before stepping into the street, because looking helps maximize the expected performance.
Doing actions in order to modify future percepts—sometimes called information gathering—is an important part of rationality and is covered in depth in Chapter 16. A second
example of information gathering is provided by the exploration that must be undertaken by
a vacuum-cleaning agent in an initially unknown environment.
Our definition requires a rational agent not only to gather information but also to learn
as much as possible from what it perceives. The agent’s initial configuration could reflect
some prior knowledge of the environment, but as the agent gains experience this may be
modified and augmented. There are extreme cases in which the environment is completely
known a priori. In such cases, the agent need not perceive or learn; it simply acts correctly.
Of course, such agents are fragile. Consider the lowly dung beetle. After digging its nest and
laying its eggs, it fetches a ball of dung from a nearby heap to plug the entrance. If the ball of
dung is removed from its grasp en route, the beetle continues its task and pantomimes plugging the nest with the nonexistent dung ball, never noticing that it is missing. Evolution has
built an assumption into the beetle’s behavior, and when it is violated, unsuccessful behavior
results. Slightly more intelligent is the sphex wasp. The female sphex will dig a burrow, go
out and sting a caterpillar and drag it to the burrow, enter the burrow again to check all is
well, drag the caterpillar inside, and lay its eggs. The caterpillar serves as a food source when
the eggs hatch. So far so good, but if an entomologist moves the caterpillar a few inches
away while the sphex is doing the check, it will revert to the “drag” step of its plan and will
continue the plan without modification, even after dozens of caterpillar-moving interventions.
The sphex is unable to learn that its innate plan is failing, and thus will not change it.
To the extent that an agent relies on the prior knowledge of its designer rather than
on its own percepts, we say that the agent lacks autonomy. A rational agent should be
autonomous—it should learn what it can to compensate for partial or incorrect prior knowledge. For example, a vacuum-cleaning agent that learns to foresee where and when additional
dirt will appear will do better than one that does not. As a practical matter, one seldom requires complete autonomy from the start: when the agent has had little or no experience, it
would have to act randomly unless the designer gave some assistance. So, just as evolution
provides animals with enough built-in reflexes to survive long enough to learn for themselves,
it would be reasonable to provide an artificial intelligent agent with some initial knowledge
as well as an ability to learn. After sufficient experience of its environment, the behavior
of a rational agent can become effectively independent of its prior knowledge. Hence, the
incorporation of learning allows one to design a single rational agent that will succeed in a
vast variety of environments.

40

2.3

Chapter

2.

Intelligent Agents

T HE NATURE OF E NVIRONMENTS

TASK ENVIRONMENT

Now that we have a definition of rationality, we are almost ready to think about building
rational agents. First, however, we must think about task environments, which are essentially the “problems” to which rational agents are the “solutions.” We begin by showing how
to specify a task environment, illustrating the process with a number of examples. We then
show that task environments come in a variety of flavors. The flavor of the task environment
directly affects the appropriate design for the agent program.

2.3.1 Specifying the task environment

PEAS

In our discussion of the rationality of the simple vacuum-cleaner agent, we had to specify
the performance measure, the environment, and the agent’s actuators and sensors. We group
all these under the heading of the task environment. For the acronymically minded, we call
this the PEAS (Performance, Environment, Actuators, Sensors) description. In designing an
agent, the first step must always be to specify the task environment as fully as possible.
The vacuum world was a simple example; let us consider a more complex problem: an
automated taxi driver. We should point out, before the reader becomes alarmed, that a fully
automated taxi is currently somewhat beyond the capabilities of existing technology. (page 28
describes an existing driving robot.) The full driving task is extremely open-ended. There is
no limit to the novel combinations of circumstances that can arise—another reason we chose
it as a focus for discussion. Figure 2.4 summarizes the PEAS description for the taxi’s task
environment. We discuss each element in more detail in the following paragraphs.
Agent Type

Performance
Measure

Environment

Actuators

Sensors

Taxi driver

Safe, fast, legal,
comfortable trip,
maximize profits

Roads, other
traffic,
pedestrians,
customers

Steering,
accelerator,
brake, signal,
horn, display

Cameras, sonar,
speedometer,
GPS, odometer,
accelerometer,
engine sensors,
keyboard

Figure 2.4

PEAS description of the task environment for an automated taxi.

First, what is the performance measure to which we would like our automated driver
to aspire? Desirable qualities include getting to the correct destination; minimizing fuel consumption and wear and tear; minimizing the trip time or cost; minimizing violations of traffic
laws and disturbances to other drivers; maximizing safety and passenger comfort; maximizing profits. Obviously, some of these goals conflict, so tradeoffs will be required.
Next, what is the driving environment that the taxi will face? Any taxi driver must
deal with a variety of roads, ranging from rural lanes and urban alleys to 12-lane freeways.
The roads contain other traffic, pedestrians, stray animals, road works, police cars, puddles,

Section 2.3.

SOFTWARE AGENT
SOFTBOT

The Nature of Environments

41

and potholes. The taxi must also interact with potential and actual passengers. There are also
some optional choices. The taxi might need to operate in Southern California, where snow
is seldom a problem, or in Alaska, where it seldom is not. It could always be driving on the
right, or we might want it to be flexible enough to drive on the left when in Britain or Japan.
Obviously, the more restricted the environment, the easier the design problem.
The actuators for an automated taxi include those available to a human driver: control
over the engine through the accelerator and control over steering and braking. In addition, it
will need output to a display screen or voice synthesizer to talk back to the passengers, and
perhaps some way to communicate with other vehicles, politely or otherwise.
The basic sensors for the taxi will include one or more controllable video cameras so
that it can see the road; it might augment these with infrared or sonar sensors to detect distances to other cars and obstacles. To avoid speeding tickets, the taxi should have a speedometer, and to control the vehicle properly, especially on curves, it should have an accelerometer.
To determine the mechanical state of the vehicle, it will need the usual array of engine, fuel,
and electrical system sensors. Like many human drivers, it might want a global positioning
system (GPS) so that it doesn’t get lost. Finally, it will need a keyboard or microphone for
the passenger to request a destination.
In Figure 2.5, we have sketched the basic PEAS elements for a number of additional
agent types. Further examples appear in Exercise 2.4. It may come as a surprise to some readers that our list of agent types includes some programs that operate in the entirely artificial
environment defined by keyboard input and character output on a screen. “Surely,” one might
say, “this is not a real environment, is it?” In fact, what matters is not the distinction between
“real” and “artificial” environments, but the complexity of the relationship among the behavior of the agent, the percept sequence generated by the environment, and the performance
measure. Some “real” environments are actually quite simple. For example, a robot designed
to inspect parts as they come by on a conveyor belt can make use of a number of simplifying
assumptions: that the lighting is always just so, that the only thing on the conveyor belt will
be parts of a kind that it knows about, and that only two actions (accept or reject) are possible.
In contrast, some software agents (or software robots or softbots) exist in rich, unlimited domains. Imagine a softbot Web site operator designed to scan Internet news sources and
show the interesting items to its users, while selling advertising space to generate revenue.
To do well, that operator will need some natural language processing abilities, it will need
to learn what each user and advertiser is interested in, and it will need to change its plans
dynamically—for example, when the connection for one news source goes down or when a
new one comes online. The Internet is an environment whose complexity rivals that of the
physical world and whose inhabitants include many artificial and human agents.

2.3.2 Properties of task environments
The range of task environments that might arise in AI is obviously vast. We can, however,
identify a fairly small number of dimensions along which task environments can be categorized. These dimensions determine, to a large extent, the appropriate agent design and the
applicability of each of the principal families of techniques for agent implementation. First,

42

Chapter

2.

Intelligent Agents

Agent Type

Performance
Measure

Environment

Actuators

Sensors

Medical
diagnosis system

Healthy patient,
reduced costs

Patient, hospital,
staff

Display of
questions, tests,
diagnoses,
treatments,
referrals

Keyboard entry
of symptoms,
findings, patient’s
answers

Satellite image
analysis system

Correct image
categorization

Downlink from
orbiting satellite

Display of scene
categorization

Color pixel
arrays

Part-picking
robot

Percentage of
parts in correct
bins

Conveyor belt
with parts; bins

Jointed arm and
hand

Camera, joint
angle sensors

Refinery
controller

Purity, yield,
safety

Refinery,
operators

Valves, pumps,
heaters, displays

Temperature,
pressure,
chemical sensors

Interactive
English tutor

Student’s score
on test

Set of students,
testing agency

Display of
exercises,
suggestions,
corrections

Keyboard entry

Figure 2.5

Examples of agent types and their PEAS descriptions.

we list the dimensions, then we analyze several task environments to illustrate the ideas. The
definitions here are informal; later chapters provide more precise statements and examples of
each kind of environment.
FULLY OBSERVABLE
PARTIALLY
OBSERVABLE

UNOBSERVABLE

SINGLE AGENT
MULTIAGENT

Fully observable vs. partially observable: If an agent’s sensors give it access to the
complete state of the environment at each point in time, then we say that the task environment is fully observable. A task environment is effectively fully observable if the sensors
detect all aspects that are relevant to the choice of action; relevance, in turn, depends on the
performance measure. Fully observable environments are convenient because the agent need
not maintain any internal state to keep track of the world. An environment might be partially
observable because of noisy and inaccurate sensors or because parts of the state are simply
missing from the sensor data—for example, a vacuum agent with only a local dirt sensor
cannot tell whether there is dirt in other squares, and an automated taxi cannot see what other
drivers are thinking. If the agent has no sensors at all then the environment is unobservable. One might think that in such cases the agent’s plight is hopeless, but, as we discuss in
Chapter 4, the agent’s goals may still be achievable, sometimes with certainty.
Single agent vs. multiagent: The distinction between single-agent and multiagent en-

Section 2.3.

COMPETITIVE

COOPERATIVE

DETERMINISTIC
STOCHASTIC

UNCERTAIN

NONDETERMINISTIC

EPISODIC
SEQUENTIAL

The Nature of Environments

43

vironments may seem simple enough. For example, an agent solving a crossword puzzle by
itself is clearly in a single-agent environment, whereas an agent playing chess is in a twoagent environment. There are, however, some subtle issues. First, we have described how an
entity may be viewed as an agent, but we have not explained which entities must be viewed
as agents. Does an agent A (the taxi driver for example) have to treat an object B (another
vehicle) as an agent, or can it be treated merely as an object behaving according to the laws of
physics, analogous to waves at the beach or leaves blowing in the wind? The key distinction
is whether B’s behavior is best described as maximizing a performance measure whose value
depends on agent A’s behavior. For example, in chess, the opponent entity B is trying to
maximize its performance measure, which, by the rules of chess, minimizes agent A’s performance measure. Thus, chess is a competitive multiagent environment. In the taxi-driving
environment, on the other hand, avoiding collisions maximizes the performance measure of
all agents, so it is a partially cooperative multiagent environment. It is also partially competitive because, for example, only one car can occupy a parking space. The agent-design
problems in multiagent environments are often quite different from those in single-agent environments; for example, communication often emerges as a rational behavior in multiagent
environments; in some competitive environments, randomized behavior is rational because
it avoids the pitfalls of predictability.
Deterministic vs. stochastic. If the next state of the environment is completely determined by the current state and the action executed by the agent, then we say the environment
is deterministic; otherwise, it is stochastic. In principle, an agent need not worry about uncertainty in a fully observable, deterministic environment. (In our definition, we ignore uncertainty that arises purely from the actions of other agents in a multiagent environment; thus,
a game can be deterministic even though each agent may be unable to predict the actions of
the others.) If the environment is partially observable, however, then it could appear to be
stochastic. Most real situations are so complex that it is impossible to keep track of all the
unobserved aspects; for practical purposes, they must be treated as stochastic. Taxi driving is
clearly stochastic in this sense, because one can never predict the behavior of traffic exactly;
moreover, one’s tires blow out and one’s engine seizes up without warning. The vacuum
world as we described it is deterministic, but variations can include stochastic elements such
as randomly appearing dirt and an unreliable suction mechanism (Exercise 2.13). We say an
environment is uncertain if it is not fully observable or not deterministic. One final note:
our use of the word “stochastic” generally implies that uncertainty about outcomes is quantified in terms of probabilities; a nondeterministic environment is one in which actions are
characterized by their possible outcomes, but no probabilities are attached to them. Nondeterministic environment descriptions are usually associated with performance measures that
require the agent to succeed for all possible outcomes of its actions.
Episodic vs. sequential: In an episodic task environment, the agent’s experience is
divided into atomic episodes. In each episode the agent receives a percept and then performs
a single action. Crucially, the next episode does not depend on the actions taken in previous
episodes. Many classification tasks are episodic. For example, an agent that has to spot
defective parts on an assembly line bases each decision on the current part, regardless of
previous decisions; moreover, the current decision doesn’t affect whether the next part is

44

STATIC
DYNAMIC

SEMIDYNAMIC

DISCRETE
CONTINUOUS

KNOWN
UNKNOWN

Chapter

2.

Intelligent Agents

defective. In sequential environments, on the other hand, the current decision could affect
all future decisions.3 Chess and taxi driving are sequential: in both cases, short-term actions
can have long-term consequences. Episodic environments are much simpler than sequential
environments because the agent does not need to think ahead.
Static vs. dynamic: If the environment can change while an agent is deliberating, then
we say the environment is dynamic for that agent; otherwise, it is static. Static environments
are easy to deal with because the agent need not keep looking at the world while it is deciding
on an action, nor need it worry about the passage of time. Dynamic environments, on the
other hand, are continuously asking the agent what it wants to do; if it hasn’t decided yet,
that counts as deciding to do nothing. If the environment itself does not change with the
passage of time but the agent’s performance score does, then we say the environment is
semidynamic. Taxi driving is clearly dynamic: the other cars and the taxi itself keep moving
while the driving algorithm dithers about what to do next. Chess, when played with a clock,
is semidynamic. Crossword puzzles are static.
Discrete vs. continuous: The discrete/continuous distinction applies to the state of the
environment, to the way time is handled, and to the percepts and actions of the agent. For
example, the chess environment has a finite number of distinct states (excluding the clock).
Chess also has a discrete set of percepts and actions. Taxi driving is a continuous-state and
continuous-time problem: the speed and location of the taxi and of the other vehicles sweep
through a range of continuous values and do so smoothly over time. Taxi-driving actions are
also continuous (steering angles, etc.). Input from digital cameras is discrete, strictly speaking, but is typically treated as representing continuously varying intensities and locations.
Known vs. unknown: Strictly speaking, this distinction refers not to the environment
itself but to the agent’s (or designer’s) state of knowledge about the “laws of physics” of
the environment. In a known environment, the outcomes (or outcome probabilities if the
environment is stochastic) for all actions are given. Obviously, if the environment is unknown,
the agent will have to learn how it works in order to make good decisions. Note that the
distinction between known and unknown environments is not the same as the one between
fully and partially observable environments. It is quite possible for a known environment
to be partially observable—for example, in solitaire card games, I know the rules but am
still unable to see the cards that have not yet been turned over. Conversely, an unknown
environment can be fully observable—in a new video game, the screen may show the entire
game state but I still don’t know what the buttons do until I try them.
As one might expect, the hardest case is partially observable, multiagent, stochastic,
sequential, dynamic, continuous, and unknown. Taxi driving is hard in all these senses, except
that for the most part the driver’s environment is known. Driving a rented car in a new country
with unfamiliar geography and traffic laws is a lot more exciting.
Figure 2.6 lists the properties of a number of familiar environments. Note that the
answers are not always cut and dried. For example, we describe the part-picking robot as
episodic, because it normally considers each part in isolation. But if one day there is a large
3

The word “sequential” is also used in computer science as the antonym of “parallel.” The two meanings are
largely unrelated.

Section 2.3.

The Nature of Environments
Task Environment

Observable Agents Deterministic Episodic

Static

Discrete

Crossword puzzle
Chess with a clock

Fully
Fully

Single Deterministic Sequential
Multi Deterministic Sequential

Static
Semi

Discrete
Discrete

Poker
Backgammon

Partially
Fully

Multi
Multi

Stochastic
Stochastic

Sequential
Sequential

Static
Static

Discrete
Discrete

Taxi driving
Medical diagnosis

Partially
Partially

Multi
Single

Stochastic
Stochastic

Sequential Dynamic Continuous
Sequential Dynamic Continuous

Image analysis
Part-picking robot

Fully
Partially

Single Deterministic Episodic
Semi Continuous
Single Stochastic
Episodic Dynamic Continuous

Refinery controller
Interactive English tutor

Partially
Partially

Single
Multi

Figure 2.6

ENVIRONMENT
CLASS

45

Stochastic
Stochastic

Sequential Dynamic Continuous
Sequential Dynamic Discrete

Examples of task environments and their characteristics.

batch of defective parts, the robot should learn from several observations that the distribution
of defects has changed, and should modify its behavior for subsequent parts. We have not
included a “known/unknown” column because, as explained earlier, this is not strictly a property of the environment. For some environments, such as chess and poker, it is quite easy to
supply the agent with full knowledge of the rules, but it is nonetheless interesting to consider
how an agent might learn to play these games without such knowledge.
Several of the answers in the table depend on how the task environment is defined. We
have listed the medical-diagnosis task as single-agent because the disease process in a patient
is not profitably modeled as an agent; but a medical-diagnosis system might also have to
deal with recalcitrant patients and skeptical staff, so the environment could have a multiagent
aspect. Furthermore, medical diagnosis is episodic if one conceives of the task as selecting a
diagnosis given a list of symptoms; the problem is sequential if the task can include proposing
a series of tests, evaluating progress over the course of treatment, and so on. Also, many
environments are episodic at higher levels than the agent’s individual actions. For example,
a chess tournament consists of a sequence of games; each game is an episode because (by
and large) the contribution of the moves in one game to the agent’s overall performance is
not affected by the moves in its previous game. On the other hand, decision making within a
single game is certainly sequential.
The code repository associated with this book (aima.cs.berkeley.edu) includes implementations of a number of environments, together with a general-purpose environment simulator that places one or more agents in a simulated environment, observes their behavior over
time, and evaluates them according to a given performance measure. Such experiments are
often carried out not for a single environment but for many environments drawn from an environment class. For example, to evaluate a taxi driver in simulated traffic, we would want to
run many simulations with different traffic, lighting, and weather conditions. If we designed
the agent for a single scenario, we might be able to take advantage of specific properties
of the particular case but might not identify a good design for driving in general. For this

46

Chapter

ENVIRONMENT
GENERATOR

2.4

2.

Intelligent Agents

reason, the code repository also includes an environment generator for each environment
class that selects particular environments (with certain likelihoods) in which to run the agent.
For example, the vacuum environment generator initializes the dirt pattern and agent location
randomly. We are then interested in the agent’s average performance over the environment
class. A rational agent for a given environment class maximizes this average performance.
Exercises 2.8 to 2.13 take you through the process of developing an environment class and
evaluating various agents therein.

T HE S TRUCTURE OF AGENTS

AGENT PROGRAM

ARCHITECTURE

So far we have talked about agents by describing behavior—the action that is performed after
any given sequence of percepts. Now we must bite the bullet and talk about how the insides
work. The job of AI is to design an agent program that implements the agent function—
the mapping from percepts to actions. We assume this program will run on some sort of
computing device with physical sensors and actuators—we call this the architecture:
agent = architecture + program .
Obviously, the program we choose has to be one that is appropriate for the architecture. If the
program is going to recommend actions like Walk, the architecture had better have legs. The
architecture might be just an ordinary PC, or it might be a robotic car with several onboard
computers, cameras, and other sensors. In general, the architecture makes the percepts from
the sensors available to the program, runs the program, and feeds the program’s action choices
to the actuators as they are generated. Most of this book is about designing agent programs,
although Chapters 24 and 25 deal directly with the sensors and actuators.

2.4.1 Agent programs
The agent programs that we design in this book all have the same skeleton: they take the
current percept as input from the sensors and return an action to the actuators.4 Notice the
difference between the agent program, which takes the current percept as input, and the agent
function, which takes the entire percept history. The agent program takes just the current
percept as input because nothing more is available from the environment; if the agent’s actions
need to depend on the entire percept sequence, the agent will have to remember the percepts.
We describe the agent programs in the simple pseudocode language that is defined in
Appendix B. (The online code repository contains implementations in real programming
languages.) For example, Figure 2.7 shows a rather trivial agent program that keeps track of
the percept sequence and then uses it to index into a table of actions to decide what to do.
The table—an example of which is given for the vacuum world in Figure 2.3—represents
explicitly the agent function that the agent program embodies. To build a rational agent in
4

There are other choices for the agent program skeleton; for example, we could have the agent programs be
coroutines that run asynchronously with the environment. Each such coroutine has an input and output port and
consists of a loop that reads the input port for percepts and writes actions to the output port.

Section 2.4.

The Structure of Agents

47

function TABLE -D RIVEN -AGENT( percept ) returns an action
persistent: percepts, a sequence, initially empty
table, a table of actions, indexed by percept sequences, initially fully specified
append percept to the end of percepts
action ← L OOKUP( percepts, table)
return action
Figure 2.7 The TABLE -D RIVEN -AGENT program is invoked for each new percept and
returns an action each time. It retains the complete percept sequence in memory.

this way, we as designers must construct a table that contains the appropriate action for every
possible percept sequence.
It is instructive to consider why the table-driven approach to agent construction is
doomed to failure. Let P be the set of possible percepts and let T be the lifetime
 of the
agent (the total number of percepts it will receive). The lookup table will contain Tt= 1 |P|t
entries. Consider the automated taxi: the visual input from a single camera comes in at the
rate of roughly 27 megabytes per second (30 frames per second, 640 × 480 pixels with 24
bits of color information). This gives a lookup table with over 10250,000,000,000 entries for an
hour’s driving. Even the lookup table for chess—a tiny, well-behaved fragment of the real
world—would have at least 10150 entries. The daunting size of these tables (the number of
atoms in the observable universe is less than 1080 ) means that (a) no physical agent in this
universe will have the space to store the table, (b) the designer would not have time to create
the table, (c) no agent could ever learn all the right table entries from its experience, and (d)
even if the environment is simple enough to yield a feasible table size, the designer still has
no guidance about how to fill in the table entries.
Despite all this, TABLE -D RIVEN -AGENT does do what we want: it implements the
desired agent function. The key challenge for AI is to find out how to write programs that,
to the extent possible, produce rational behavior from a smallish program rather than from
a vast table. We have many examples showing that this can be done successfully in other
areas: for example, the huge tables of square roots used by engineers and schoolchildren prior
to the 1970s have now been replaced by a five-line program for Newton’s method running
on electronic calculators. The question is, can AI do for general intelligent behavior what
Newton did for square roots? We believe the answer is yes.
In the remainder of this section, we outline four basic kinds of agent programs that
embody the principles underlying almost all intelligent systems:
• Simple reflex agents;
• Model-based reflex agents;
• Goal-based agents; and
• Utility-based agents.
Each kind of agent program combines particular components in particular ways to generate
actions. Section 2.4.6 explains in general terms how to convert all these agents into learning

48

Chapter

2.

Intelligent Agents

function R EFLEX -VACUUM -AGENT( [location,status]) returns an action
if status = Dirty then return Suck
else if location = A then return Right
else if location = B then return Left
Figure 2.8 The agent program for a simple reflex agent in the two-state vacuum environment. This program implements the agent function tabulated in Figure 2.3.

agents that can improve the performance of their components so as to generate better actions.
Finally, Section 2.4.7 describes the variety of ways in which the components themselves can
be represented within the agent. This variety provides a major organizing principle for the
field and for the book itself.

2.4.2 Simple reflex agents
SIMPLE REFLEX
AGENT

CONDITION–ACTION
RULE

The simplest kind of agent is the simple reflex agent. These agents select actions on the basis
of the current percept, ignoring the rest of the percept history. For example, the vacuum agent
whose agent function is tabulated in Figure 2.3 is a simple reflex agent, because its decision
is based only on the current location and on whether that location contains dirt. An agent
program for this agent is shown in Figure 2.8.
Notice that the vacuum agent program is very small indeed compared to the corresponding table. The most obvious reduction comes from ignoring the percept history, which cuts
down the number of possibilities from 4T to just 4. A further, small reduction comes from
the fact that when the current square is dirty, the action does not depend on the location.
Simple reflex behaviors occur even in more complex environments. Imagine yourself
as the driver of the automated taxi. If the car in front brakes and its brake lights come on, then
you should notice this and initiate braking. In other words, some processing is done on the
visual input to establish the condition we call “The car in front is braking.” Then, this triggers
some established connection in the agent program to the action “initiate braking.” We call
such a connection a condition–action rule,5 written as
if car-in-front-is-braking then initiate-braking.
Humans also have many such connections, some of which are learned responses (as for driving) and some of which are innate reflexes (such as blinking when something approaches the
eye). In the course of the book, we show several different ways in which such connections
can be learned and implemented.
The program in Figure 2.8 is specific to one particular vacuum environment. A more
general and flexible approach is first to build a general-purpose interpreter for condition–
action rules and then to create rule sets for specific task environments. Figure 2.9 gives the
structure of this general program in schematic form, showing how the condition–action rules
allow the agent to make the connection from percept to action. (Do not worry if this seems
5

Also called situation–action rules, productions, or if–then rules.

Section 2.4.

The Structure of Agents

Agent

49

Sensors
What the world
is like now

Environment

Condition-action rules

What action I
should do now

Actuators

Figure 2.9

Schematic diagram of a simple reflex agent.

function S IMPLE -R EFLEX -AGENT( percept ) returns an action
persistent: rules, a set of condition–action rules
state ← I NTERPRET-I NPUT( percept )
rule ← RULE -M ATCH(state, rules)
action ← rule.ACTION
return action
Figure 2.10 A simple reflex agent. It acts according to a rule whose condition matches
the current state, as defined by the percept.

trivial; it gets more interesting shortly.) We use rectangles to denote the current internal state
of the agent’s decision process, and ovals to represent the background information used in
the process. The agent program, which is also very simple, is shown in Figure 2.10. The
I NTERPRET-I NPUT function generates an abstracted description of the current state from the
percept, and the RULE -M ATCH function returns the first rule in the set of rules that matches
the given state description. Note that the description in terms of “rules” and “matching” is
purely conceptual; actual implementations can be as simple as a collection of logic gates
implementing a Boolean circuit.
Simple reflex agents have the admirable property of being simple, but they turn out to be
of limited intelligence. The agent in Figure 2.10 will work only if the correct decision can be
made on the basis of only the current percept—that is, only if the environment is fully observable. Even a little bit of unobservability can cause serious trouble. For example, the braking
rule given earlier assumes that the condition car-in-front-is-braking can be determined from
the current percept—a single frame of video. This works if the car in front has a centrally
mounted brake light. Unfortunately, older models have different configurations of taillights,

50

RANDOMIZATION

Chapter

2.

Intelligent Agents

brake lights, and turn-signal lights, and it is not always possible to tell from a single image
whether the car is braking. A simple reflex agent driving behind such a car would either brake
continuously and unnecessarily, or, worse, never brake at all.
We can see a similar problem arising in the vacuum world. Suppose that a simple reflex
vacuum agent is deprived of its location sensor and has only a dirt sensor. Such an agent
has just two possible percepts: [Dirty] and [Clean]. It can Suck in response to [Dirty]; what
should it do in response to [Clean]? Moving Left fails (forever) if it happens to start in square
A, and moving Right fails (forever) if it happens to start in square B. Infinite loops are often
unavoidable for simple reflex agents operating in partially observable environments.
Escape from infinite loops is possible if the agent can randomize its actions. For example, if the vacuum agent perceives [Clean], it might flip a coin to choose between Left and
Right. It is easy to show that the agent will reach the other square in an average of two steps.
Then, if that square is dirty, the agent will clean it and the task will be complete. Hence, a
randomized simple reflex agent might outperform a deterministic simple reflex agent.
We mentioned in Section 2.3 that randomized behavior of the right kind can be rational
in some multiagent environments. In single-agent environments, randomization is usually not
rational. It is a useful trick that helps a simple reflex agent in some situations, but in most
cases we can do much better with more sophisticated deterministic agents.

2.4.3 Model-based reflex agents

INTERNAL STATE

MODEL-BASED
AGENT

The most effective way to handle partial observability is for the agent to keep track of the
part of the world it can’t see now. That is, the agent should maintain some sort of internal
state that depends on the percept history and thereby reflects at least some of the unobserved
aspects of the current state. For the braking problem, the internal state is not too extensive—
just the previous frame from the camera, allowing the agent to detect when two red lights at
the edge of the vehicle go on or off simultaneously. For other driving tasks such as changing
lanes, the agent needs to keep track of where the other cars are if it can’t see them all at once.
And for any driving to be possible at all, the agent needs to keep track of where its keys are.
Updating this internal state information as time goes by requires two kinds of knowledge to be encoded in the agent program. First, we need some information about how the
world evolves independently of the agent—for example, that an overtaking car generally will
be closer behind than it was a moment ago. Second, we need some information about how
the agent’s own actions affect the world—for example, that when the agent turns the steering
wheel clockwise, the car turns to the right, or that after driving for five minutes northbound
on the freeway, one is usually about five miles north of where one was five minutes ago. This
knowledge about “how the world works”—whether implemented in simple Boolean circuits
or in complete scientific theories—is called a model of the world. An agent that uses such a
model is called a model-based agent.
Figure 2.11 gives the structure of the model-based reflex agent with internal state, showing how the current percept is combined with the old internal state to generate the updated
description of the current state, based on the agent’s model of how the world works. The agent
program is shown in Figure 2.12. The interesting part is the function U PDATE -S TATE , which

Section 2.4.

The Structure of Agents

51

Sensors
State
How the world evolves

What my actions do

Condition-action rules

Agent
Figure 2.11

Environment

What the world
is like now

What action I
should do now
Actuators

A model-based reflex agent.

function M ODEL -BASED -R EFLEX -AGENT( percept ) returns an action
persistent: state, the agent’s current conception of the world state
model , a description of how the next state depends on current state and action
rules, a set of condition–action rules
action, the most recent action, initially none
state ← U PDATE -S TATE(state, action , percept , model )
rule ← RULE -M ATCH(state, rules)
action ← rule.ACTION
return action
Figure 2.12 A model-based reflex agent. It keeps track of the current state of the world,
using an internal model. It then chooses an action in the same way as the reflex agent.

is responsible for creating the new internal state description. The details of how models and
states are represented vary widely depending on the type of environment and the particular
technology used in the agent design. Detailed examples of models and updating algorithms
appear in Chapters 4, 12, 11, 15, 17, and 25.
Regardless of the kind of representation used, it is seldom possible for the agent to
determine the current state of a partially observable environment exactly. Instead, the box
labeled “what the world is like now” (Figure 2.11) represents the agent’s “best guess” (or
sometimes best guesses). For example, an automated taxi may not be able to see around the
large truck that has stopped in front of it and can only guess about what may be causing the
hold-up. Thus, uncertainty about the current state may be unavoidable, but the agent still has
to make a decision.
A perhaps less obvious point about the internal “state” maintained by a model-based
agent is that it does not have to describe “what the world is like now” in a literal sense. For

52

Chapter

2.

Intelligent Agents

Sensors
State
What the world
is like now

What my actions do

What it will be like
if I do action A

Goals

What action I
should do now

Agent

Environment

How the world evolves

Actuators

Figure 2.13 A model-based, goal-based agent. It keeps track of the world state as well as
a set of goals it is trying to achieve, and chooses an action that will (eventually) lead to the
achievement of its goals.

example, the taxi may be driving back home, and it may have a rule telling it to fill up with
gas on the way home unless it has at least half a tank. Although “driving back home” may
seem to an aspect of the world state, the fact of the taxi’s destination is actually an aspect of
the agent’s internal state. If you find this puzzling, consider that the taxi could be in exactly
the same place at the same time, but intending to reach a different destination.

2.4.4 Goal-based agents

GOAL

Knowing something about the current state of the environment is not always enough to decide
what to do. For example, at a road junction, the taxi can turn left, turn right, or go straight
on. The correct decision depends on where the taxi is trying to get to. In other words, as well
as a current state description, the agent needs some sort of goal information that describes
situations that are desirable—for example, being at the passenger’s destination. The agent
program can combine this with the model (the same information as was used in the modelbased reflex agent) to choose actions that achieve the goal. Figure 2.13 shows the goal-based
agent’s structure.
Sometimes goal-based action selection is straightforward—for example, when goal satisfaction results immediately from a single action. Sometimes it will be more tricky—for
example, when the agent has to consider long sequences of twists and turns in order to find a
way to achieve the goal. Search (Chapters 3 to 5) and planning (Chapters 10 and 11) are the
subfields of AI devoted to finding action sequences that achieve the agent’s goals.
Notice that decision making of this kind is fundamentally different from the condition–
action rules described earlier, in that it involves consideration of the future—both “What will
happen if I do such-and-such?” and “Will that make me happy?” In the reflex agent designs,
this information is not explicitly represented, because the built-in rules map directly from

Section 2.4.

The Structure of Agents

53

percepts to actions. The reflex agent brakes when it sees brake lights. A goal-based agent, in
principle, could reason that if the car in front has its brake lights on, it will slow down. Given
the way the world usually evolves, the only action that will achieve the goal of not hitting
other cars is to brake.
Although the goal-based agent appears less efficient, it is more flexible because the
knowledge that supports its decisions is represented explicitly and can be modified. If it starts
to rain, the agent can update its knowledge of how effectively its brakes will operate; this will
automatically cause all of the relevant behaviors to be altered to suit the new conditions.
For the reflex agent, on the other hand, we would have to rewrite many condition–action
rules. The goal-based agent’s behavior can easily be changed to go to a different destination,
simply by specifying that destination as the goal. The reflex agent’s rules for when to turn
and when to go straight will work only for a single destination; they must all be replaced to
go somewhere new.

2.4.5 Utility-based agents

UTILITY

UTILITY FUNCTION

EXPECTED UTILITY

Goals alone are not enough to generate high-quality behavior in most environments. For
example, many action sequences will get the taxi to its destination (thereby achieving the
goal) but some are quicker, safer, more reliable, or cheaper than others. Goals just provide a
crude binary distinction between “happy” and “unhappy” states. A more general performance
measure should allow a comparison of different world states according to exactly how happy
they would make the agent. Because “happy” does not sound very scientific, economists and
computer scientists use the term utility instead.6
We have already seen that a performance measure assigns a score to any given sequence
of environment states, so it can easily distinguish between more and less desirable ways of
getting to the taxi’s destination. An agent’s utility function is essentially an internalization
of the performance measure. If the internal utility function and the external performance
measure are in agreement, then an agent that chooses actions to maximize its utility will be
rational according to the external performance measure.
Let us emphasize again that this is not the only way to be rational—we have already
seen a rational agent program for the vacuum world (Figure 2.8) that has no idea what its
utility function is—but, like goal-based agents, a utility-based agent has many advantages in
terms of flexibility and learning. Furthermore, in two kinds of cases, goals are inadequate but
a utility-based agent can still make rational decisions. First, when there are conflicting goals,
only some of which can be achieved (for example, speed and safety), the utility function
specifies the appropriate tradeoff. Second, when there are several goals that the agent can
aim for, none of which can be achieved with certainty, utility provides a way in which the
likelihood of success can be weighed against the importance of the goals.
Partial observability and stochasticity are ubiquitous in the real world, and so, therefore,
is decision making under uncertainty. Technically speaking, a rational utility-based agent
chooses the action that maximizes the expected utility of the action outcomes—that is, the
utility the agent expects to derive, on average, given the probabilities and utilities of each
6

The word “utility” here refers to “the quality of being useful,” not to the electric company or waterworks.

54

Chapter

2.

Intelligent Agents

Sensors
State
What the world
is like now

What my actions do

What it will be like
if I do action A

Utility

How happy I will be
in such a state

Environment

How the world evolves

What action I
should do now

Agent

Actuators

Figure 2.14 A model-based, utility-based agent. It uses a model of the world, along with
a utility function that measures its preferences among states of the world. Then it chooses the
action that leads to the best expected utility, where expected utility is computed by averaging
over all possible outcome states, weighted by the probability of the outcome.

outcome. (Appendix A defines expectation more precisely.) In Chapter 16, we show that any
rational agent must behave as if it possesses a utility function whose expected value it tries
to maximize. An agent that possesses an explicit utility function can make rational decisions
with a general-purpose algorithm that does not depend on the specific utility function being
maximized. In this way, the “global” definition of rationality—designating as rational those
agent functions that have the highest performance—is turned into a “local” constraint on
rational-agent designs that can be expressed in a simple program.
The utility-based agent structure appears in Figure 2.14. Utility-based agent programs
appear in Part IV, where we design decision-making agents that must handle the uncertainty
inherent in stochastic or partially observable environments.
At this point, the reader may be wondering, “Is it that simple? We just build agents that
maximize expected utility, and we’re done?” It’s true that such agents would be intelligent,
but it’s not simple. A utility-based agent has to model and keep track of its environment,
tasks that have involved a great deal of research on perception, representation, reasoning,
and learning. The results of this research fill many of the chapters of this book. Choosing
the utility-maximizing course of action is also a difficult task, requiring ingenious algorithms
that fill several more chapters. Even with these algorithms, perfect rationality is usually
unachievable in practice because of computational complexity, as we noted in Chapter 1.

2.4.6 Learning agents
We have described agent programs with various methods for selecting actions. We have
not, so far, explained how the agent programs come into being. In his famous early paper,
Turing (1950) considers the idea of actually programming his intelligent machines by hand.

Section 2.4.

The Structure of Agents

55

Performance standard

Sensors

Critic

changes
Learning
element

knowledge

Performance
element

learning
goals

Environment

feedback

Problem
generator

Agent
Figure 2.15

LEARNING ELEMENT
PERFORMANCE
ELEMENT

CRITIC

Actuators

A general learning agent.

He estimates how much work this might take and concludes “Some more expeditious method
seems desirable.” The method he proposes is to build learning machines and then to teach
them. In many areas of AI, this is now the preferred method for creating state-of-the-art
systems. Learning has another advantage, as we noted earlier: it allows the agent to operate
in initially unknown environments and to become more competent than its initial knowledge
alone might allow. In this section, we briefly introduce the main ideas of learning agents.
Throughout the book, we comment on opportunities and methods for learning in particular
kinds of agents. Part V goes into much more depth on the learning algorithms themselves.
A learning agent can be divided into four conceptual components, as shown in Figure 2.15. The most important distinction is between the learning element, which is responsible for making improvements, and the performance element, which is responsible for
selecting external actions. The performance element is what we have previously considered
to be the entire agent: it takes in percepts and decides on actions. The learning element uses
feedback from the critic on how the agent is doing and determines how the performance
element should be modified to do better in the future.
The design of the learning element depends very much on the design of the performance
element. When trying to design an agent that learns a certain capability, the first question is
not “How am I going to get it to learn this?” but “What kind of performance element will my
agent need to do this once it has learned how?” Given an agent design, learning mechanisms
can be constructed to improve every part of the agent.
The critic tells the learning element how well the agent is doing with respect to a fixed
performance standard. The critic is necessary because the percepts themselves provide no
indication of the agent’s success. For example, a chess program could receive a percept
indicating that it has checkmated its opponent, but it needs a performance standard to know
that this is a good thing; the percept itself does not say so. It is important that the performance

56

PROBLEM
GENERATOR

Chapter

2.

Intelligent Agents

standard be fixed. Conceptually, one should think of it as being outside the agent altogether
because the agent must not modify it to fit its own behavior.
The last component of the learning agent is the problem generator. It is responsible
for suggesting actions that will lead to new and informative experiences. The point is that
if the performance element had its way, it would keep doing the actions that are best, given
what it knows. But if the agent is willing to explore a little and do some perhaps suboptimal
actions in the short run, it might discover much better actions for the long run. The problem
generator’s job is to suggest these exploratory actions. This is what scientists do when they
carry out experiments. Galileo did not think that dropping rocks from the top of a tower in
Pisa was valuable in itself. He was not trying to break the rocks or to modify the brains of
unfortunate passers-by. His aim was to modify his own brain by identifying a better theory
of the motion of objects.
To make the overall design more concrete, let us return to the automated taxi example.
The performance element consists of whatever collection of knowledge and procedures the
taxi has for selecting its driving actions. The taxi goes out on the road and drives, using
this performance element. The critic observes the world and passes information along to the
learning element. For example, after the taxi makes a quick left turn across three lanes of traffic, the critic observes the shocking language used by other drivers. From this experience, the
learning element is able to formulate a rule saying this was a bad action, and the performance
element is modified by installation of the new rule. The problem generator might identify
certain areas of behavior in need of improvement and suggest experiments, such as trying out
the brakes on different road surfaces under different conditions.
The learning element can make changes to any of the “knowledge” components shown
in the agent diagrams (Figures 2.9, 2.11, 2.13, and 2.14). The simplest cases involve learning
directly from the percept sequence. Observation of pairs of successive states of the environment can allow the agent to learn “How the world evolves,” and observation of the results of
its actions can allow the agent to learn “What my actions do.” For example, if the taxi exerts
a certain braking pressure when driving on a wet road, then it will soon find out how much
deceleration is actually achieved. Clearly, these two learning tasks are more difficult if the
environment is only partially observable.
The forms of learning in the preceding paragraph do not need to access the external
performance standard—in a sense, the standard is the universal one of making predictions
that agree with experiment. The situation is slightly more complex for a utility-based agent
that wishes to learn utility information. For example, suppose the taxi-driving agent receives
no tips from passengers who have been thoroughly shaken up during the trip. The external
performance standard must inform the agent that the loss of tips is a negative contribution to
its overall performance; then the agent might be able to learn that violent maneuvers do not
contribute to its own utility. In a sense, the performance standard distinguishes part of the
incoming percept as a reward (or penalty) that provides direct feedback on the quality of the
agent’s behavior. Hard-wired performance standards such as pain and hunger in animals can
be understood in this way. This issue is discussed further in Chapter 21.
In summary, agents have a variety of components, and those components can be represented in many ways within the agent program, so there appears to be great variety among

Section 2.4.

The Structure of Agents

57

learning methods. There is, however, a single unifying theme. Learning in intelligent agents
can be summarized as a process of modification of each component of the agent to bring the
components into closer agreement with the available feedback information, thereby improving the overall performance of the agent.

2.4.7 How the components of agent programs work
We have described agent programs (in very high-level terms) as consisting of various components, whose function it is to answer questions such as: “What is the world like now?” “What
action should I do now?” “What do my actions do?” The next question for a student of AI
is, “How on earth do these components work?” It takes about a thousand pages to begin to
answer that question properly, but here we want to draw the reader’s attention to some basic
distinctions among the various ways that the components can represent the environment that
the agent inhabits.
Roughly speaking, we can place the representations along an axis of increasing complexity and expressive power—atomic, factored, and structured. To illustrate these ideas,
it helps to consider a particular agent component, such as the one that deals with “What my
actions do.” This component describes the changes that might occur in the environment as
the result of taking an action, and Figure 2.16 provides schematic depictions of how those
transitions might be represented.

B

C

B

(a) Atomic

C

(b) Factored

(b) Structured

Figure 2.16 Three ways to represent states and the transitions between them. (a) Atomic
representation: a state (such as B or C) is a black box with no internal structure; (b) Factored
representation: a state consists of a vector of attribute values; values can be Boolean, realvalued, or one of a fixed set of symbols. (c) Structured representation: a state includes
objects, each of which may have attributes of its own as well as relationships to other objects.
ATOMIC
REPRESENTATION

In an atomic representation each state of the world is indivisible—it has no internal
structure. Consider the problem of finding a driving route from one end of a country to the
other via some sequence of cities (we address this problem in Figure 3.2 on page 68). For the
purposes of solving this problem, it may suffice to reduce the state of world to just the name
of the city we are in—a single atom of knowledge; a “black box” whose only discernible
property is that of being identical to or different from another black box. The algorithms

58

FACTORED
REPRESENTATION
VARIABLE
ATTRIBUTE
VALUE

STRUCTURED
REPRESENTATION

EXPRESSIVENESS

Chapter

2.

Intelligent Agents

underlying search and game-playing (Chapters 3–5), Hidden Markov models (Chapter 15),
and Markov decision processes (Chapter 17) all work with atomic representations—or, at
least, they treat representations as if they were atomic.
Now consider a higher-fidelity description for the same problem, where we need to be
concerned with more than just atomic location in one city or another; we might need to pay
attention to how much gas is in the tank, our current GPS coordinates, whether or not the oil
warning light is working, how much spare change we have for toll crossings, what station is
on the radio, and so on. A factored representation splits up each state into a fixed set of
variables or attributes, each of which can have a value. While two different atomic states
have nothing in common—they are just different black boxes—two different factored states
can share some attributes (such as being at some particular GPS location) and not others (such
as having lots of gas or having no gas); this makes it much easier to work out how to turn
one state into another. With factored representations, we can also represent uncertainty—for
example, ignorance about the amount of gas in the tank can be represented by leaving that
attribute blank. Many important areas of AI are based on factored representations, including
constraint satisfaction algorithms (Chapter 6), propositional logic (Chapter 7), planning
(Chapters 10 and 11), Bayesian networks (Chapters 13–16), and the machine learning algorithms in Chapters 18, 20, and 21.
For many purposes, we need to understand the world as having things in it that are
related to each other, not just variables with values. For example, we might notice that a
large truck ahead of us is reversing into the driveway of a dairy farm but a cow has got loose
and is blocking the truck’s path. A factored representation is unlikely to be pre-equipped
with the attribute TruckAheadBackingIntoDairyFarmDrivewayBlockedByLooseCow with
value true or false. Instead, we would need a structured representation, in which objects such as cows and trucks and their various and varying relationships can be described
explicitly. (See Figure 2.16(c).) Structured representations underlie relational databases
and first-order logic (Chapters 8, 9, and 12), first-order probability models (Chapter 14),
knowledge-based learning (Chapter 19) and much of natural language understanding
(Chapters 22 and 23). In fact, almost everything that humans express in natural language
concerns objects and their relationships.
As we mentioned earlier, the axis along which atomic, factored, and structured representations lie is the axis of increasing expressiveness. Roughly speaking, a more expressive
representation can capture, at least as concisely, everything a less expressive one can capture,
plus some more. Often, the more expressive language is much more concise; for example, the
rules of chess can be written in a page or two of a structured-representation language such
as first-order logic but require thousands of pages when written in a factored-representation
language such as propositional logic. On the other hand, reasoning and learning become
more complex as the expressive power of the representation increases. To gain the benefits
of expressive representations while avoiding their drawbacks, intelligent systems for the real
world may need to operate at all points along the axis simultaneously.

Section 2.5.

2.5

Summary

59

S UMMARY
This chapter has been something of a whirlwind tour of AI, which we have conceived of as
the science of agent design. The major points to recall are as follows:
• An agent is something that perceives and acts in an environment. The agent function
for an agent specifies the action taken by the agent in response to any percept sequence.
• The performance measure evaluates the behavior of the agent in an environment. A
rational agent acts so as to maximize the expected value of the performance measure,
given the percept sequence it has seen so far.
• A task environment specification includes the performance measure, the external environment, the actuators, and the sensors. In designing an agent, the first step must
always be to specify the task environment as fully as possible.
• Task environments vary along several significant dimensions. They can be fully or
partially observable, single-agent or multiagent, deterministic or stochastic, episodic or
sequential, static or dynamic, discrete or continuous, and known or unknown.
• The agent program implements the agent function. There exists a variety of basic
agent-program designs reflecting the kind of information made explicit and used in the
decision process. The designs vary in efficiency, compactness, and flexibility. The
appropriate design of the agent program depends on the nature of the environment.
• Simple reflex agents respond directly to percepts, whereas model-based reflex agents
maintain internal state to track aspects of the world that are not evident in the current
percept. Goal-based agents act to achieve their goals, and utility-based agents try to
maximize their own expected “happiness.”
• All agents can improve their performance through learning.

B IBLIOGRAPHICAL AND H ISTORICAL N OTES

CONTROLLER

The central role of action in intelligence—the notion of practical reasoning—goes back at
least as far as Aristotle’s Nicomachean Ethics. Practical reasoning was also the subject of
McCarthy’s (1958) influential paper “Programs with Common Sense.” The fields of robotics
and control theory are, by their very nature, concerned principally with physical agents. The
concept of a controller in control theory is identical to that of an agent in AI. Perhaps surprisingly, AI has concentrated for most of its history on isolated components of agents—
question-answering systems, theorem-provers, vision systems, and so on—rather than on
whole agents. The discussion of agents in the text by Genesereth and Nilsson (1987) was an
influential exception. The whole-agent view is now widely accepted and is a central theme in
recent texts (Poole et al., 1998; Nilsson, 1998; Padgham and Winikoff, 2004; Jones, 2007).
Chapter 1 traced the roots of the concept of rationality in philosophy and economics. In
AI, the concept was of peripheral interest until the mid-1980s, when it began to suffuse many

60

AUTONOMIC
COMPUTING

MULTIAGENT
SYSTEMS

Chapter

2.

Intelligent Agents

discussions about the proper technical foundations of the field. A paper by Jon Doyle (1983)
predicted that rational agent design would come to be seen as the core mission of AI, while
other popular topics would spin off to form new disciplines.
Careful attention to the properties of the environment and their consequences for rational agent design is most apparent in the control theory tradition—for example, classical
control systems (Dorf and Bishop, 2004; Kirk, 2004) handle fully observable, deterministic
environments; stochastic optimal control (Kumar and Varaiya, 1986; Bertsekas and Shreve,
2007) handles partially observable, stochastic environments; and hybrid control (Henzinger
and Sastry, 1998; Cassandras and Lygeros, 2006) deals with environments containing both
discrete and continuous elements. The distinction between fully and partially observable environments is also central in the dynamic programming literature developed in the field of
operations research (Puterman, 1994), which we discuss in Chapter 17.
Reflex agents were the primary model for psychological behaviorists such as Skinner
(1953), who attempted to reduce the psychology of organisms strictly to input/output or stimulus/response mappings. The advance from behaviorism to functionalism in psychology,
which was at least partly driven by the application of the computer metaphor to agents (Putnam, 1960; Lewis, 1966), introduced the internal state of the agent into the picture. Most
work in AI views the idea of pure reflex agents with state as too simple to provide much
leverage, but work by Rosenschein (1985) and Brooks (1986) questioned this assumption
(see Chapter 25). In recent years, a great deal of work has gone into finding efficient algorithms for keeping track of complex environments (Hamscher et al., 1992; Simon, 2006). The
Remote Agent program (described on page 28) that controlled the Deep Space One spacecraft
is a particularly impressive example (Muscettola et al., 1998; Jonsson et al., 2000).
Goal-based agents are presupposed in everything from Aristotle’s view of practical reasoning to McCarthy’s early papers on logical AI. Shakey the Robot (Fikes and Nilsson,
1971; Nilsson, 1984) was the first robotic embodiment of a logical, goal-based agent. A
full logical analysis of goal-based agents appeared in Genesereth and Nilsson (1987), and a
goal-based programming methodology called agent-oriented programming was developed by
Shoham (1993). The agent-based approach is now extremely popular in software engineering (Ciancarini and Wooldridge, 2001). It has also infiltrated the area of operating systems,
where autonomic computing refers to computer systems and networks that monitor and control themselves with a perceive–act loop and machine learning methods (Kephart and Chess,
2003). Noting that a collection of agent programs designed to work well together in a true
multiagent environment necessarily exhibits modularity—the programs share no internal state
and communicate with each other only through the environment—it is common within the
field of multiagent systems to design the agent program of a single agent as a collection of
autonomous sub-agents. In some cases, one can even prove that the resulting system gives
the same optimal solutions as a monolithic design.
The goal-based view of agents also dominates the cognitive psychology tradition in the
area of problem solving, beginning with the enormously influential Human Problem Solving (Newell and Simon, 1972) and running through all of Newell’s later work (Newell, 1990).
Goals, further analyzed as desires (general) and intentions (currently pursued), are central to
the theory of agents developed by Bratman (1987). This theory has been influential both in

Exercises

61
natural language understanding and multiagent systems.
Horvitz et al. (1988) specifically suggest the use of rationality conceived as the maximization of expected utility as a basis for AI. The text by Pearl (1988) was the first in AI to
cover probability and utility theory in depth; its exposition of practical methods for reasoning
and decision making under uncertainty was probably the single biggest factor in the rapid
shift towards utility-based agents in the 1990s (see Part IV).
The general design for learning agents portrayed in Figure 2.15 is classic in the machine
learning literature (Buchanan et al., 1978; Mitchell, 1997). Examples of the design, as embodied in programs, go back at least as far as Arthur Samuel’s (1959, 1967) learning program
for playing checkers. Learning agents are discussed in depth in Part V.
Interest in agents and in agent design has risen rapidly in recent years, partly because of
the growth of the Internet and the perceived need for automated and mobile softbot (Etzioni
and Weld, 1994). Relevant papers are collected in Readings in Agents (Huhns and Singh,
1998) and Foundations of Rational Agency (Wooldridge and Rao, 1999). Texts on multiagent
systems usually provide a good introduction to many aspects of agent design (Weiss, 2000a;
Wooldridge, 2002). Several conference series devoted to agents began in the 1990s, including
the International Workshop on Agent Theories, Architectures, and Languages (ATAL), the
International Conference on Autonomous Agents (AGENTS), and the International Conference on Multi-Agent Systems (ICMAS). In 2002, these three merged to form the International
Joint Conference on Autonomous Agents and Multi-Agent Systems (AAMAS). The journal
Autonomous Agents and Multi-Agent Systems was founded in 1998. Finally, Dung Beetle
Ecology (Hanski and Cambefort, 1991) provides a wealth of interesting information on the
behavior of dung beetles. YouTube features inspiring video recordings of their activities.

E XERCISES
2.1 Suppose that the performance measure is concerned with just the first T time steps of
the environment and ignores everything thereafter. Show that a rational agent’s action may
depend not just on the state of the environment but also on the time step it has reached.
2.2

Let us examine the rationality of various vacuum-cleaner agent functions.

a. Show that the simple vacuum-cleaner agent function described in Figure 2.3 is indeed
rational under the assumptions listed on page 38.
b. Describe a rational agent function for the case in which each movement costs one point.
Does the corresponding agent program require internal state?
c. Discuss possible agent designs for the cases in which clean squares can become dirty
and the geography of the environment is unknown. Does it make sense for the agent to
learn from its experience in these cases? If so, what should it learn? If not, why not?
2.3 For each of the following assertions, say whether it is true or false and support your
answer with examples or counterexamples where appropriate.
a. An agent that senses only partial information about the state cannot be perfectly rational.

62

Chapter

2.

Intelligent Agents

b. There exist task environments in which no pure reflex agent can behave rationally.
c. There exists a task environment in which every agent is rational.
d. The input to an agent program is the same as the input to the agent function.
e. Every agent function is implementable by some program/machine combination.
f. Suppose an agent selects its action uniformly at random from the set of possible actions.
There exists a deterministic task environment in which this agent is rational.
g. It is possible for a given agent to be perfectly rational in two distinct task environments.
h. Every agent is rational in an unobservable environment.
i. A perfectly rational poker-playing agent never loses.
2.4 For each of the following activities, give a PEAS description of the task environment
and characterize it in terms of the properties listed in Section 2.3.2.
• Playing soccer.
• Exploring the subsurface oceans of Titan.
• Shopping for used AI books on the Internet.
• Playing a tennis match.
• Practicing tennis against a wall.
• Performing a high jump.
• Knitting a sweater.
• Bidding on an item at an auction.
2.5 Define in your own words the following terms: agent, agent function, agent program,
rationality, autonomy, reflex agent, model-based agent, goal-based agent, utility-based agent,
learning agent.
2.6

This exercise explores the differences between agent functions and agent programs.

a. Can there be more than one agent program that implements a given agent function?
Give an example, or show why one is not possible.
b. Are there agent functions that cannot be implemented by any agent program?
c. Given a fixed machine architecture, does each agent program implement exactly one
agent function?
d. Given an architecture with n bits of storage, how many different possible agent programs are there?
e. Suppose we keep the agent program fixed but speed up the machine by a factor of two.
Does that change the agent function?
2.7

Write pseudocode agent programs for the goal-based and utility-based agents.

The following exercises all concern the implementation of environments and agents for the
vacuum-cleaner world.

Exercises

63
2.8 Implement a performance-measuring environment simulator for the vacuum-cleaner
world depicted in Figure 2.2 and specified on page 38. Your implementation should be modular so that the sensors, actuators, and environment characteristics (size, shape, dirt placement,
etc.) can be changed easily. (Note: for some choices of programming language and operating
system there are already implementations in the online code repository.)
2.9 Implement a simple reflex agent for the vacuum environment in Exercise 2.8. Run the
environment with this agent for all possible initial dirt configurations and agent locations.
Record the performance score for each configuration and the overall average score.
2.10 Consider a modified version of the vacuum environment in Exercise 2.8, in which the
agent is penalized one point for each movement.
a. Can a simple reflex agent be perfectly rational for this environment? Explain.
b. What about a reflex agent with state? Design such an agent.
c. How do your answers to a and b change if the agent’s percepts give it the clean/dirty
status of every square in the environment?
2.11 Consider a modified version of the vacuum environment in Exercise 2.8, in which the
geography of the environment—its extent, boundaries, and obstacles—is unknown, as is the
initial dirt configuration. (The agent can go Up and Down as well as Left and Right.)
a. Can a simple reflex agent be perfectly rational for this environment? Explain.
b. Can a simple reflex agent with a randomized agent function outperform a simple reflex
agent? Design such an agent and measure its performance on several environments.
c. Can you design an environment in which your randomized agent will perform poorly?
Show your results.
d. Can a reflex agent with state outperform a simple reflex agent? Design such an agent
and measure its performance on several environments. Can you design a rational agent
of this type?
2.12 Repeat Exercise 2.11 for the case in which the location sensor is replaced with a
“bump” sensor that detects the agent’s attempts to move into an obstacle or to cross the
boundaries of the environment. Suppose the bump sensor stops working; how should the
agent behave?
2.13 The vacuum environments in the preceding exercises have all been deterministic. Discuss possible agent programs for each of the following stochastic versions:
a. Murphy’s law: twenty-five percent of the time, the Suck action fails to clean the floor if
it is dirty and deposits dirt onto the floor if the floor is clean. How is your agent program
affected if the dirt sensor gives the wrong answer 10% of the time?
b. Small children: At each time step, each clean square has a 10% chance of becoming
dirty. Can you come up with a rational agent design for this case?

3

SOLVING PROBLEMS BY
SEARCHING

In which we see how an agent can find a sequence of actions that achieves its
goals when no single action will do.

PROBLEM-SOLVING
AGENT

3.1

The simplest agents discussed in Chapter 2 were the reflex agents, which base their actions on
a direct mapping from states to actions. Such agents cannot operate well in environments for
which this mapping would be too large to store and would take too long to learn. Goal-based
agents, on the other hand, consider future actions and the desirability of their outcomes.
This chapter describes one kind of goal-based agent called a problem-solving agent.
Problem-solving agents use atomic representations, as described in Section 2.4.7—that is,
states of the world are considered as wholes, with no internal structure visible to the problemsolving algorithms. Goal-based agents that use more advanced factored or structured representations are usually called planning agents and are discussed in Chapters 7 and 10.
Our discussion of problem solving begins with precise definitions of problems and their
solutions and give several examples to illustrate these definitions. We then describe several
general-purpose search algorithms that can be used to solve these problems. We will see
several uninformed search algorithms—algorithms that are given no information about the
problem other than its definition. Although some of these algorithms can solve any solvable
problem, none of them can do so efficiently. Informed search algorithms, on the other hand,
can do quite well given some guidance on where to look for solutions.
In this chapter, we limit ourselves to the simplest kind of task environment, for which
the solution to a problem is always a fixed sequence of actions. The more general case—where
the agent’s future actions may vary depending on future percepts—is handled in Chapter 4.
This chapter uses the concepts of asymptotic complexity (that is, O() notation) and
NP-completeness. Readers unfamiliar with these concepts should consult Appendix A.

P ROBLEM -S OLVING AGENTS
Intelligent agents are supposed to maximize their performance measure. As we mentioned
in Chapter 2, achieving this is sometimes simplified if the agent can adopt a goal and aim at
satisfying it. Let us first look at why and how an agent might do this.
64

Section 3.1.

GOAL FORMULATION

PROBLEM
FORMULATION

Problem-Solving Agents

65

Imagine an agent in the city of Arad, Romania, enjoying a touring holiday. The agent’s
performance measure contains many factors: it wants to improve its suntan, improve its Romanian, take in the sights, enjoy the nightlife (such as it is), avoid hangovers, and so on. The
decision problem is a complex one involving many tradeoffs and careful reading of guidebooks. Now, suppose the agent has a nonrefundable ticket to fly out of Bucharest the following day. In that case, it makes sense for the agent to adopt the goal of getting to Bucharest.
Courses of action that don’t reach Bucharest on time can be rejected without further consideration and the agent’s decision problem is greatly simplified. Goals help organize behavior
by limiting the objectives that the agent is trying to achieve and hence the actions it needs
to consider. Goal formulation, based on the current situation and the agent’s performance
measure, is the first step in problem solving.
We will consider a goal to be a set of world states—exactly those states in which the
goal is satisfied. The agent’s task is to find out how to act, now and in the future, so that it
reaches a goal state. Before it can do this, it needs to decide (or we need to decide on its
behalf) what sorts of actions and states it should consider. If it were to consider actions at
the level of “move the left foot forward an inch” or “turn the steering wheel one degree left,”
the agent would probably never find its way out of the parking lot, let alone to Bucharest,
because at that level of detail there is too much uncertainty in the world and there would be
too many steps in a solution. Problem formulation is the process of deciding what actions
and states to consider, given a goal. We discuss this process in more detail later. For now, let
us assume that the agent will consider actions at the level of driving from one major town to
another. Each state therefore corresponds to being in a particular town.
Our agent has now adopted the goal of driving to Bucharest and is considering where
to go from Arad. Three roads lead out of Arad, one toward Sibiu, one to Timisoara, and one
to Zerind. None of these achieves the goal, so unless the agent is familiar with the geography
of Romania, it will not know which road to follow.1 In other words, the agent will not know
which of its possible actions is best, because it does not yet know enough about the state
that results from taking each action. If the agent has no additional information—i.e., if the
environment is unknown in the sense defined in Section 2.3—then it is has no choice but to
try one of the actions at random. This sad situation is discussed in Chapter 4.
But suppose the agent has a map of Romania. The point of a map is to provide the
agent with information about the states it might get itself into and the actions it can take. The
agent can use this information to consider subsequent stages of a hypothetical journey via
each of the three towns, trying to find a journey that eventually gets to Bucharest. Once it has
found a path on the map from Arad to Bucharest, it can achieve its goal by carrying out the
driving actions that correspond to the legs of the journey. In general, an agent with several
immediate options of unknown value can decide what to do by first examining future actions
that eventually lead to states of known value.
To be more specific about what we mean by “examining future actions,” we have to
be more specific about properties of the environment, as defined in Section 2.3. For now,
1

We are assuming that most readers are in the same position and can easily imagine themselves to be as clueless
as our agent. We apologize to Romanian readers who are unable to take advantage of this pedagogical device.

66

SEARCH
SOLUTION

EXECUTION

OPEN-LOOP

Chapter

3.

Solving Problems by Searching

we assume that the environment is observable, so the agent always knows the current state.
For the agent driving in Romania, it’s reasonable to suppose that each city on the map has a
sign indicating its presence to arriving drivers. We also assume the environment is discrete,
so at any given state there are only finitely many actions to choose from. This is true for
navigating in Romania because each city is connected to a small number of other cities. We
will assume the environment is known, so the agent knows which states are reached by each
action. (Having an accurate map suffices to meet this condition for navigation problems.)
Finally, we assume that the environment is deterministic, so each action has exactly one
outcome. Under ideal conditions, this is true for the agent in Romania—it means that if it
chooses to drive from Arad to Sibiu, it does end up in Sibiu. Of course, conditions are not
always ideal, as we show in Chapter 4.
Under these assumptions, the solution to any problem is a fixed sequence of actions.
“Of course!” one might say, “What else could it be?” Well, in general it could be a branching
strategy that recommends different actions in the future depending on what percepts arrive.
For example, under less than ideal conditions, the agent might plan to drive from Arad to
Sibiu and then to Rimnicu Vilcea but may also need to have a contingency plan in case it
arrives by accident in Zerind instead of Sibiu. Fortunately, if the agent knows the initial state
and the environment is known and deterministic, it knows exactly where it will be after the
first action and what it will perceive. Since only one percept is possible after the first action,
the solution can specify only one possible second action, and so on.
The process of looking for a sequence of actions that reaches the goal is called search.
A search algorithm takes a problem as input and returns a solution in the form of an action
sequence. Once a solution is found, the actions it recommends can be carried out. This
is called the execution phase. Thus, we have a simple “formulate, search, execute” design
for the agent, as shown in Figure 3.1. After formulating a goal and a problem to solve,
the agent calls a search procedure to solve it. It then uses the solution to guide its actions,
doing whatever the solution recommends as the next thing to do—typically, the first action of
the sequence—and then removing that step from the sequence. Once the solution has been
executed, the agent will formulate a new goal.
Notice that while the agent is executing the solution sequence it ignores its percepts
when choosing an action because it knows in advance what they will be. An agent that
carries out its plans with its eyes closed, so to speak, must be quite certain of what is going
on. Control theorists call this an open-loop system, because ignoring the percepts breaks the
loop between agent and environment.
We first describe the process of problem formulation, and then devote the bulk of the
chapter to various algorithms for the S EARCH function. We do not discuss the workings of
the U PDATE -S TATE and F ORMULATE -G OAL functions further in this chapter.

3.1.1 Well-defined problems and solutions
PROBLEM
INITIAL STATE

A problem can be defined formally by five components:
• The initial state that the agent starts in. For example, the initial state for our agent in
Romania might be described as In(Arad ).

Section 3.1.

Problem-Solving Agents

67

function S IMPLE -P ROBLEM -S OLVING -AGENT ( percept ) returns an action
persistent: seq, an action sequence, initially empty
state, some description of the current world state
goal , a goal, initially null
problem, a problem formulation
state ← U PDATE -S TATE(state, percept )
if seq is empty then
goal ← F ORMULATE -G OAL(state)
problem ← F ORMULATE -P ROBLEM(state, goal )
seq ← S EARCH ( problem)
if seq = failure then return a null action
action ← F IRST (seq)
seq ← R EST(seq)
return action
Figure 3.1 A simple problem-solving agent. It first formulates a goal and a problem,
searches for a sequence of actions that would solve the problem, and then executes the actions
one at a time. When this is complete, it formulates another goal and starts over.

• A description of the possible actions available to the agent. Given a particular state s,
ACTIONS (s) returns the set of actions that can be executed in s. We say that each of
these actions is applicable in s. For example, from the state In(Arad ), the applicable
actions are {Go(Sibiu), Go(Timisoara ), Go(Zerind )}.
• A description of what each action does; the formal name for this is the transition
model, specified by a function R ESULT (s, a) that returns the state that results from
doing action a in state s. We also use the term successor to refer to any state reachable
from a given state by a single action.2 For example, we have

ACTIONS

APPLICABLE

TRANSITION MODEL
SUCCESSOR

R ESULT (In(Arad ), Go(Zerind )) = In(Zerind ) .
Together, the initial state, actions, and transition model implicitly define the state space
of the problem—the set of all states reachable from the initial state by any sequence
of actions. The state space forms a directed network or graph in which the nodes
are states and the links between nodes are actions. (The map of Romania shown in
Figure 3.2 can be interpreted as a state-space graph if we view each road as standing
for two driving actions, one in each direction.) A path in the state space is a sequence
of states connected by a sequence of actions.
• The goal test, which determines whether a given state is a goal state. Sometimes there
is an explicit set of possible goal states, and the test simply checks whether the given
state is one of them. The agent’s goal in Romania is the singleton set {In(Bucharest )}.

STATE SPACE

GRAPH

PATH

GOAL TEST

2

Many treatments of problem solving, including previous editions of this book, use a successor function, which
returns the set of all successors, instead of separate A CTIONS and R ESULT functions. The successor function
makes it difficult to describe an agent that knows what actions it can try but not what they achieve. Also, note
some author use R ESULT(a, s) instead of R ESULT(s, a), and some use D O instead of R ESULT.

68

Chapter

3.

Solving Problems by Searching

Oradea
71

Neamt
Zerind

87

151

75

Iasi
Arad

140

92

Sibiu

99

Fagaras

118

Vaslui

80
Rimnicu Vilcea

Timisoara
111

Lugoj

142

211

Pitesti

97

70

98
Mehadia

146

75
Drobeta

85

101

Hirsova

Urziceni
86

138

Bucharest

120
90
Craiova

Figure 3.2

Eforie

A simplified road map of part of Romania.

Sometimes the goal is specified by an abstract property rather than an explicitly enumerated set of states. For example, in chess, the goal is to reach a state called “checkmate,”
where the opponent’s king is under attack and can’t escape.
• A path cost function that assigns a numeric cost to each path. The problem-solving
agent chooses a cost function that reflects its own performance measure. For the agent
trying to get to Bucharest, time is of the essence, so the cost of a path might be its length
in kilometers. In this chapter, we assume that the cost of a path can be described as the
sum of the costs of the individual actions along the path.3 The step cost of taking action
a in state s to reach state s is denoted by c(s, a, s ). The step costs for Romania are
shown in Figure 3.2 as route distances. We assume that step costs are nonnegative.4

PATH COST

STEP COST

OPTIMAL SOLUTION

Giurgiu

The preceding elements define a problem and can be gathered into a single data structure
that is given as input to a problem-solving algorithm. A solution to a problem is an action
sequence that leads from the initial state to a goal state. Solution quality is measured by the
path cost function, and an optimal solution has the lowest path cost among all solutions.

3.1.2 Formulating problems
In the preceding section we proposed a formulation of the problem of getting to Bucharest in
terms of the initial state, actions, transition model, goal test, and path cost. This formulation
seems reasonable, but it is still a model—an abstract mathematical description—and not the
3
4

This assumption is algorithmically convenient but also theoretically justifiable—see page 649 in Chapter 17.
The implications of negative costs are explored in Exercise 3.8.

Section 3.2.

ABSTRACTION

3.2

69

real thing. Compare the simple state description we have chosen, In(Arad), to an actual crosscountry trip, where the state of the world includes so many things: the traveling companions,
the current radio program, the scenery out of the window, the proximity of law enforcement
officers, the distance to the next rest stop, the condition of the road, the weather, and so on.
All these considerations are left out of our state descriptions because they are irrelevant to the
problem of finding a route to Bucharest. The process of removing detail from a representation
is called abstraction.
In addition to abstracting the state description, we must abstract the actions themselves.
A driving action has many effects. Besides changing the location of the vehicle and its occupants, it takes up time, consumes fuel, generates pollution, and changes the agent (as they
say, travel is broadening). Our formulation takes into account only the change in location.
Also, there are many actions that we omit altogether: turning on the radio, looking out of
the window, slowing down for law enforcement officers, and so on. And of course, we don’t
specify actions at the level of “turn steering wheel to the left by one degree.”
Can we be more precise about defining the appropriate level of abstraction? Think of the
abstract states and actions we have chosen as corresponding to large sets of detailed world
states and detailed action sequences. Now consider a solution to the abstract problem: for
example, the path from Arad to Sibiu to Rimnicu Vilcea to Pitesti to Bucharest. This abstract
solution corresponds to a large number of more detailed paths. For example, we could drive
with the radio on between Sibiu and Rimnicu Vilcea, and then switch it off for the rest of
the trip. The abstraction is valid if we can expand any abstract solution into a solution in the
more detailed world; a sufficient condition is that for every detailed state that is “in Arad,”
there is a detailed path to some state that is “in Sibiu,” and so on.5 The abstraction is useful
if carrying out each of the actions in the solution is easier than the original problem; in this
case they are easy enough that they can be carried out without further search or planning by
an average driving agent. The choice of a good abstraction thus involves removing as much
detail as possible while retaining validity and ensuring that the abstract actions are easy to
carry out. Were it not for the ability to construct useful abstractions, intelligent agents would
be completely swamped by the real world.

E XAMPLE P ROBLEMS

TOY PROBLEM

REAL-WORLD
PROBLEM

Example Problems

The problem-solving approach has been applied to a vast array of task environments. We
list some of the best known here, distinguishing between toy and real-world problems. A
toy problem is intended to illustrate or exercise various problem-solving methods. It can be
given a concise, exact description and hence is usable by different researchers to compare the
performance of algorithms. A real-world problem is one whose solutions people actually
care about. Such problems tend not to have a single agreed-upon description, but we can give
the general flavor of their formulations.
5

See Section 11.2 for a more complete set of definitions and algorithms.

70

Chapter

3.

Solving Problems by Searching

R
L

R
L
S

S

R

R

L

R

L

R

L

L
S

S
S

S
R
L

R
L
S

S

Figure 3.3 The state space for the vacuum world. Links denote actions: L = Left, R =
Right, S = Suck.

3.2.1 Toy problems
The first example we examine is the vacuum world first introduced in Chapter 2. (See
Figure 2.2.) This can be formulated as a problem as follows:
• States: The state is determined by both the agent location and the dirt locations. The
agent is in one of two locations, each of which might or might not contain dirt. Thus,
there are 2 × 22 = 8 possible world states. A larger environment with n locations has
n · 2n states.
• Initial state: Any state can be designated as the initial state.
• Actions: In this simple environment, each state has just three actions: Left, Right, and
Suck. Larger environments might also include Up and Down.
• Transition model: The actions have their expected effects, except that moving Left in
the leftmost square, moving Right in the rightmost square, and Sucking in a clean square
have no effect. The complete state space is shown in Figure 3.3.
• Goal test: This checks whether all the squares are clean.
• Path cost: Each step costs 1, so the path cost is the number of steps in the path.

8-PUZZLE

Compared with the real world, this toy problem has discrete locations, discrete dirt, reliable
cleaning, and it never gets any dirtier. Chapter 4 relaxes some of these assumptions.
The 8-puzzle, an instance of which is shown in Figure 3.4, consists of a 3×3 board with
eight numbered tiles and a blank space. A tile adjacent to the blank space can slide into the
space. The object is to reach a specified goal state, such as the one shown on the right of the
figure. The standard formulation is as follows:

Section 3.2.

Example Problems

71

7

2

5
8

3

4

2

6

3

4

5

1

6

7

8

Start State
Figure 3.4

1

Goal State

A typical instance of the 8-puzzle.

• States: A state description specifies the location of each of the eight tiles and the blank
in one of the nine squares.
• Initial state: Any state can be designated as the initial state. Note that any given goal
can be reached from exactly half of the possible initial states (Exercise 3.4).
• Actions: The simplest formulation defines the actions as movements of the blank space
Left, Right, Up, or Down. Different subsets of these are possible depending on where
the blank is.
• Transition model: Given a state and action, this returns the resulting state; for example,
if we apply Left to the start state in Figure 3.4, the resulting state has the 5 and the blank
switched.
• Goal test: This checks whether the state matches the goal configuration shown in Figure 3.4. (Other goal configurations are possible.)
• Path cost: Each step costs 1, so the path cost is the number of steps in the path.

SLIDING-BLOCK
PUZZLES

8-QUEENS PROBLEM

What abstractions have we included here? The actions are abstracted to their beginning and
final states, ignoring the intermediate locations where the block is sliding. We have abstracted
away actions such as shaking the board when pieces get stuck and ruled out extracting the
pieces with a knife and putting them back again. We are left with a description of the rules of
the puzzle, avoiding all the details of physical manipulations.
The 8-puzzle belongs to the family of sliding-block puzzles, which are often used as
test problems for new search algorithms in AI. This family is known to be NP-complete,
so one does not expect to find methods significantly better in the worst case than the search
algorithms described in this chapter and the next. The 8-puzzle has 9!/2 = 181, 440 reachable
states and is easily solved. The 15-puzzle (on a 4 × 4 board) has around 1.3 trillion states, and
random instances can be solved optimally in a few milliseconds by the best search algorithms.
The 24-puzzle (on a 5 × 5 board) has around 1025 states, and random instances take several
hours to solve optimally.
The goal of the 8-queens problem is to place eight queens on a chessboard such that
no queen attacks any other. (A queen attacks any piece in the same row, column or diagonal.) Figure 3.5 shows an attempted solution that fails: the queen in the rightmost column is
attacked by the queen at the top left.

72

Chapter

Figure 3.5

INCREMENTAL
FORMULATION
COMPLETE-STATE
FORMULATION

3.

Solving Problems by Searching

Almost a solution to the 8-queens problem. (Solution is left as an exercise.)

Although efficient special-purpose algorithms exist for this problem and for the whole
n-queens family, it remains a useful test problem for search algorithms. There are two main
kinds of formulation. An incremental formulation involves operators that augment the state
description, starting with an empty state; for the 8-queens problem, this means that each
action adds a queen to the state. A complete-state formulation starts with all 8 queens on
the board and moves them around. In either case, the path cost is of no interest because only
the final state counts. The first incremental formulation one might try is the following:
• States: Any arrangement of 0 to 8 queens on the board is a state.
• Initial state: No queens on the board.
• Actions: Add a queen to any empty square.
• Transition model: Returns the board with a queen added to the specified square.
• Goal test: 8 queens are on the board, none attacked.
In this formulation, we have 64 · 63 · · · 57 ≈ 1.8 × 1014 possible sequences to investigate. A
better formulation would prohibit placing a queen in any square that is already attacked:
• States: All possible arrangements of n queens (0 ≤ n ≤ 8), one per column in the
leftmost n columns, with no queen attacking another.
• Actions: Add a queen to any square in the leftmost empty column such that it is not
attacked by any other queen.
This formulation reduces the 8-queens state space from 1.8 × 1014 to just 2,057, and solutions
are easy to find. On the other hand, for 100 queens the reduction is from roughly 10400 states
to about 1052 states (Exercise 3.5)—a big improvement, but not enough to make the problem
tractable. Section 4.1 describes the complete-state formulation, and Chapter 6 gives a simple
algorithm that solves even the million-queens problem with ease.

Section 3.2.

Example Problems

73

Our final toy problem was devised by Donald Knuth (1964) and illustrates how infinite
state spaces can arise. Knuth conjectured that, starting with the number 4, a sequence of factorial, square root, and floor operations will reach any desired positive integer. For example,
we can reach 5 from 4 as follows:
 
 


(4!)! = 5 .
The problem definition is very simple:
• States: Positive numbers.
• Initial state: 4.
• Actions: Apply factorial, square root, or floor operation (factorial for integers only).
• Transition model: As given by the mathematical definitions of the operations.
• Goal test: State is the desired positive integer.
To our knowledge there is no bound on how large a number might be constructed in the process of reaching a given target—for example, the number 620,448,401,733,239,439,360,000
is generated in the expression for 5—so the state space for this problem is infinite. Such
state spaces arise frequently in tasks involving the generation of mathematical expressions,
circuits, proofs, programs, and other recursively defined objects.

3.2.2 Real-world problems
ROUTE-FINDING
PROBLEM

We have already seen how the route-finding problem is defined in terms of specified locations and transitions along links between them. Route-finding algorithms are used in a variety
of applications. Some, such as Web sites and in-car systems that provide driving directions,
are relatively straightforward extensions of the Romania example. Others, such as routing
video streams in computer networks, military operations planning, and airline travel-planning
systems, involve much more complex specifications. Consider the airline travel problems that
must be solved by a travel-planning Web site:
• States: Each state obviously includes a location (e.g., an airport) and the current time.
Furthermore, because the cost of an action (a flight segment) may depend on previous
segments, their fare bases, and their status as domestic or international, the state must
record extra information about these “historical” aspects.
• Initial state: This is specified by the user’s query.
• Actions: Take any flight from the current location, in any seat class, leaving after the
current time, leaving enough time for within-airport transfer if needed.
• Transition model: The state resulting from taking a flight will have the flight’s destination as the current location and the flight’s arrival time as the current time.
• Goal test: Are we at the final destination specified by the user?
• Path cost: This depends on monetary cost, waiting time, flight time, customs and immigration procedures, seat quality, time of day, type of airplane, frequent-flyer mileage
awards, and so on.

74

TOURING PROBLEM

TRAVELING
SALESPERSON
PROBLEM

VLSI LAYOUT

ROBOT NAVIGATION

AUTOMATIC
ASSEMBLY
SEQUENCING

Chapter

3.

Solving Problems by Searching

Commercial travel advice systems use a problem formulation of this kind, with many additional complications to handle the byzantine fare structures that airlines impose. Any seasoned traveler knows, however, that not all air travel goes according to plan. A really good
system should include contingency plans—such as backup reservations on alternate flights—
to the extent that these are justified by the cost and likelihood of failure of the original plan.
Touring problems are closely related to route-finding problems, but with an important difference. Consider, for example, the problem “Visit every city in Figure 3.2 at least
once, starting and ending in Bucharest.” As with route finding, the actions correspond
to trips between adjacent cities. The state space, however, is quite different. Each state
must include not just the current location but also the set of cities the agent has visited.
So the initial state would be In(Bucharest ), Visited ({Bucharest }), a typical intermediate state would be In(Vaslui ), Visited ({Bucharest , Urziceni , Vaslui }), and the goal test
would check whether the agent is in Bucharest and all 20 cities have been visited.
The traveling salesperson problem (TSP) is a touring problem in which each city
must be visited exactly once. The aim is to find the shortest tour. The problem is known to
be NP-hard, but an enormous amount of effort has been expended to improve the capabilities
of TSP algorithms. In addition to planning trips for traveling salespersons, these algorithms
have been used for tasks such as planning movements of automatic circuit-board drills and of
stocking machines on shop floors.
A VLSI layout problem requires positioning millions of components and connections
on a chip to minimize area, minimize circuit delays, minimize stray capacitances, and maximize manufacturing yield. The layout problem comes after the logical design phase and is
usually split into two parts: cell layout and channel routing. In cell layout, the primitive
components of the circuit are grouped into cells, each of which performs some recognized
function. Each cell has a fixed footprint (size and shape) and requires a certain number of
connections to each of the other cells. The aim is to place the cells on the chip so that they do
not overlap and so that there is room for the connecting wires to be placed between the cells.
Channel routing finds a specific route for each wire through the gaps between the cells. These
search problems are extremely complex, but definitely worth solving. Later in this chapter,
we present some algorithms capable of solving them.
Robot navigation is a generalization of the route-finding problem described earlier.
Rather than following a discrete set of routes, a robot can move in a continuous space with
(in principle) an infinite set of possible actions and states. For a circular robot moving on a
flat surface, the space is essentially two-dimensional. When the robot has arms and legs or
wheels that must also be controlled, the search space becomes many-dimensional. Advanced
techniques are required just to make the search space finite. We examine some of these
methods in Chapter 25. In addition to the complexity of the problem, real robots must also
deal with errors in their sensor readings and motor controls.
Automatic assembly sequencing of complex objects by a robot was first demonstrated
by F REDDY (Michie, 1972). Progress since then has been slow but sure, to the point where
the assembly of intricate objects such as electric motors is economically feasible. In assembly
problems, the aim is to find an order in which to assemble the parts of some object. If the
wrong order is chosen, there will be no way to add some part later in the sequence without

Section 3.3.

PROTEIN DESIGN

3.3

75

undoing some of the work already done. Checking a step in the sequence for feasibility is a
difficult geometrical search problem closely related to robot navigation. Thus, the generation
of legal actions is the expensive part of assembly sequencing. Any practical algorithm must
avoid exploring all but a tiny fraction of the state space. Another important assembly problem
is protein design, in which the goal is to find a sequence of amino acids that will fold into a
three-dimensional protein with the right properties to cure some disease.

S EARCHING FOR S OLUTIONS

SEARCH TREE
NODE

EXPANDING
GENERATING
PARENT NODE
CHILD NODE

LEAF NODE

FRONTIER
OPEN LIST

SEARCH STRATEGY

REPEATED STATE
LOOPY PATH

Searching for Solutions

Having formulated some problems, we now need to solve them. A solution is an action
sequence, so search algorithms work by considering various possible action sequences. The
possible action sequences starting at the initial state form a search tree with the initial state
at the root; the branches are actions and the nodes correspond to states in the state space of
the problem. Figure 3.6 shows the first few steps in growing the search tree for finding a route
from Arad to Bucharest. The root node of the tree corresponds to the initial state, In(Arad).
The first step is to test whether this is a goal state. (Clearly it is not, but it is important to
check so that we can solve trick problems like “starting in Arad, get to Arad.”) Then we
need to consider taking various actions. We do this by expanding the current state; that is,
applying each legal action to the current state, thereby generating a new set of states. In
this case, we add three branches from the parent node In(Arad) leading to three new child
nodes: In(Sibiu), In(Timisoara), and In(Zerind). Now we must choose which of these three
possibilities to consider further.
This is the essence of search—following up one option now and putting the others aside
for later, in case the first choice does not lead to a solution. Suppose we choose Sibiu first.
We check to see whether it is a goal state (it is not) and then expand it to get In(Arad),
In(Fagaras), In(Oradea), and In(RimnicuVilcea). We can then choose any of these four or go
back and choose Timisoara or Zerind. Each of these six nodes is a leaf node, that is, a node
with no children in the tree. The set of all leaf nodes available for expansion at any given
point is called the frontier. (Many authors call it the open list, which is both geographically
less evocative and less accurate, because other data structures are better suited than a list.) In
Figure 3.6, the frontier of each tree consists of those nodes with bold outlines.
The process of expanding nodes on the frontier continues until either a solution is found
or there are no more states to expand. The general T REE -S EARCH algorithm is shown informally in Figure 3.7. Search algorithms all share this basic structure; they vary primarily
according to how they choose which state to expand next—the so-called search strategy.
The eagle-eyed reader will notice one peculiar thing about the search tree shown in Figure 3.6: it includes the path from Arad to Sibiu and back to Arad again! We say that In(Arad)
is a repeated state in the search tree, generated in this case by a loopy path. Considering
such loopy paths means that the complete search tree for Romania is infinite because there
is no limit to how often one can traverse a loop. On the other hand, the state space—the
map shown in Figure 3.2—has only 20 states. As we discuss in Section 3.4, loops can cause

76

REDUNDANT PATH

Chapter

3.

Solving Problems by Searching

certain algorithms to fail, making otherwise solvable problems unsolvable. Fortunately, there
is no need to consider loopy paths. We can rely on more than intuition for this: because path
costs are additive and step costs are nonnegative, a loopy path to any given state is never
better than the same path with the loop removed.
Loopy paths are a special case of the more general concept of redundant paths, which
exist whenever there is more than one way to get from one state to another. Consider the paths
Arad–Sibiu (140 km long) and Arad–Zerind–Oradea–Sibiu (297 km long). Obviously, the
second path is redundant—it’s just a worse way to get to the same state. If you are concerned
about reaching the goal, there’s never any reason to keep more than one path to any given
state, because any goal state that is reachable by extending one path is also reachable by
extending the other.
In some cases, it is possible to define the problem itself so as to eliminate redundant
paths. For example, if we formulate the 8-queens problem (page 71) so that a queen can be
placed in any column, then each state with n queens can be reached by n! different paths; but
if we reformulate the problem so that each new queen is placed in the leftmost empty column,
then each state can be reached only through one path.
Arad

(a) The initial state

Timisoara

Sibiu

Arad

Fagaras

Oradea

Rimnicu Vilcea

(b) After expanding Arad

Arad

Fagaras

Oradea

Rimnicu Vilcea

Arad

Zerind

Lugoj

Arad

Timisoara

Oradea

Oradea

Oradea

Arad

Sibiu

Fagaras

Arad

Timisoara

(c) After expanding Sibiu

Arad

Lugoj

Arad

Sibiu

Arad

Zerind

Rimnicu Vilcea

Arad

Zerind

Lugoj

Arad

Oradea

Figure 3.6 Partial search trees for finding a route from Arad to Bucharest. Nodes that
have been expanded are shaded; nodes that have been generated but not yet expanded are
outlined in bold; nodes that have not yet been generated are shown in faint dashed lines.

Section 3.3.

Searching for Solutions

77

function T REE -S EARCH( problem) returns a solution, or failure
initialize the frontier using the initial state of problem
loop do
if the frontier is empty then return failure
choose a leaf node and remove it from the frontier
if the node contains a goal state then return the corresponding solution
expand the chosen node, adding the resulting nodes to the frontier
function G RAPH -S EARCH ( problem) returns a solution, or failure
initialize the frontier using the initial state of problem
initialize the explored set to be empty
loop do
if the frontier is empty then return failure
choose a leaf node and remove it from the frontier
if the node contains a goal state then return the corresponding solution
add the node to the explored set
expand the chosen node, adding the resulting nodes to the frontier
only if not in the frontier or explored set
Figure 3.7 An informal description of the general tree-search and graph-search algorithms. The parts of G RAPH -S EARCH marked in bold italic are the additions needed to
handle repeated states.

RECTANGULAR GRID

EXPLORED SET
CLOSED LIST

SEPARATOR

In other cases, redundant paths are unavoidable. This includes all problems where
the actions are reversible, such as route-finding problems and sliding-block puzzles. Routefinding on a rectangular grid (like the one used later for Figure 3.9) is a particularly important example in computer games. In such a grid, each state has four successors, so a search
tree of depth d that includes repeated states has 4d leaves; but there are only about 2d2 distinct
states within d steps of any given state. For d = 20, this means about a trillion nodes but only
about 800 distinct states. Thus, following redundant paths can cause a tractable problem to
become intractable. This is true even for algorithms that know how to avoid infinite loops.
As the saying goes, algorithms that forget their history are doomed to repeat it. The
way to avoid exploring redundant paths is to remember where one has been. To do this, we
augment the T REE -S EARCH algorithm with a data structure called the explored set (also
known as the closed list), which remembers every expanded node. Newly generated nodes
that match previously generated nodes—ones in the explored set or the frontier—can be discarded instead of being added to the frontier. The new algorithm, called G RAPH -S EARCH , is
shown informally in Figure 3.7. The specific algorithms in this chapter draw on this general
design.
Clearly, the search tree constructed by the G RAPH -S EARCH algorithm contains at most
one copy of each state, so we can think of it as growing a tree directly on the state-space graph,
as shown in Figure 3.8. The algorithm has another nice property: the frontier separates the
state-space graph into the explored region and the unexplored region, so that every path from

78

Chapter

3.

Solving Problems by Searching

Figure 3.8 A sequence of search trees generated by a graph search on the Romania problem of Figure 3.2. At each stage, we have extended each path by one step. Notice that at the
third stage, the northernmost city (Oradea) has become a dead end: both of its successors are
already explored via other paths.

(a)

(b)

(c)

Figure 3.9 The separation property of G RAPH -S EARCH , illustrated on a rectangular-grid
problem. The frontier (white nodes) always separates the explored region of the state space
(black nodes) from the unexplored region (gray nodes). In (a), just the root has been expanded. In (b), one leaf node has been expanded. In (c), the remaining successors of the root
have been expanded in clockwise order.

the initial state to an unexplored state has to pass through a state in the frontier. (If this
seems completely obvious, try Exercise 3.13 now.) This property is illustrated in Figure 3.9.
As every step moves a state from the frontier into the explored region while moving some
states from the unexplored region into the frontier, we see that the algorithm is systematically
examining the states in the state space, one by one, until it finds a solution.

3.3.1 Infrastructure for search algorithms
Search algorithms require a data structure to keep track of the search tree that is being constructed. For each node n of the tree, we have a structure that contains four components:
• n.S TATE : the state in the state space to which the node corresponds;
• n.PARENT: the node in the search tree that generated this node;
• n.ACTION: the action that was applied to the parent to generate the node;
• n.PATH -C OST : the cost, traditionally denoted by g(n), of the path from the initial state
to the node, as indicated by the parent pointers.

Section 3.3.

Searching for Solutions

79

PARENT

Node

5

4

6

1

88

7

3

22

ACTION = Right
PATH-COST = 6

STATE

Figure 3.10 Nodes are the data structures from which the search tree is constructed. Each
has a parent, a state, and various bookkeeping fields. Arrows point from child to parent.

Given the components for a parent node, it is easy to see how to compute the necessary
components for a child node. The function C HILD -N ODE takes a parent node and an action
and returns the resulting child node:

function C HILD -N ODE( problem, parent , action) returns a node
return a node with
S TATE = problem.R ESULT(parent.S TATE, action ),
PARENT = parent , ACTION = action,
PATH -C OST = parent .PATH -C OST + problem.S TEP -C OST(parent.S TATE, action )

QUEUE

The node data structure is depicted in Figure 3.10. Notice how the PARENT pointers
string the nodes together into a tree structure. These pointers also allow the solution path to be
extracted when a goal node is found; we use the S OLUTION function to return the sequence
of actions obtained by following parent pointers back to the root.
Up to now, we have not been very careful to distinguish between nodes and states, but in
writing detailed algorithms it’s important to make that distinction. A node is a bookkeeping
data structure used to represent the search tree. A state corresponds to a configuration of the
world. Thus, nodes are on particular paths, as defined by PARENT pointers, whereas states
are not. Furthermore, two different nodes can contain the same world state if that state is
generated via two different search paths.
Now that we have nodes, we need somewhere to put them. The frontier needs to be
stored in such a way that the search algorithm can easily choose the next node to expand
according to its preferred strategy. The appropriate data structure for this is a queue. The
operations on a queue are as follows:
• E MPTY ?(queue) returns true only if there are no more elements in the queue.
• P OP(queue) removes the first element of the queue and returns it.
• I NSERT (element, queue) inserts an element and returns the resulting queue.

80

FIFO QUEUE
LIFO QUEUE
PRIORITY QUEUE

CANONICAL FORM

Chapter

3.

Solving Problems by Searching

Queues are characterized by the order in which they store the inserted nodes. Three common
variants are the first-in, first-out or FIFO queue, which pops the oldest element of the queue;
the last-in, first-out or LIFO queue (also known as a stack), which pops the newest element
of the queue; and the priority queue, which pops the element of the queue with the highest
priority according to some ordering function.
The explored set can be implemented with a hash table to allow efficient checking for
repeated states. With a good implementation, insertion and lookup can be done in roughly
constant time no matter how many states are stored. One must take care to implement the
hash table with the right notion of equality between states. For example, in the traveling
salesperson problem (page 74), the hash table needs to know that the set of visited cities
{Bucharest,Urziceni,Vaslui} is the same as {Urziceni,Vaslui,Bucharest}. Sometimes this can
be achieved most easily by insisting that the data structures for states be in some canonical
form; that is, logically equivalent states should map to the same data structure. In the case
of states described by sets, for example, a bit-vector representation or a sorted list without
repetition would be canonical, whereas an unsorted list would not.

3.3.2 Measuring problem-solving performance
Before we get into the design of specific search algorithms, we need to consider the criteria
that might be used to choose among them. We can evaluate an algorithm’s performance in
four ways:
COMPLETENESS
OPTIMALITY
TIME COMPLEXITY
SPACE COMPLEXITY

BRANCHING FACTOR
DEPTH

SEARCH COST

TOTAL COST

• Completeness: Is the algorithm guaranteed to find a solution when there is one?
• Optimality: Does the strategy find the optimal solution, as defined on page 68?
• Time complexity: How long does it take to find a solution?
• Space complexity: How much memory is needed to perform the search?
Time and space complexity are always considered with respect to some measure of the problem difficulty. In theoretical computer science, the typical measure is the size of the state
space graph, |V | + |E|, where V is the set of vertices (nodes) of the graph and E is the set
of edges (links). This is appropriate when the graph is an explicit data structure that is input
to the search program. (The map of Romania is an example of this.) In AI, the graph is often
represented implicitly by the initial state, actions, and transition model and is frequently infinite. For these reasons, complexity is expressed in terms of three quantities: b, the branching
factor or maximum number of successors of any node; d, the depth of the shallowest goal
node (i.e., the number of steps along the path from the root); and m, the maximum length of
any path in the state space. Time is often measured in terms of the number of nodes generated
during the search, and space in terms of the maximum number of nodes stored in memory.
For the most part, we describe time and space complexity for search on a tree; for a graph,
the answer depends on how “redundant” the paths in the state space are.
To assess the effectiveness of a search algorithm, we can consider just the search cost—
which typically depends on the time complexity but can also include a term for memory
usage—or we can use the total cost, which combines the search cost and the path cost of the
solution found. For the problem of finding a route from Arad to Bucharest, the search cost
is the amount of time taken by the search and the solution cost is the total length of the path

Section 3.4.

Uninformed Search Strategies

81

in kilometers. Thus, to compute the total cost, we have to add milliseconds and kilometers.
There is no “official exchange rate” between the two, but it might be reasonable in this case to
convert kilometers into milliseconds by using an estimate of the car’s average speed (because
time is what the agent cares about). This enables the agent to find an optimal tradeoff point
at which further computation to find a shorter path becomes counterproductive. The more
general problem of tradeoffs between different goods is taken up in Chapter 16.

3.4

U NINFORMED S EARCH S TRATEGIES

UNINFORMED
SEARCH
BLIND SEARCH

INFORMED SEARCH
HEURISTIC SEARCH

This section covers several search strategies that come under the heading of uninformed
search (also called blind search). The term means that the strategies have no additional
information about states beyond that provided in the problem definition. All they can do is
generate successors and distinguish a goal state from a non-goal state. All search strategies
are distinguished by the order in which nodes are expanded. Strategies that know whether
one non-goal state is “more promising” than another are called informed search or heuristic
search strategies; they are covered in Section 3.5.

3.4.1 Breadth-first search
BREADTH-FIRST
SEARCH

Breadth-first search is a simple strategy in which the root node is expanded first, then all the
successors of the root node are expanded next, then their successors, and so on. In general,
all the nodes are expanded at a given depth in the search tree before any nodes at the next
level are expanded.
Breadth-first search is an instance of the general graph-search algorithm (Figure 3.7) in
which the shallowest unexpanded node is chosen for expansion. This is achieved very simply
by using a FIFO queue for the frontier. Thus, new nodes (which are always deeper than their
parents) go to the back of the queue, and old nodes, which are shallower than the new nodes,
get expanded first. There is one slight tweak on the general graph-search algorithm, which is
that the goal test is applied to each node when it is generated rather than when it is selected for
expansion. This decision is explained below, where we discuss time complexity. Note also
that the algorithm, following the general template for graph search, discards any new path to
a state already in the frontier or explored set; it is easy to see that any such path must be at
least as deep as the one already found. Thus, breadth-first search always has the shallowest
path to every node on the frontier.
Pseudocode is given in Figure 3.11. Figure 3.12 shows the progress of the search on a
simple binary tree.
How does breadth-first search rate according to the four criteria from the previous section? We can easily see that it is complete—if the shallowest goal node is at some finite depth
d, breadth-first search will eventually find it after generating all shallower nodes (provided
the branching factor b is finite). Note that as soon as a goal node is generated, we know it
is the shallowest goal node because all shallower nodes must have been generated already
and failed the goal test. Now, the shallowest goal node is not necessarily the optimal one;

82

Chapter

3.

Solving Problems by Searching

function B READTH -F IRST-S EARCH ( problem) returns a solution, or failure
node ← a node with S TATE = problem.I NITIAL -S TATE, PATH -C OST = 0
if problem.G OAL -T EST(node.S TATE) then return S OLUTION(node)
frontier ← a FIFO queue with node as the only element
explored ← an empty set
loop do
if E MPTY ?( frontier ) then return failure
node ← P OP( frontier ) /* chooses the shallowest node in frontier */
add node.S TATE to explored
for each action in problem.ACTIONS(node.S TATE) do
child ← C HILD -N ODE( problem, node, action)
if child .S TATE is not in explored or frontier then
if problem.G OAL -T EST(child .S TATE) then return S OLUTION(child )
frontier ← I NSERT(child , frontier )
Figure 3.11

Breadth-first search on a graph.

technically, breadth-first search is optimal if the path cost is a nondecreasing function of the
depth of the node. The most common such scenario is that all actions have the same cost.
So far, the news about breadth-first search has been good. The news about time and
space is not so good. Imagine searching a uniform tree where every state has b successors.
The root of the search tree generates b nodes at the first level, each of which generates b more
nodes, for a total of b2 at the second level. Each of these generates b more nodes, yielding b3
nodes at the third level, and so on. Now suppose that the solution is at depth d. In the worst
case, it is the last node generated at that level. Then the total number of nodes generated is
b + b2 + b3 + · · · + bd = O(bd ) .
(If the algorithm were to apply the goal test to nodes when selected for expansion, rather than
when generated, the whole layer of nodes at depth d would be expanded before the goal was
detected and the time complexity would be O(bd+1 ).)
As for space complexity: for any kind of graph search, which stores every expanded
node in the explored set, the space complexity is always within a factor of b of the time
complexity. For breadth-first graph search in particular, every node generated remains in
memory. There will be O(bd−1 ) nodes in the explored set and O(bd ) nodes in the frontier,
A

A

B
D

C
E

F

A

B
G

D

C
E

F

A

B
G

D

C
E

F

B
G

D

C
E

F

Figure 3.12 Breadth-first search on a simple binary tree. At each stage, the node to be
expanded next is indicated by a marker.

G

Section 3.4.

Uninformed Search Strategies

83

so the space complexity is O(bd ), i.e., it is dominated by the size of the frontier. Switching
to a tree search would not save much space, and in a state space with many redundant paths,
switching could cost a great deal of time.
An exponential complexity bound such as O(bd ) is scary. Figure 3.13 shows why. It
lists, for various values of the solution depth d, the time and memory required for a breadthfirst search with branching factor b = 10. The table assumes that 1 million nodes can be
generated per second and that a node requires 1000 bytes of storage. Many search problems
fit roughly within these assumptions (give or take a factor of 100) when run on a modern
personal computer.
Depth

Nodes

Time

Memory

2
4
6
8
10
12
14
16

110
11,110
106
108
1010
1012
1014
1016

.11 milliseconds
11 milliseconds
1.1 seconds
2 minutes
3 hours
13 days
3.5 years
350 years

107 kilobytes
10.6 megabytes
1 gigabyte
103 gigabytes
10 terabytes
1 petabyte
99 petabytes
10 exabytes

Figure 3.13 Time and memory requirements for breadth-first search. The numbers shown
assume branching factor b = 10; 1 million nodes/second; 1000 bytes/node.

Two lessons can be learned from Figure 3.13. First, the memory requirements are a
bigger problem for breadth-first search than is the execution time. One might wait 13 days
for the solution to an important problem with search depth 12, but no personal computer has
the petabyte of memory it would take. Fortunately, other strategies require less memory.
The second lesson is that time is still a major factor. If your problem has a solution at
depth 16, then (given our assumptions) it will take about 350 years for breadth-first search (or
indeed any uninformed search) to find it. In general, exponential-complexity search problems
cannot be solved by uninformed methods for any but the smallest instances.

3.4.2 Uniform-cost search

UNIFORM-COST
SEARCH

When all step costs are equal, breadth-first search is optimal because it always expands the
shallowest unexpanded node. By a simple extension, we can find an algorithm that is optimal
with any step-cost function. Instead of expanding the shallowest node, uniform-cost search
expands the node n with the lowest path cost g(n). This is done by storing the frontier as a
priority queue ordered by g. The algorithm is shown in Figure 3.14.
In addition to the ordering of the queue by path cost, there are two other significant
differences from breadth-first search. The first is that the goal test is applied to a node when
it is selected for expansion (as in the generic graph-search algorithm shown in Figure 3.7)
rather than when it is first generated. The reason is that the first goal node that is generated

84

Chapter

3.

Solving Problems by Searching

function U NIFORM -C OST-S EARCH ( problem) returns a solution, or failure
node ← a node with S TATE = problem.I NITIAL -S TATE, PATH -C OST = 0
frontier ← a priority queue ordered by PATH -C OST, with node as the only element
explored ← an empty set
loop do
if E MPTY ?( frontier ) then return failure
node ← P OP( frontier ) /* chooses the lowest-cost node in frontier */
if problem.G OAL -T EST(node.S TATE) then return S OLUTION (node)
add node.S TATE to explored
for each action in problem.ACTIONS(node.S TATE) do
child ← C HILD -N ODE( problem, node, action)
if child .S TATE is not in explored or frontier then
frontier ← I NSERT(child , frontier )
else if child .S TATE is in frontier with higher PATH -C OST then
replace that frontier node with child
Figure 3.14 Uniform-cost search on a graph. The algorithm is identical to the general
graph search algorithm in Figure 3.7, except for the use of a priority queue and the addition
of an extra check in case a shorter path to a frontier state is discovered. The data structure for
frontier needs to support efficient membership testing, so it should combine the capabilities
of a priority queue and a hash table.

Sibiu

99

Fagaras

80
Rimnicu Vilcea

97

211

Pitesti

101
Bucharest

Figure 3.15

Part of the Romania state space, selected to illustrate uniform-cost search.

may be on a suboptimal path. The second difference is that a test is added in case a better
path is found to a node currently on the frontier.
Both of these modifications come into play in the example shown in Figure 3.15, where
the problem is to get from Sibiu to Bucharest. The successors of Sibiu are Rimnicu Vilcea and
Fagaras, with costs 80 and 99, respectively. The least-cost node, Rimnicu Vilcea, is expanded
next, adding Pitesti with cost 80 + 97 = 177. The least-cost node is now Fagaras, so it is
expanded, adding Bucharest with cost 99 + 211 = 310. Now a goal node has been generated,
but uniform-cost search keeps going, choosing Pitesti for expansion and adding a second path

Section 3.4.

Uninformed Search Strategies

85

to Bucharest with cost 80 + 97 + 101 = 278. Now the algorithm checks to see if this new path
is better than the old one; it is, so the old one is discarded. Bucharest, now with g-cost 278,
is selected for expansion and the solution is returned.
It is easy to see that uniform-cost search is optimal in general. First, we observe that
whenever uniform-cost search selects a node n for expansion, the optimal path to that node
has been found. (Were this not the case, there would have to be another frontier node n on
the optimal path from the start node to n, by the graph separation property of Figure 3.9;
by definition, n would have lower g-cost than n and would have been selected first.) Then,
because step costs are nonnegative, paths never get shorter as nodes are added. These two
facts together imply that uniform-cost search expands nodes in order of their optimal path
cost. Hence, the first goal node selected for expansion must be the optimal solution.
Uniform-cost search does not care about the number of steps a path has, but only about
their total cost. Therefore, it will get stuck in an infinite loop if there is a path with an infinite
sequence of zero-cost actions—for example, a sequence of NoOp actions.6 Completeness is
guaranteed provided the cost of every step exceeds some small positive constant .
Uniform-cost search is guided by path costs rather than depths, so its complexity is not
easily characterized in terms of b and d. Instead, let C ∗ be the cost of the optimal solution,7
and assume that every action costs at least . Then the algorithm’s worst-case time and space
∗
complexity is O(b1+C / ), which can be much greater than bd . This is because uniformcost search can explore large trees of small steps before exploring paths involving large and
∗
perhaps useful steps. When all step costs are equal, b1+C / is just bd+1 . When all step
costs are the same, uniform-cost search is similar to breadth-first search, except that the latter
stops as soon as it generates a goal, whereas uniform-cost search examines all the nodes at
the goal’s depth to see if one has a lower cost; thus uniform-cost search does strictly more
work by expanding nodes at depth d unnecessarily.

3.4.3 Depth-first search
DEPTH-FIRST
SEARCH

Depth-first search always expands the deepest node in the current frontier of the search tree.
The progress of the search is illustrated in Figure 3.16. The search proceeds immediately
to the deepest level of the search tree, where the nodes have no successors. As those nodes
are expanded, they are dropped from the frontier, so then the search “backs up” to the next
deepest node that still has unexplored successors.
The depth-first search algorithm is an instance of the graph-search algorithm in Figure 3.7; whereas breadth-first-search uses a FIFO queue, depth-first search uses a LIFO queue.
A LIFO queue means that the most recently generated node is chosen for expansion. This
must be the deepest unexpanded node because it is one deeper than its parent—which, in turn,
was the deepest unexpanded node when it was selected.
As an alternative to the G RAPH -S EARCH -style implementation, it is common to implement depth-first search with a recursive function that calls itself on each of its children in
turn. (A recursive depth-first algorithm incorporating a depth limit is shown in Figure 3.17.)
6
7

NoOp, or “no operation,” is the name of an assembly language instruction that does nothing.
Here, and throughout the book, the “star” in C ∗ means an optimal value for C.

86

Chapter
A

H

C
E

I

J

L

G
N

M

C

D
O

H

E
I

J

K

C
E

I

J

L

G
N

M

D
O

O

H

E
I

J

F
K

J

O

C

F
K

N

M

A

E
I

L

G

L

G
N

M

E
O

J

F
K

L

G
N

M

O

A
C

E

B

F
K

D

C

A

J

N

M

B

F
K

L

G

C

A

B

H

B

F

A

D

A

B

F
K

Solving Problems by Searching

A

B
D

3.

L

G
N

M

C
E

O

A

C

F
K

L

G
N

M

F
O

A
C

F

G
M

N

O

C

F
O

N

M

A

C

L

L

G

L

G
M

N

F
O

G
M

N

O

Figure 3.16 Depth-first search on a binary tree. The unexplored region is shown in light
gray. Explored nodes with no descendants in the frontier are removed from memory. Nodes
at depth 3 have no successors and M is the only goal node.

The properties of depth-first search depend strongly on whether the graph-search or
tree-search version is used. The graph-search version, which avoids repeated states and redundant paths, is complete in finite state spaces because it will eventually expand every node.
The tree-search version, on the other hand, is not complete—for example, in Figure 3.6 the
algorithm will follow the Arad–Sibiu–Arad–Sibiu loop forever. Depth-first tree search can be
modified at no extra memory cost so that it checks new states against those on the path from
the root to the current node; this avoids infinite loops in finite state spaces but does not avoid
the proliferation of redundant paths. In infinite state spaces, both versions fail if an infinite
non-goal path is encountered. For example, in Knuth’s 4 problem, depth-first search would
keep applying the factorial operator forever.
For similar reasons, both versions are nonoptimal. For example, in Figure 3.16, depthfirst search will explore the entire left subtree even if node C is a goal node. If node J were
also a goal node, then depth-first search would return it as a solution instead of C, which
would be a better solution; hence, depth-first search is not optimal.

Section 3.4.

BACKTRACKING
SEARCH

Uninformed Search Strategies

87

The time complexity of depth-first graph search is bounded by the size of the state space
(which may be infinite, of course). A depth-first tree search, on the other hand, may generate
all of the O(bm ) nodes in the search tree, where m is the maximum depth of any node; this
can be much greater than the size of the state space. Note that m itself can be much larger
than d (the depth of the shallowest solution) and is infinite if the tree is unbounded.
So far, depth-first search seems to have no clear advantage over breadth-first search,
so why do we include it? The reason is the space complexity. For a graph search, there is
no advantage, but a depth-first tree search needs to store only a single path from the root
to a leaf node, along with the remaining unexpanded sibling nodes for each node on the
path. Once a node has been expanded, it can be removed from memory as soon as all its
descendants have been fully explored. (See Figure 3.16.) For a state space with branching
factor b and maximum depth m, depth-first search requires storage of only O(bm) nodes.
Using the same assumptions as for Figure 3.13 and assuming that nodes at the same depth as
the goal node have no successors, we find that depth-first search would require 156 kilobytes
instead of 10 exabytes at depth d = 16, a factor of 7 trillion times less space. This has
led to the adoption of depth-first tree search as the basic workhorse of many areas of AI,
including constraint satisfaction (Chapter 6), propositional satisfiability (Chapter 7), and logic
programming (Chapter 9). For the remainder of this section, we focus primarily on the treesearch version of depth-first search.
A variant of depth-first search called backtracking search uses still less memory. (See
Chapter 6 for more details.) In backtracking, only one successor is generated at a time rather
than all successors; each partially expanded node remembers which successor to generate
next. In this way, only O(m) memory is needed rather than O(bm). Backtracking search
facilitates yet another memory-saving (and time-saving) trick: the idea of generating a successor by modifying the current state description directly rather than copying it first. This
reduces the memory requirements to just one state description and O(m) actions. For this to
work, we must be able to undo each modification when we go back to generate the next successor. For problems with large state descriptions, such as robotic assembly, these techniques
are critical to success.

3.4.4 Depth-limited search

DEPTH-LIMITED
SEARCH

The embarrassing failure of depth-first search in infinite state spaces can be alleviated by
supplying depth-first search with a predetermined depth limit . That is, nodes at depth  are
treated as if they have no successors. This approach is called depth-limited search. The
depth limit solves the infinite-path problem. Unfortunately, it also introduces an additional
source of incompleteness if we choose  < d, that is, the shallowest goal is beyond the depth
limit. (This is likely when d is unknown.) Depth-limited search will also be nonoptimal if
we choose  > d. Its time complexity is O(b ) and its space complexity is O(b). Depth-first
search can be viewed as a special case of depth-limited search with  = ∞.
Sometimes, depth limits can be based on knowledge of the problem. For example, on
the map of Romania there are 20 cities. Therefore, we know that if there is a solution, it must
be of length 19 at the longest, so  = 19 is a possible choice. But in fact if we studied the

88

Chapter

3.

Solving Problems by Searching

function D EPTH -L IMITED -S EARCH( problem, limit ) returns a solution, or failure/cutoff
return R ECURSIVE -DLS(M AKE -N ODE(problem.I NITIAL -S TATE), problem, limit )
function R ECURSIVE -DLS(node, problem, limit ) returns a solution, or failure/cutoff
if problem.G OAL -T EST(node.S TATE) then return S OLUTION(node)
else if limit = 0 then return cutoﬀ
else
cutoﬀ occurred ? ← false
for each action in problem.ACTIONS(node.S TATE) do
child ← C HILD -N ODE( problem, node, action)
result ← R ECURSIVE -DLS(child , problem, limit − 1)
if result = cutoﬀ then cutoﬀ occurred ? ← true
else if result  = failure then return result
if cutoﬀ occurred ? then return cutoﬀ else return failure
Figure 3.17

DIAMETER

A recursive implementation of depth-limited tree search.

map carefully, we would discover that any city can be reached from any other city in at most
9 steps. This number, known as the diameter of the state space, gives us a better depth limit,
which leads to a more efficient depth-limited search. For most problems, however, we will
not know a good depth limit until we have solved the problem.
Depth-limited search can be implemented as a simple modification to the general treeor graph-search algorithm. Alternatively, it can be implemented as a simple recursive algorithm as shown in Figure 3.17. Notice that depth-limited search can terminate with two
kinds of failure: the standard failure value indicates no solution; the cutoﬀ value indicates
no solution within the depth limit.

3.4.5 Iterative deepening depth-first search
ITERATIVE
DEEPENING SEARCH

Iterative deepening search (or iterative deepening depth-first search) is a general strategy,
often used in combination with depth-first tree search, that finds the best depth limit. It does
this by gradually increasing the limit—first 0, then 1, then 2, and so on—until a goal is found.
This will occur when the depth limit reaches d, the depth of the shallowest goal node. The
algorithm is shown in Figure 3.18. Iterative deepening combines the benefits of depth-first
and breadth-first search. Like depth-first search, its memory requirements are modest: O(bd)
to be precise. Like breadth-first search, it is complete when the branching factor is finite and
optimal when the path cost is a nondecreasing function of the depth of the node. Figure 3.19
shows four iterations of I TERATIVE -D EEPENING -S EARCH on a binary search tree, where the
solution is found on the fourth iteration.
Iterative deepening search may seem wasteful because states are generated multiple
times. It turns out this is not too costly. The reason is that in a search tree with the same (or
nearly the same) branching factor at each level, most of the nodes are in the bottom level,
so it does not matter much that the upper levels are generated multiple times. In an iterative
deepening search, the nodes on the bottom level (depth d) are generated once, those on the

Section 3.4.

Uninformed Search Strategies

89

function I TERATIVE -D EEPENING -S EARCH( problem) returns a solution, or failure
for depth = 0 to ∞ do
result ← D EPTH -L IMITED -S EARCH( problem, depth)
if result  = cutoff then return result
Figure 3.18 The iterative deepening search algorithm, which repeatedly applies depthlimited search with increasing limits. It terminates when a solution is found or if the depthlimited search returns failure, meaning that no solution exists.

Limit = 0

A

A

Limit = 1

A

A

B

C

B

C

A

Limit = 2

C
E

G

C

D

E

C
E

G

C
E

I

J

G
M

L

O

N

H

I

J

C

H

E
I

J

K

G
M

L

O

N

H

J

C
E

I

J

Figure 3.19

H

I

L

G
M

N

H

M

L

K

J

O

N

O

N

H

I

J

F
K

H

E
I

J

L

G
M

N

G

H

M

L

O

N

H

E
I

J

F
K

J

M

L

B

F
K

G
O

N

A

E
I

O

N

C

D

C

D
O

M

L

B

F
K

G

A

B

F
K

M

L

C
E

C

D

G

B
D

G

A

E
I

F

A

B
G

C

D
O

E

C

J

G

C

D

A

B

F
K

O

N

F
K

G

F

A

B
D

M

L

E
I

F

B

F

E

C

D

A

H

E

D

G

B

F

E

C

D

A

B

D

A

B

F
K

G

C

A

E

A

D

G

C

D

B

F

B

F

B

F
K

E

A

B

H

E

A

D

D

C

D

C

A

B

F

Limit = 3

G

C

A

B

B

A

B

F

A

D

C

A

B

F

A

B

A

B
D

A

L

G
M

N

C

D
O

H

E
I

Four iterations of iterative deepening search on a binary tree.

J

F
K

L

G
M

N

O

90

Chapter

3.

Solving Problems by Searching

next-to-bottom level are generated twice, and so on, up to the children of the root, which are
generated d times. So the total number of nodes generated in the worst case is
N (IDS) = (d)b + (d − 1)b2 + · · · + (1)bd ,
which gives a time complexity of O(bd )—asymptotically the same as breadth-first search.
There is some extra cost for generating the upper levels multiple times, but it is not large. For
example, if b = 10 and d = 5, the numbers are
N (IDS) = 50 + 400 + 3, 000 + 20, 000 + 100, 000 = 123, 450
N (BFS) = 10 + 100 + 1, 000 + 10, 000 + 100, 000 = 111, 110 .

ITERATIVE
LENGTHENING
SEARCH

If you are really concerned about repeating the repetition, you can use a hybrid approach
that runs breadth-first search until almost all the available memory is consumed, and then
runs iterative deepening from all the nodes in the frontier. In general, iterative deepening is
the preferred uninformed search method when the search space is large and the depth of the
solution is not known.
Iterative deepening search is analogous to breadth-first search in that it explores a complete layer of new nodes at each iteration before going on to the next layer. It would seem
worthwhile to develop an iterative analog to uniform-cost search, inheriting the latter algorithm’s optimality guarantees while avoiding its memory requirements. The idea is to use
increasing path-cost limits instead of increasing depth limits. The resulting algorithm, called
iterative lengthening search, is explored in Exercise 3.17. It turns out, unfortunately, that
iterative lengthening incurs substantial overhead compared to uniform-cost search.

3.4.6 Bidirectional search
The idea behind bidirectional search is to run two simultaneous searches—one forward from
the initial state and the other backward from the goal—hoping that the two searches meet in
the middle (Figure 3.20). The motivation is that bd/2 + bd/2 is much less than bd , or in the
figure, the area of the two small circles is less than the area of one big circle centered on the
start and reaching to the goal.
Bidirectional search is implemented by replacing the goal test with a check to see
whether the frontiers of the two searches intersect; if they do, a solution has been found.
(It is important to realize that the first such solution found may not be optimal, even if the
two searches are both breadth-first; some additional search is required to make sure there
isn’t another short-cut across the gap.) The check can be done when each node is generated
or selected for expansion and, with a hash table, will take constant time. For example, if a
problem has solution depth d = 6, and each direction runs breadth-first search one node at a
time, then in the worst case the two searches meet when they have generated all of the nodes
at depth 3. For b = 10, this means a total of 2,220 node generations, compared with 1,111,110
for a standard breadth-first search. Thus, the time complexity of bidirectional search using
breadth-first searches in both directions is O(bd/2 ). The space complexity is also O(bd/2 ).
We can reduce this by roughly half if one of the two searches is done by iterative deepening,
but at least one of the frontiers must be kept in memory so that the intersection check can be
done. This space requirement is the most significant weakness of bidirectional search.

Section 3.4.

Uninformed Search Strategies

91

Goal

Start

Figure 3.20 A schematic view of a bidirectional search that is about to succeed when a
branch from the start node meets a branch from the goal node.

PREDECESSOR

The reduction in time complexity makes bidirectional search attractive, but how do we
search backward? This is not as easy as it sounds. Let the predecessors of a state x be all
those states that have x as a successor. Bidirectional search requires a method for computing
predecessors. When all the actions in the state space are reversible, the predecessors of x are
just its successors. Other cases may require substantial ingenuity.
Consider the question of what we mean by “the goal” in searching “backward from the
goal.” For the 8-puzzle and for finding a route in Romania, there is just one goal state, so the
backward search is very much like the forward search. If there are several explicitly listed
goal states—for example, the two dirt-free goal states in Figure 3.3—then we can construct a
new dummy goal state whose immediate predecessors are all the actual goal states. But if the
goal is an abstract description, such as the goal that “no queen attacks another queen” in the
n-queens problem, then bidirectional search is difficult to use.

3.4.7 Comparing uninformed search strategies
Figure 3.21 compares search strategies in terms of the four evaluation criteria set forth in
Section 3.3.2. This comparison is for tree-search versions. For graph searches, the main
differences are that depth-first search is complete for finite state spaces and that the space and
time complexities are bounded by the size of the state space.
Criterion

BreadthFirst

UniformCost

DepthFirst

DepthLimited

Iterative
Deepening

Bidirectional
(if applicable)

Complete?
Time
Space
Optimal?

Yesa
O(bd )
O(bd )
Yesc

Yesa,b
∗
O(b1+C / )
1+C ∗ /
O(b
)
Yes

No
O(bm )
O(bm)
No

No
O(b )
O(b)
No

Yesa
O(bd )
O(bd)
Yesc

Yesa,d
O(bd/2 )
O(bd/2 )
Yesc,d

Figure 3.21 Evaluation of tree-search strategies. b is the branching factor; d is the depth
of the shallowest solution; m is the maximum depth of the search tree; l is the depth limit.
Superscript caveats are as follows: a complete if b is finite; b complete if step costs ≥  for
positive ; c optimal if step costs are all identical; d if both directions use breadth-first search.

92

3.5

Chapter

3.

Solving Problems by Searching

I NFORMED (H EURISTIC ) S EARCH S TRATEGIES

INFORMED SEARCH

BEST-FIRST SEARCH

EVALUATION
FUNCTION

HEURISTIC
FUNCTION

This section shows how an informed search strategy—one that uses problem-specific knowledge beyond the definition of the problem itself—can find solutions more efficiently than can
an uninformed strategy.
The general approach we consider is called best-first search. Best-first search is an
instance of the general T REE -S EARCH or G RAPH -S EARCH algorithm in which a node is
selected for expansion based on an evaluation function, f (n). The evaluation function is
construed as a cost estimate, so the node with the lowest evaluation is expanded first. The
implementation of best-first graph search is identical to that for uniform-cost search (Figure 3.14), except for the use of f instead of g to order the priority queue.
The choice of f determines the search strategy. (For example, as Exercise 3.21 shows,
best-first tree search includes depth-first search as a special case.) Most best-first algorithms
include as a component of f a heuristic function, denoted h(n):
h(n) = estimated cost of the cheapest path from the state at node n to a goal state.
(Notice that h(n) takes a node as input, but, unlike g(n), it depends only on the state at that
node.) For example, in Romania, one might estimate the cost of the cheapest path from Arad
to Bucharest via the straight-line distance from Arad to Bucharest.
Heuristic functions are the most common form in which additional knowledge of the
problem is imparted to the search algorithm. We study heuristics in more depth in Section 3.6.
For now, we consider them to be arbitrary, nonnegative, problem-specific functions, with one
constraint: if n is a goal node, then h(n) = 0. The remainder of this section covers two ways
to use heuristic information to guide search.

3.5.1 Greedy best-first search
GREEDY BEST-FIRST
SEARCH

STRAIGHT-LINE
DISTANCE

Greedy best-first search8 tries to expand the node that is closest to the goal, on the grounds
that this is likely to lead to a solution quickly. Thus, it evaluates nodes by using just the
heuristic function; that is, f (n) = h(n).
Let us see how this works for route-finding problems in Romania; we use the straightline distance heuristic, which we will call hSLD . If the goal is Bucharest, we need to
know the straight-line distances to Bucharest, which are shown in Figure 3.22. For example, hSLD (In(Arad )) = 366. Notice that the values of hSLD cannot be computed from the
problem description itself. Moreover, it takes a certain amount of experience to know that
hSLD is correlated with actual road distances and is, therefore, a useful heuristic.
Figure 3.23 shows the progress of a greedy best-first search using hSLD to find a path
from Arad to Bucharest. The first node to be expanded from Arad will be Sibiu because it
is closer to Bucharest than either Zerind or Timisoara. The next node to be expanded will
be Fagaras because it is closest. Fagaras in turn generates Bucharest, which is the goal. For
this particular problem, greedy best-first search using hSLD finds a solution without ever
8

Our first edition called this greedy search; other authors have called it best-first search. Our more general
usage of the latter term follows Pearl (1984).

Section 3.5.

Informed (Heuristic) Search Strategies
Arad
Bucharest
Craiova
Drobeta
Eforie
Fagaras
Giurgiu
Hirsova
Iasi
Lugoj
Figure 3.22

366
0
160
242
161
176
77
151
226
244

93
Mehadia
Neamt
Oradea
Pitesti
Rimnicu Vilcea
Sibiu
Timisoara
Urziceni
Vaslui
Zerind

241
234
380
100
193
253
329
80
199
374

Values of hSLD —straight-line distances to Bucharest.

expanding a node that is not on the solution path; hence, its search cost is minimal. It is
not optimal, however: the path via Sibiu and Fagaras to Bucharest is 32 kilometers longer
than the path through Rimnicu Vilcea and Pitesti. This shows why the algorithm is called
“greedy”—at each step it tries to get as close to the goal as it can.
Greedy best-first tree search is also incomplete even in a finite state space, much like
depth-first search. Consider the problem of getting from Iasi to Fagaras. The heuristic suggests that Neamt be expanded first because it is closest to Fagaras, but it is a dead end. The
solution is to go first to Vaslui—a step that is actually farther from the goal according to
the heuristic—and then to continue to Urziceni, Bucharest, and Fagaras. The algorithm will
never find this solution, however, because expanding Neamt puts Iasi back into the frontier,
Iasi is closer to Fagaras than Vaslui is, and so Iasi will be expanded again, leading to an infinite loop. (The graph search version is complete in finite spaces, but not in infinite ones.) The
worst-case time and space complexity for the tree version is O(bm ), where m is the maximum
depth of the search space. With a good heuristic function, however, the complexity can be
reduced substantially. The amount of the reduction depends on the particular problem and on
the quality of the heuristic.

3.5.2 A* search: Minimizing the total estimated solution cost
∗

A SEARCH

The most widely known form of best-first search is called A∗ search (pronounced “A-star
search”). It evaluates nodes by combining g(n), the cost to reach the node, and h(n), the cost
to get from the node to the goal:
f (n) = g(n) + h(n) .
Since g(n) gives the path cost from the start node to node n, and h(n) is the estimated cost
of the cheapest path from n to the goal, we have
f (n) = estimated cost of the cheapest solution through n .
Thus, if we are trying to find the cheapest solution, a reasonable thing to try first is the
node with the lowest value of g(n) + h(n). It turns out that this strategy is more than just
reasonable: provided that the heuristic function h(n) satisfies certain conditions, A∗ search is
both complete and optimal. The algorithm is identical to U NIFORM -C OST-S EARCH except
that A∗ uses g + h instead of g.

94

Chapter
(a) The initial state

3.

Solving Problems by Searching

Arad
366

(b) After expanding Arad

Arad

Sibiu

Timisoara

Zerind

253

329

374

Timisoara

Zerind

329

374

Timisoara

Zerind

329

374

(c) After expanding Sibiu

Arad

Sibiu

Arad

Fagaras

Oradea

Rimnicu Vilcea

366

176

380

193

(d) After expanding Fagaras

Arad

Sibiu

Arad

Fagaras

Oradea

Rimnicu Vilcea

380

193

366

Sibiu

Bucharest

253

0

Figure 3.23 Stages in a greedy best-first tree search for Bucharest with the straight-line
distance heuristic hSLD . Nodes are labeled with their h-values.

Conditions for optimality: Admissibility and consistency
ADMISSIBLE
HEURISTIC

The first condition we require for optimality is that h(n) be an admissible heuristic. An
admissible heuristic is one that never overestimates the cost to reach the goal. Because g(n)
is the actual cost to reach n along the current path, and f (n) = g(n) + h(n), we have as an
immediate consequence that f (n) never overestimates the true cost of a solution along the
current path through n.
Admissible heuristics are by nature optimistic because they think the cost of solving
the problem is less than it actually is. An obvious example of an admissible heuristic is the
straight-line distance hSLD that we used in getting to Bucharest. Straight-line distance is
admissible because the shortest path between any two points is a straight line, so the straight

Section 3.5.

CONSISTENCY
MONOTONICITY

Informed (Heuristic) Search Strategies

95

line cannot be an overestimate. In Figure 3.24, we show the progress of an A∗ tree search for
Bucharest. The values of g are computed from the step costs in Figure 3.2, and the values of
hSLD are given in Figure 3.22. Notice in particular that Bucharest first appears on the frontier
at step (e), but it is not selected for expansion because its f -cost (450) is higher than that of
Pitesti (417). Another way to say this is that there might be a solution through Pitesti whose
cost is as low as 417, so the algorithm will not settle for a solution that costs 450.
A second, slightly stronger condition called consistency (or sometimes monotonicity)
is required only for applications of A∗ to graph search.9 A heuristic h(n) is consistent if, for
every node n and every successor n of n generated by any action a, the estimated cost of
reaching the goal from n is no greater than the step cost of getting to n plus the estimated
cost of reaching the goal from n :
h(n) ≤ c(n, a, n ) + h(n ) .

TRIANGLE
INEQUALITY

This is a form of the general triangle inequality, which stipulates that each side of a triangle
cannot be longer than the sum of the other two sides. Here, the triangle is formed by n, n ,
and the goal Gn closest to n. For an admissible heuristic, the inequality makes perfect sense:
if there were a route from n to Gn via n that was cheaper than h(n), that would violate the
property that h(n) is a lower bound on the cost to reach Gn .
It is fairly easy to show (Exercise 3.29) that every consistent heuristic is also admissible.
Consistency is therefore a stricter requirement than admissibility, but one has to work quite
hard to concoct heuristics that are admissible but not consistent. All the admissible heuristics
we discuss in this chapter are also consistent. Consider, for example, hSLD . We know that
the general triangle inequality is satisfied when each side is measured by the straight-line
distance and that the straight-line distance between n and n is no greater than c(n, a, n ).
Hence, hSLD is a consistent heuristic.
Optimality of A*
As we mentioned earlier, A∗ has the following properties: the tree-search version of A∗ is
optimal if h(n) is admissible, while the graph-search version is optimal if h(n) is consistent.
We show the second of these two claims since it is more useful. The argument essentially mirrors the argument for the optimality of uniform-cost search, with g replaced by
f —just as in the A∗ algorithm itself.
The first step is to establish the following: if h(n) is consistent, then the values of
f (n) along any path are nondecreasing. The proof follows directly from the definition of
consistency. Suppose n is a successor of n; then g(n ) = g(n) + c(n, a, n ) for some action
a, and we have
f (n ) = g(n ) + h(n ) = g(n) + c(n, a, n ) + h(n ) ≥ g(n) + h(n) = f (n) .
The next step is to prove that whenever A∗ selects a node n for expansion, the optimal path
to that node has been found. Were this not the case, there would have to be another frontier
node n on the optimal path from the start node to n, by the graph separation property of
9

With an admissible but inconsistent heuristic, A∗ requires some extra bookkeeping to ensure optimality.

96

Chapter
(a) The initial state

3.

Solving Problems by Searching

Arad
366=0+366

(b) After expanding Arad

Arad

Sibiu
393=140+253

(c) After expanding Sibiu

Fagaras

Zerind
449=75+374

Arad

Sibiu

Arad

Timisoara
447=118+329

Oradea

Timisoara

Zerind

447=118+329

449=75+374

Rimnicu Vilcea

646=280+366 415=239+176 671=291+380 413=220+193

(d) After expanding Rimnicu Vilcea

Arad

Sibiu

Arad

Fagaras

Oradea

Timisoara

Zerind

447=118+329

449=75+374

Rimnicu Vilcea

646=280+366 415=239+176 671=291+380
Craiova

Pitesti

Sibiu

526=366+160 417=317+100 553=300+253

(e) After expanding Fagaras

Arad

Sibiu

Arad

Fagaras

646=280+366
Sibiu

Oradea

Rimnicu Vilcea

Bucharest

Craiova

Pitesti

Arad

Sibiu

Fagaras

Sibiu

Sibiu

526=366+160 417=317+100 553=300+253

(f) After expanding Pitesti

Arad

Zerind
449=75+374

671=291+380

591=338+253 450=450+0

646=280+366

Timisoara
447=118+329

Timisoara

Zerind

447=118+329

449=75+374

Rimnicu Vilcea

Oradea
671=291+380

Bucharest

591=338+253 450=450+0

Craiova

Pitesti

526=366+160
Bucharest

Sibiu
553=300+253

Craiova

Rimnicu Vilcea

418=418+0 615=455+160 607=414+193

Figure 3.24 Stages in an A∗ search for Bucharest. Nodes are labeled with f = g + h. The
h values are the straight-line distances to Bucharest taken from Figure 3.22.

Section 3.5.

Informed (Heuristic) Search Strategies

97

O
N

Z

I

A
S

380

F

V

400
T

R
P

L
M

B

420

D
C

U

H
E

G

Figure 3.25 Map of Romania showing contours at f = 380, f = 400, and f = 420, with
Arad as the start state. Nodes inside a given contour have f -costs less than or equal to the
contour value.

CONTOUR

Figure 3.9; because f is nondecreasing along any path, n would have lower f -cost than n
and would have been selected first.
From the two preceding observations, it follows that the sequence of nodes expanded
by A∗ using G RAPH -S EARCH is in nondecreasing order of f (n). Hence, the first goal node
selected for expansion must be an optimal solution because f is the true cost for goal nodes
(which have h = 0) and all later goal nodes will be at least as expensive.
The fact that f -costs are nondecreasing along any path also means that we can draw
contours in the state space, just like the contours in a topographic map. Figure 3.25 shows
an example. Inside the contour labeled 400, all nodes have f (n) less than or equal to 400,
and so on. Then, because A∗ expands the frontier node of lowest f -cost, we can see that an
A∗ search fans out from the start node, adding nodes in concentric bands of increasing f -cost.
With uniform-cost search (A∗ search using h(n) = 0), the bands will be “circular”
around the start state. With more accurate heuristics, the bands will stretch toward the goal
state and become more narrowly focused around the optimal path. If C ∗ is the cost of the
optimal solution path, then we can say the following:
• A∗ expands all nodes with f (n) < C ∗ .
• A∗ might then expand some of the nodes right on the “goal contour” (where f (n) = C ∗ )
before selecting a goal node.
Completeness requires that there be only finitely many nodes with cost less than or equal to
C ∗ , a condition that is true if all step costs exceed some finite  and if b is finite.
Notice that A∗ expands no nodes with f (n) > C ∗ —for example, Timisoara is not
expanded in Figure 3.24 even though it is a child of the root. We say that the subtree below

98
PRUNING

OPTIMALLY
EFFICIENT

ABSOLUTE ERROR
RELATIVE ERROR

Chapter

3.

Solving Problems by Searching

Timisoara is pruned; because hSLD is admissible, the algorithm can safely ignore this subtree
while still guaranteeing optimality. The concept of pruning—eliminating possibilities from
consideration without having to examine them—is important for many areas of AI.
One final observation is that among optimal algorithms of this type—algorithms that
extend search paths from the root and use the same heuristic information—A∗ is optimally
efficient for any given consistent heuristic. That is, no other optimal algorithm is guaranteed to expand fewer nodes than A∗ (except possibly through tie-breaking among nodes with
f (n) = C ∗ ). This is because any algorithm that does not expand all nodes with f (n) < C ∗
runs the risk of missing the optimal solution.
That A∗ search is complete, optimal, and optimally efficient among all such algorithms
is rather satisfying. Unfortunately, it does not mean that A∗ is the answer to all our searching
needs. The catch is that, for most problems, the number of states within the goal contour
search space is still exponential in the length of the solution. The details of the analysis are
beyond the scope of this book, but the basic results are as follows. For problems with constant
step costs, the growth in run time as a function of the optimal solution depth d is analyzed in
terms of the the absolute error or the relative error of the heuristic. The absolute error is
defined as Δ ≡ h∗ − h, where h∗ is the actual cost of getting from the root to the goal, and
the relative error is defined as  ≡ (h∗ − h)/h∗ .
The complexity results depend very strongly on the assumptions made about the state
space. The simplest model studied is a state space that has a single goal and is essentially a
tree with reversible actions. (The 8-puzzle satisfies the first and third of these assumptions.)
In this case, the time complexity of A∗ is exponential in the maximum absolute error, that is,
O(bΔ ). For constant step costs, we can write this as O(bd ), where d is the solution depth.
For almost all heuristics in practical use, the absolute error is at least proportional to the path
cost h∗ , so  is constant or growing and the time complexity is exponential in d. We can
also see the effect of a more accurate heuristic: O(bd ) = O((b )d ), so the effective branching
factor (defined more formally in the next section) is b .
When the state space has many goal states—particularly near-optimal goal states—the
search process can be led astray from the optimal path and there is an extra cost proportional
to the number of goals whose cost is within a factor  of the optimal cost. Finally, in the
general case of a graph, the situation is even worse. There can be exponentially many states
with f (n) < C ∗ even if the absolute error is bounded by a constant. For example, consider
a version of the vacuum world where the agent can clean up any square for unit cost without
even having to visit it: in that case, squares can be cleaned in any order. With N initially dirty
squares, there are 2N states where some subset has been cleaned and all of them are on an
optimal solution path—and hence satisfy f (n) < C ∗ —even if the heuristic has an error of 1.
The complexity of A∗ often makes it impractical to insist on finding an optimal solution.
One can use variants of A∗ that find suboptimal solutions quickly, or one can sometimes
design heuristics that are more accurate but not strictly admissible. In any case, the use of a
good heuristic still provides enormous savings compared to the use of an uninformed search.
In Section 3.6, we look at the question of designing good heuristics.
Computation time is not, however, A∗ ’s main drawback. Because it keeps all generated
nodes in memory (as do all G RAPH -S EARCH algorithms), A∗ usually runs out of space long

Section 3.5.

Informed (Heuristic) Search Strategies

99

function R ECURSIVE -B EST-F IRST-S EARCH ( problem) returns a solution, or failure
return RBFS(problem, M AKE -N ODE(problem.I NITIAL -S TATE), ∞)
function RBFS(problem, node, f limit ) returns a solution, or failure and a new f -cost limit
if problem.G OAL -T EST(node.S TATE) then return S OLUTION(node)
successors ← [ ]
for each action in problem.ACTIONS (node.S TATE) do
add C HILD -N ODE( problem, node, action) into successors
if successors is empty then return failure, ∞
for each s in successors do /* update f with value from previous search, if any */
s.f ← max(s.g + s.h, node.f ))
loop do
best ← the lowest f -value node in successors
if best .f > f limit then return failure, best.f
alternative ← the second-lowest f -value among successors
result, best.f ← RBFS(problem, best, min( f limit, alternative))
if result  = failure then return result
Figure 3.26

The algorithm for recursive best-first search.

before it runs out of time. For this reason, A∗ is not practical for many large-scale problems. There are, however, algorithms that overcome the space problem without sacrificing
optimality or completeness, at a small cost in execution time. We discuss these next.

3.5.3 Memory-bounded heuristic search
ITERATIVEDEEPENING
∗
A

RECURSIVE
BEST-FIRST SEARCH

BACKED-UP VALUE

The simplest way to reduce memory requirements for A∗ is to adapt the idea of iterative
deepening to the heuristic search context, resulting in the iterative-deepening A∗ (IDA∗ ) algorithm. The main difference between IDA∗ and standard iterative deepening is that the cutoff
used is the f -cost (g + h) rather than the depth; at each iteration, the cutoff value is the smallest f -cost of any node that exceeded the cutoff on the previous iteration. IDA∗ is practical
for many problems with unit step costs and avoids the substantial overhead associated with
keeping a sorted queue of nodes. Unfortunately, it suffers from the same difficulties with realvalued costs as does the iterative version of uniform-cost search described in Exercise 3.17.
This section briefly examines two other memory-bounded algorithms, called RBFS and MA∗ .
Recursive best-first search (RBFS) is a simple recursive algorithm that attempts to
mimic the operation of standard best-first search, but using only linear space. The algorithm
is shown in Figure 3.26. Its structure is similar to that of a recursive depth-first search, but
rather than continuing indefinitely down the current path, it uses the f limit variable to keep
track of the f -value of the best alternative path available from any ancestor of the current
node. If the current node exceeds this limit, the recursion unwinds back to the alternative
path. As the recursion unwinds, RBFS replaces the f -value of each node along the path
with a backed-up value—the best f -value of its children. In this way, RBFS remembers the
f -value of the best leaf in the forgotten subtree and can therefore decide whether it’s worth

100

Chapter
(a) After expanding Arad, Sibiu,
and Rimnicu Vilcea
447
Sibiu

3.

∞
Arad

Solving Problems by Searching

366

Timisoara
447

393

Zerind
449

415
Arad
646

Fagaras
415

Oradea

Rimnicu Vilcea

671

413

Craiova
526

Pitesti

(b) After unwinding back to Sibiu
and expanding Fagaras
447
Sibiu

Arad
646

417
Fagaras
415

Sibiu
591

Sibiu
553

417
∞
Arad

366

Timisoara
447

393

Oradea

Zerind

449

Rimnicu Vilcea

671

413 417

Bucharest
450

(c) After switching back to Rimnicu Vilcea
and expanding Pitesti
447
Sibiu

∞
Arad

366

Timisoara

393

Zerind
447

449

447
Arad
646

Fagaras
415 450

Rimnicu Vilcea

Oradea
671

417
447
Pitesti

Craiova

Bucharest
418

Sibiu
417

526

553
Rimnicu Vilcea

Craiova
615

607

Figure 3.27 Stages in an RBFS search for the shortest route to Bucharest. The f -limit
value for each recursive call is shown on top of each current node, and every node is labeled
with its f -cost. (a) The path via Rimnicu Vilcea is followed until the current best leaf (Pitesti)
has a value that is worse than the best alternative path (Fagaras). (b) The recursion unwinds
and the best leaf value of the forgotten subtree (417) is backed up to Rimnicu Vilcea; then
Fagaras is expanded, revealing a best leaf value of 450. (c) The recursion unwinds and the
best leaf value of the forgotten subtree (450) is backed up to Fagaras; then Rimnicu Vilcea is
expanded. This time, because the best alternative path (through Timisoara) costs at least 447,
the expansion continues to Bucharest.

reexpanding the subtree at some later time. Figure 3.27 shows how RBFS reaches Bucharest.
RBFS is somewhat more efficient than IDA∗ , but still suffers from excessive node regeneration. In the example in Figure 3.27, RBFS follows the path via Rimnicu Vilcea, then

Section 3.5.

MA*
SMA*

Informed (Heuristic) Search Strategies

101

“changes its mind” and tries Fagaras, and then changes its mind back again. These mind
changes occur because every time the current best path is extended, its f -value is likely to
increase—h is usually less optimistic for nodes closer to the goal. When this happens, the
second-best path might become the best path, so the search has to backtrack to follow it.
Each mind change corresponds to an iteration of IDA∗ and could require many reexpansions
of forgotten nodes to recreate the best path and extend it one more node.
Like A∗ tree search, RBFS is an optimal algorithm if the heuristic function h(n) is
admissible. Its space complexity is linear in the depth of the deepest optimal solution, but
its time complexity is rather difficult to characterize: it depends both on the accuracy of the
heuristic function and on how often the best path changes as nodes are expanded.
IDA∗ and RBFS suffer from using too little memory. Between iterations, IDA∗ retains
only a single number: the current f -cost limit. RBFS retains more information in memory,
but it uses only linear space: even if more memory were available, RBFS has no way to make
use of it. Because they forget most of what they have done, both algorithms may end up reexpanding the same states many times over. Furthermore, they suffer the potentially exponential
increase in complexity associated with redundant paths in graphs (see Section 3.3).
It seems sensible, therefore, to use all available memory. Two algorithms that do this
are MA∗ (memory-bounded A∗ ) and SMA∗ (simplified MA∗ ). SMA∗ is—well—simpler, so
we will describe it. SMA∗ proceeds just like A∗ , expanding the best leaf until memory is full.
At this point, it cannot add a new node to the search tree without dropping an old one. SMA∗
always drops the worst leaf node—the one with the highest f -value. Like RBFS, SMA∗
then backs up the value of the forgotten node to its parent. In this way, the ancestor of a
forgotten subtree knows the quality of the best path in that subtree. With this information,
SMA∗ regenerates the subtree only when all other paths have been shown to look worse than
the path it has forgotten. Another way of saying this is that, if all the descendants of a node n
are forgotten, then we will not know which way to go from n, but we will still have an idea
of how worthwhile it is to go anywhere from n.
The complete algorithm is too complicated to reproduce here,10 but there is one subtlety
worth mentioning. We said that SMA∗ expands the best leaf and deletes the worst leaf. What
if all the leaf nodes have the same f -value? To avoid selecting the same node for deletion
and expansion, SMA∗ expands the newest best leaf and deletes the oldest worst leaf. These
coincide when there is only one leaf, but in that case, the current search tree must be a single
path from root to leaf that fills all of memory. If the leaf is not a goal node, then even if it is on
an optimal solution path, that solution is not reachable with the available memory. Therefore,
the node can be discarded exactly as if it had no successors.
SMA∗ is complete if there is any reachable solution—that is, if d, the depth of the
shallowest goal node, is less than the memory size (expressed in nodes). It is optimal if any
optimal solution is reachable; otherwise, it returns the best reachable solution. In practical
terms, SMA∗ is a fairly robust choice for finding optimal solutions, particularly when the state
space is a graph, step costs are not uniform, and node generation is expensive compared to
the overhead of maintaining the frontier and the explored set.
10 A rough sketch appeared in the first edition of this book.

102

Chapter

3.

Solving Problems by Searching

On very hard problems, however, it will often be the case that SMA∗ is forced to switch
back and forth continually among many candidate solution paths, only a small subset of which
can fit in memory. (This resembles the problem of thrashing in disk paging systems.) Then
the extra time required for repeated regeneration of the same nodes means that problems
that would be practically solvable by A∗ , given unlimited memory, become intractable for
SMA∗ . That is to say, memory limitations can make a problem intractable from the point
of view of computation time. Although no current theory explains the tradeoff between time
and memory, it seems that this is an inescapable problem. The only way out is to drop the
optimality requirement.

THRASHING

3.5.4 Learning to search better

METALEVEL STATE
SPACE
OBJECT-LEVEL STATE
SPACE

METALEVEL
LEARNING

3.6

We have presented several fixed strategies—breadth-first, greedy best-first, and so on—that
have been designed by computer scientists. Could an agent learn how to search better? The
answer is yes, and the method rests on an important concept called the metalevel state space.
Each state in a metalevel state space captures the internal (computational) state of a program
that is searching in an object-level state space such as Romania. For example, the internal
state of the A∗ algorithm consists of the current search tree. Each action in the metalevel state
space is a computation step that alters the internal state; for example, each computation step
in A∗ expands a leaf node and adds its successors to the tree. Thus, Figure 3.24, which shows
a sequence of larger and larger search trees, can be seen as depicting a path in the metalevel
state space where each state on the path is an object-level search tree.
Now, the path in Figure 3.24 has five steps, including one step, the expansion of Fagaras,
that is not especially helpful. For harder problems, there will be many such missteps, and a
metalevel learning algorithm can learn from these experiences to avoid exploring unpromising subtrees. The techniques used for this kind of learning are described in Chapter 21. The
goal of learning is to minimize the total cost of problem solving, trading off computational
expense and path cost.

H EURISTIC F UNCTIONS
In this section, we look at heuristics for the 8-puzzle, in order to shed light on the nature of
heuristics in general.
The 8-puzzle was one of the earliest heuristic search problems. As mentioned in Section 3.2, the object of the puzzle is to slide the tiles horizontally or vertically into the empty
space until the configuration matches the goal configuration (Figure 3.28).
The average solution cost for a randomly generated 8-puzzle instance is about 22 steps.
The branching factor is about 3. (When the empty tile is in the middle, four moves are
possible; when it is in a corner, two; and when it is along an edge, three.) This means
that an exhaustive tree search to depth 22 would look at about 322 ≈ 3.1 × 1010 states.
A graph search would cut this down by a factor of about 170,000 because only 9!/2 =
181, 440 distinct states are reachable. (See Exercise 3.4.) This is a manageable number, but

Section 3.6.

Heuristic Functions

103

7

2

5
8

3

4

2

6

3

4

5

1

6

7

8

Start State
Figure 3.28

1

Goal State

A typical instance of the 8-puzzle. The solution is 26 steps long.

the corresponding number for the 15-puzzle is roughly 1013 , so the next order of business is
to find a good heuristic function. If we want to find the shortest solutions by using A∗ , we
need a heuristic function that never overestimates the number of steps to the goal. There is a
long history of such heuristics for the 15-puzzle; here are two commonly used candidates:

MANHATTAN
DISTANCE

• h1 = the number of misplaced tiles. For Figure 3.28, all of the eight tiles are out of
position, so the start state would have h1 = 8. h1 is an admissible heuristic because it
is clear that any tile that is out of place must be moved at least once.
• h2 = the sum of the distances of the tiles from their goal positions. Because tiles
cannot move along diagonals, the distance we will count is the sum of the horizontal
and vertical distances. This is sometimes called the city block distance or Manhattan
distance. h2 is also admissible because all any move can do is move one tile one step
closer to the goal. Tiles 1 to 8 in the start state give a Manhattan distance of
h2 = 3 + 1 + 2 + 2 + 2 + 3 + 3 + 2 = 18 .
As expected, neither of these overestimates the true solution cost, which is 26.

3.6.1 The effect of heuristic accuracy on performance
EFFECTIVE
BRANCHING FACTOR

One way to characterize the quality of a heuristic is the effective branching factor b∗ . If the
total number of nodes generated by A∗ for a particular problem is N and the solution depth is
d, then b∗ is the branching factor that a uniform tree of depth d would have to have in order
to contain N + 1 nodes. Thus,
N + 1 = 1 + b∗ + (b∗ )2 + · · · + (b∗ )d .
For example, if A∗ finds a solution at depth 5 using 52 nodes, then the effective branching
factor is 1.92. The effective branching factor can vary across problem instances, but usually
it is fairly constant for sufficiently hard problems. (The existence of an effective branching
factor follows from the result, mentioned earlier, that the number of nodes expanded by A∗
grows exponentially with solution depth.) Therefore, experimental measurements of b∗ on a
small set of problems can provide a good guide to the heuristic’s overall usefulness. A welldesigned heuristic would have a value of b∗ close to 1, allowing fairly large problems to be
solved at reasonable computational cost.

104

Chapter

3.

Solving Problems by Searching

To test the heuristic functions h1 and h2 , we generated 1200 random problems with
solution lengths from 2 to 24 (100 for each even number) and solved them with iterative
deepening search and with A∗ tree search using both h1 and h2 . Figure 3.29 gives the average
number of nodes generated by each strategy and the effective branching factor. The results
suggest that h2 is better than h1 , and is far better than using iterative deepening search. Even
for small problems with d = 12, A∗ with h2 is 50,000 times more efficient than uninformed
iterative deepening search.
Search Cost (nodes generated)

Effective Branching Factor

d

IDS

A∗ (h1 )

A∗ (h2 )

IDS

A∗ (h1 )

A∗ (h2 )

2
4
6
8
10
12
14
16
18
20
22
24

10
112
680
6384
47127
3644035
–
–
–
–
–
–

6
13
20
39
93
227
539
1301
3056
7276
18094
39135

6
12
18
25
39
73
113
211
363
676
1219
1641

2.45
2.87
2.73
2.80
2.79
2.78
–
–
–
–
–
–

1.79
1.48
1.34
1.33
1.38
1.42
1.44
1.45
1.46
1.47
1.48
1.48

1.79
1.45
1.30
1.24
1.22
1.24
1.23
1.25
1.26
1.27
1.28
1.26

Figure 3.29 Comparison of the search costs and effective branching factors for the
I TERATIVE -D EEPENING -S EARCH and A∗ algorithms with h1 , h2 . Data are averaged over
100 instances of the 8-puzzle for each of various solution lengths d.

DOMINATION

One might ask whether h2 is always better than h1 . The answer is “Essentially, yes.” It
is easy to see from the definitions of the two heuristics that, for any node n, h2 (n) ≥ h1 (n).
We thus say that h2 dominates h1 . Domination translates directly into efficiency: A∗ using
h2 will never expand more nodes than A∗ using h1 (except possibly for some nodes with
f (n) = C ∗ ). The argument is simple. Recall the observation on page 97 that every node
with f (n) < C ∗ will surely be expanded. This is the same as saying that every node with
h(n) < C ∗ − g(n) will surely be expanded. But because h2 is at least as big as h1 for all
nodes, every node that is surely expanded by A∗ search with h2 will also surely be expanded
with h1 , and h1 might cause other nodes to be expanded as well. Hence, it is generally
better to use a heuristic function with higher values, provided it is consistent and that the
computation time for the heuristic is not too long.

3.6.2 Generating admissible heuristics from relaxed problems
We have seen that both h1 (misplaced tiles) and h2 (Manhattan distance) are fairly good
heuristics for the 8-puzzle and that h2 is better. How might one have come up with h2 ? Is it
possible for a computer to invent such a heuristic mechanically?
h1 and h2 are estimates of the remaining path length for the 8-puzzle, but they are also
perfectly accurate path lengths for simplified versions of the puzzle. If the rules of the puzzle

Section 3.6.

RELAXED PROBLEM

Heuristic Functions

105

were changed so that a tile could move anywhere instead of just to the adjacent empty square,
then h1 would give the exact number of steps in the shortest solution. Similarly, if a tile could
move one square in any direction, even onto an occupied square, then h2 would give the exact
number of steps in the shortest solution. A problem with fewer restrictions on the actions is
called a relaxed problem. The state-space graph of the relaxed problem is a supergraph of
the original state space because the removal of restrictions creates added edges in the graph.
Because the relaxed problem adds edges to the state space, any optimal solution in the
original problem is, by definition, also a solution in the relaxed problem; but the relaxed
problem may have better solutions if the added edges provide short cuts. Hence, the cost of
an optimal solution to a relaxed problem is an admissible heuristic for the original problem.
Furthermore, because the derived heuristic is an exact cost for the relaxed problem, it must
obey the triangle inequality and is therefore consistent (see page 95).
If a problem definition is written down in a formal language, it is possible to construct
relaxed problems automatically.11 For example, if the 8-puzzle actions are described as
A tile can move from square A to square B if
A is horizontally or vertically adjacent to B and B is blank,
we can generate three relaxed problems by removing one or both of the conditions:
(a) A tile can move from square A to square B if A is adjacent to B.
(b) A tile can move from square A to square B if B is blank.
(c) A tile can move from square A to square B.
From (a), we can derive h2 (Manhattan distance). The reasoning is that h2 would be the
proper score if we moved each tile in turn to its destination. The heuristic derived from (b) is
discussed in Exercise 3.31. From (c), we can derive h1 (misplaced tiles) because it would be
the proper score if tiles could move to their intended destination in one step. Notice that it is
crucial that the relaxed problems generated by this technique can be solved essentially without
search, because the relaxed rules allow the problem to be decomposed into eight independent
subproblems. If the relaxed problem is hard to solve, then the values of the corresponding
heuristic will be expensive to obtain.12
A program called A BSOLVER can generate heuristics automatically from problem definitions, using the “relaxed problem” method and various other techniques (Prieditis, 1993).
A BSOLVER generated a new heuristic for the 8-puzzle that was better than any preexisting
heuristic and found the first useful heuristic for the famous Rubik’s Cube puzzle.
One problem with generating new heuristic functions is that one often fails to get a
single “clearly best” heuristic. If a collection of admissible heuristics h1 . . . hm is available
for a problem and none of them dominates any of the others, which should we choose? As it
turns out, we need not make a choice. We can have the best of all worlds, by defining
h(n) = max{h1 (n), . . . , hm (n)} .
11 In Chapters 8 and 10, we describe formal languages suitable for this task; with formal descriptions that can be
manipulated, the construction of relaxed problems can be automated. For now, we use English.
12 Note that a perfect heuristic can be obtained simply by allowing h to run a full breadth-first search “on the
sly.” Thus, there is a tradeoff between accuracy and computation time for heuristic functions.

106

Chapter

2
5
8

3
Start State

3.

4

Solving Problems by Searching

1

2
6

6

3

54

1

7

8
Goal State

Figure 3.30 A subproblem of the 8-puzzle instance given in Figure 3.28. The task is to
get tiles 1, 2, 3, and 4 into their correct positions, without worrying about what happens to
the other tiles.

This composite heuristic uses whichever function is most accurate on the node in question.
Because the component heuristics are admissible, h is admissible; it is also easy to prove that
h is consistent. Furthermore, h dominates all of its component heuristics.

3.6.3 Generating admissible heuristics from subproblems: Pattern databases
SUBPROBLEM

PATTERN DATABASE

Admissible heuristics can also be derived from the solution cost of a subproblem of a given
problem. For example, Figure 3.30 shows a subproblem of the 8-puzzle instance in Figure 3.28. The subproblem involves getting tiles 1, 2, 3, 4 into their correct positions. Clearly,
the cost of the optimal solution of this subproblem is a lower bound on the cost of the complete problem. It turns out to be more accurate than Manhattan distance in some cases.
The idea behind pattern databases is to store these exact solution costs for every possible subproblem instance—in our example, every possible configuration of the four tiles
and the blank. (The locations of the other four tiles are irrelevant for the purposes of solving the subproblem, but moves of those tiles do count toward the cost.) Then we compute
an admissible heuristic hDB for each complete state encountered during a search simply by
looking up the corresponding subproblem configuration in the database. The database itself is
constructed by searching back13 from the goal and recording the cost of each new pattern encountered; the expense of this search is amortized over many subsequent problem instances.
The choice of 1-2-3-4 is fairly arbitrary; we could also construct databases for 5-6-7-8,
for 2-4-6-8, and so on. Each database yields an admissible heuristic, and these heuristics can
be combined, as explained earlier, by taking the maximum value. A combined heuristic of
this kind is much more accurate than the Manhattan distance; the number of nodes generated
when solving random 15-puzzles can be reduced by a factor of 1000.
One might wonder whether the heuristics obtained from the 1-2-3-4 database and the
5-6-7-8 could be added, since the two subproblems seem not to overlap. Would this still give
an admissible heuristic? The answer is no, because the solutions of the 1-2-3-4 subproblem
and the 5-6-7-8 subproblem for a given state will almost certainly share some moves—it is
13 By working backward from the goal, the exact solution cost of every instance encountered is immediately

available. This is an example of dynamic programming, which we discuss further in Chapter 17.

Section 3.6.

DISJOINT PATTERN
DATABASES

Heuristic Functions

107

unlikely that 1-2-3-4 can be moved into place without touching 5-6-7-8, and vice versa. But
what if we don’t count those moves? That is, we record not the total cost of solving the 1-23-4 subproblem, but just the number of moves involving 1-2-3-4. Then it is easy to see that
the sum of the two costs is still a lower bound on the cost of solving the entire problem. This
is the idea behind disjoint pattern databases. With such databases, it is possible to solve
random 15-puzzles in a few milliseconds—the number of nodes generated is reduced by a
factor of 10,000 compared with the use of Manhattan distance. For 24-puzzles, a speedup of
roughly a factor of a million can be obtained.
Disjoint pattern databases work for sliding-tile puzzles because the problem can be
divided up in such a way that each move affects only one subproblem—because only one tile
is moved at a time. For a problem such as Rubik’s Cube, this kind of subdivision is difficult
because each move affects 8 or 9 of the 26 cubies. More general ways of defining additive,
admissible heuristics have been proposed that do apply to Rubik’s cube (Yang et al., 2008),
but they have not yielded a heuristic better than the best nonadditive heuristic for the problem.

3.6.4 Learning heuristics from experience

FEATURE

A heuristic function h(n) is supposed to estimate the cost of a solution beginning from the
state at node n. How could an agent construct such a function? One solution was given in
the preceding sections—namely, to devise relaxed problems for which an optimal solution
can be found easily. Another solution is to learn from experience. “Experience” here means
solving lots of 8-puzzles, for instance. Each optimal solution to an 8-puzzle problem provides
examples from which h(n) can be learned. Each example consists of a state from the solution path and the actual cost of the solution from that point. From these examples, a learning
algorithm can be used to construct a function h(n) that can (with luck) predict solution costs
for other states that arise during search. Techniques for doing just this using neural nets, decision trees, and other methods are demonstrated in Chapter 18. (The reinforcement learning
methods described in Chapter 21 are also applicable.)
Inductive learning methods work best when supplied with features of a state that are
relevant to predicting the state’s value, rather than with just the raw state description. For
example, the feature “number of misplaced tiles” might be helpful in predicting the actual
distance of a state from the goal. Let’s call this feature x1 (n). We could take 100 randomly
generated 8-puzzle configurations and gather statistics on their actual solution costs. We
might find that when x1 (n) is 5, the average solution cost is around 14, and so on. Given
these data, the value of x1 can be used to predict h(n). Of course, we can use several features.
A second feature x2 (n) might be “number of pairs of adjacent tiles that are not adjacent in the
goal state.” How should x1 (n) and x2 (n) be combined to predict h(n)? A common approach
is to use a linear combination:
h(n) = c1 x1 (n) + c2 x2 (n) .
The constants c1 and c2 are adjusted to give the best fit to the actual data on solution costs.
One expects both c1 and c2 to be positive because misplaced tiles and incorrect adjacent pairs
make the problem harder to solve. Notice that this heuristic does satisfy the condition that
h(n) = 0 for goal states, but it is not necessarily admissible or consistent.

108

3.7

Chapter

3.

Solving Problems by Searching

S UMMARY
This chapter has introduced methods that an agent can use to select actions in environments
that are deterministic, observable, static, and completely known. In such cases, the agent can
construct sequences of actions that achieve its goals; this process is called search.
• Before an agent can start searching for solutions, a goal must be identified and a welldefined problem must be formulated.
• A problem consists of five parts: the initial state, a set of actions, a transition model
describing the results of those actions, a goal test function, and a path cost function.
The environment of the problem is represented by a state space. A path through the
state space from the initial state to a goal state is a solution.
• Search algorithms treat states and actions as atomic: they do not consider any internal
structure they might possess.
• A general T REE -S EARCH algorithm considers all possible paths to find a solution,
whereas a G RAPH -S EARCH algorithm avoids consideration of redundant paths.
• Search algorithms are judged on the basis of completeness, optimality, time complexity, and space complexity. Complexity depends on b, the branching factor in the state
space, and d, the depth of the shallowest solution.
• Uninformed search methods have access only to the problem definition. The basic
algorithms are as follows:
– Breadth-first search expands the shallowest nodes first; it is complete, optimal
for unit step costs, but has exponential space complexity.
– Uniform-cost search expands the node with lowest path cost, g(n), and is optimal
for general step costs.
– Depth-first search expands the deepest unexpanded node first. It is neither complete nor optimal, but has linear space complexity. Depth-limited search adds a
depth bound.
– Iterative deepening search calls depth-first search with increasing depth limits
until a goal is found. It is complete, optimal for unit step costs, has time complexity
comparable to breadth-first search, and has linear space complexity.
– Bidirectional search can enormously reduce time complexity, but it is not always
applicable and may require too much space.
• Informed search methods may have access to a heuristic function h(n) that estimates
the cost of a solution from n.
– The generic best-first search algorithm selects a node for expansion according to
an evaluation function.
– Greedy best-first search expands nodes with minimal h(n). It is not optimal but
is often efficient.

Bibliographical and Historical Notes

109

– A∗ search expands nodes with minimal f (n) = g(n) + h(n). A∗ is complete and
optimal, provided that h(n) is admissible (for T REE -S EARCH ) or consistent (for
G RAPH -S EARCH ). The space complexity of A∗ is still prohibitive.
– RBFS (recursive best-first search) and SMA∗ (simplified memory-bounded A∗ )
are robust, optimal search algorithms that use limited amounts of memory; given
enough time, they can solve problems that A∗ cannot solve because it runs out of
memory.
• The performance of heuristic search algorithms depends on the quality of the heuristic
function. One can sometimes construct good heuristics by relaxing the problem definition, by storing precomputed solution costs for subproblems in a pattern database, or
by learning from experience with the problem class.

B IBLIOGRAPHICAL AND H ISTORICAL N OTES
The topic of state-space search originated in more or less its current form in the early years of
AI. Newell and Simon’s work on the Logic Theorist (1957) and GPS (1961) led to the establishment of search algorithms as the primary weapons in the armory of 1960s AI researchers
and to the establishment of problem solving as the canonical AI task. Work in operations
research by Richard Bellman (1957) showed the importance of additive path costs in simplifying optimization algorithms. The text on Automated Problem Solving by Nils Nilsson
(1971) established the area on a solid theoretical footing.
Most of the state-space search problems analyzed in this chapter have a long history
in the literature and are less trivial than they might seem. The missionaries and cannibals
problem used in Exercise 3.9 was analyzed in detail by Amarel (1968). It had been considered earlier—in AI by Simon and Newell (1961) and in operations research by Bellman and
Dreyfus (1962).
The 8-puzzle is a smaller cousin of the 15-puzzle, whose history is recounted at length
by Slocum and Sonneveld (2006). It was widely believed to have been invented by the famous American game designer Sam Loyd, based on his claims to that effect from 1891 onward (Loyd, 1959). Actually it was invented by Noyes Chapman, a postmaster in Canastota,
New York, in the mid-1870s. (Chapman was unable to patent his invention, as a generic
patent covering sliding blocks with letters, numbers, or pictures was granted to Ernest Kinsey
in 1878.) It quickly attracted the attention of the public and of mathematicians (Johnson and
Story, 1879; Tait, 1880). The editors of the American Journal of Mathematics stated, “The
‘15’ puzzle for the last few weeks has been prominently before the American public, and may
safely be said to have engaged the attention of nine out of ten persons of both sexes and all
ages and conditions of the community.” Ratner and Warmuth (1986) showed that the general
n × n version of the 15-puzzle belongs to the class of NP-complete problems.
The 8-queens problem was first published anonymously in the German chess magazine Schach in 1848; it was later attributed to one Max Bezzel. It was republished in 1850
and at that time drew the attention of the eminent mathematician Carl Friedrich Gauss, who

110

Chapter

3.

Solving Problems by Searching

attempted to enumerate all possible solutions; initially he found only 72, but eventually he
found the correct answer of 92, although Nauck published all 92 solutions first, in 1850.
Netto (1901) generalized the problem to n queens, and Abramson and Yung (1989) found an
O(n) algorithm.
Each of the real-world search problems listed in the chapter has been the subject of a
good deal of research effort. Methods for selecting optimal airline flights remain proprietary
for the most part, but Carl de Marcken (personal communication) has shown that airline ticket
pricing and restrictions have become so convoluted that the problem of selecting an optimal
flight is formally undecidable. The traveling-salesperson problem is a standard combinatorial problem in theoretical computer science (Lawler et al., 1992). Karp (1972) proved the
TSP to be NP-hard, but effective heuristic approximation methods were developed (Lin and
Kernighan, 1973). Arora (1998) devised a fully polynomial approximation scheme for Euclidean TSPs. VLSI layout methods are surveyed by Shahookar and Mazumder (1991), and
many layout optimization papers appear in VLSI journals. Robotic navigation and assembly
problems are discussed in Chapter 25.
Uninformed search algorithms for problem solving are a central topic of classical computer science (Horowitz and Sahni, 1978) and operations research (Dreyfus, 1969). Breadthfirst search was formulated for solving mazes by Moore (1959). The method of dynamic
programming (Bellman, 1957; Bellman and Dreyfus, 1962), which systematically records
solutions for all subproblems of increasing lengths, can be seen as a form of breadth-first
search on graphs. The two-point shortest-path algorithm of Dijkstra (1959) is the origin
of uniform-cost search. These works also introduced the idea of explored and frontier sets
(closed and open lists).
A version of iterative deepening designed to make efficient use of the chess clock was
first used by Slate and Atkin (1977) in the C HESS 4.5 game-playing program. Martelli’s
algorithm B (1977) includes an iterative deepening aspect and also dominates A∗ ’s worst-case
performance with admissible but inconsistent heuristics. The iterative deepening technique
came to the fore in work by Korf (1985a). Bidirectional search, which was introduced by
Pohl (1971), can also be effective in some cases.
The use of heuristic information in problem solving appears in an early paper by Simon
and Newell (1958), but the phrase “heuristic search” and the use of heuristic functions that
estimate the distance to the goal came somewhat later (Newell and Ernst, 1965; Lin, 1965).
Doran and Michie (1966) conducted extensive experimental studies of heuristic search. Although they analyzed path length and “penetrance” (the ratio of path length to the total number of nodes examined so far), they appear to have ignored the information provided by the
path cost g(n). The A∗ algorithm, incorporating the current path cost into heuristic search,
was developed by Hart, Nilsson, and Raphael (1968), with some later corrections (Hart et al.,
1972). Dechter and Pearl (1985) demonstrated the optimal efficiency of A∗ .
The original A∗ paper introduced the consistency condition on heuristic functions. The
monotone condition was introduced by Pohl (1977) as a simpler replacement, but Pearl (1984)
showed that the two were equivalent.
Pohl (1977) pioneered the study of the relationship between the error in heuristic functions and the time complexity of A∗ . Basic results were obtained for tree search with unit step

Bibliographical and Historical Notes

ITERATIVE
EXPANSION

111

costs and a single goal node (Pohl, 1977; Gaschnig, 1979; Huyn et al., 1980; Pearl, 1984) and
with multiple goal nodes (Dinh et al., 2007). The “effective branching factor” was proposed
by Nilsson (1971) as an empirical measure of the efficiency; it is equivalent to assuming a
time cost of O((b∗ )d ). For tree search applied to a graph, Korf et al. (2001) argue that the time
cost is better modeled as O(bd−k ), where k depends on the heuristic accuracy; this analysis
has elicited some controversy, however. For graph search, Helmert and Röger (2008) noted
that several well-known problems contained exponentially many nodes on optimal solution
paths, implying exponential time complexity for A∗ even with constant absolute error in h.
There are many variations on the A∗ algorithm. Pohl (1973) proposed the use of dynamic
weighting, which uses a weighted sum fw (n) = wg g(n) + wh h(n) of the current path length
and the heuristic function as an evaluation function, rather than the simple sum f (n) = g(n)+
h(n) used in A∗ . The weights wg and wh are adjusted dynamically as the search progresses.
Pohl’s algorithm can be shown to be -admissible—that is, guaranteed to find solutions within
a factor 1 +  of the optimal solution, where  is a parameter supplied to the algorithm. The
same property is exhibited by the A∗ algorithm (Pearl, 1984), which can select any node from
the frontier provided its f -cost is within a factor 1 +  of the lowest-f -cost frontier node. The
selection can be done so as to minimize search cost.
Bidirectional versions of A∗ have been investigated; a combination of bidirectional A∗
and known landmarks was used to efficiently find driving routes for Microsoft’s online map
service (Goldberg et al., 2006). After caching a set of paths between landmarks, the algorithm
can find an optimal path between any pair of points in a 24 million point graph of the United
States, searching less than 0.1% of the graph. Others approaches to bidirectional search
include a breadth-first search backward from the goal up to a fixed depth, followed by a
forward IDA∗ search (Dillenburg and Nelson, 1994; Manzini, 1995).
A∗ and other state-space search algorithms are closely related to the branch-and-bound
techniques that are widely used in operations research (Lawler and Wood, 1966). The
relationships between state-space search and branch-and-bound have been investigated in
depth (Kumar and Kanal, 1983; Nau et al., 1984; Kumar et al., 1988). Martelli and Montanari (1978) demonstrate a connection between dynamic programming (see Chapter 17) and
certain types of state-space search. Kumar and Kanal (1988) attempt a “grand unification” of
heuristic search, dynamic programming, and branch-and-bound techniques under the name
of CDP—the “composite decision process.”
Because computers in the late 1950s and early 1960s had at most a few thousand words
of main memory, memory-bounded heuristic search was an early research topic. The Graph
Traverser (Doran and Michie, 1966), one of the earliest search programs, commits to an
operator after searching best-first up to the memory limit. IDA∗ (Korf, 1985a, 1985b) was the
first widely used optimal, memory-bounded heuristic search algorithm, and a large number
of variants have been developed. An analysis of the efficiency of IDA∗ and of its difficulties
with real-valued heuristics appears in Patrick et al. (1992).
RBFS (Korf, 1993) is actually somewhat more complicated than the algorithm shown
in Figure 3.26, which is closer to an independently developed algorithm called iterative expansion (Russell, 1992). RBFS uses a lower bound as well as the upper bound; the two algorithms behave identically with admissible heuristics, but RBFS expands nodes in best-first

112

PARALLEL SEARCH

Chapter

3.

Solving Problems by Searching

order even with an inadmissible heuristic. The idea of keeping track of the best alternative
path appeared earlier in Bratko’s (1986) elegant Prolog implementation of A∗ and in the DTA∗
algorithm (Russell and Wefald, 1991). The latter work also discusses metalevel state spaces
and metalevel learning.
The MA∗ algorithm appeared in Chakrabarti et al. (1989). SMA∗ , or Simplified MA∗ ,
emerged from an attempt to implement MA∗ as a comparison algorithm for IE (Russell, 1992).
Kaindl and Khorsand (1994) have applied SMA∗ to produce a bidirectional search algorithm
that is substantially faster than previous algorithms. Korf and Zhang (2000) describe a divideand-conquer approach, and Zhou and Hansen (2002) introduce memory-bounded A∗ graph
search and a strategy for switching to breadth-first search to increase memory-efficiency
(Zhou and Hansen, 2006). Korf (1995) surveys memory-bounded search techniques.
The idea that admissible heuristics can be derived by problem relaxation appears in the
seminal paper by Held and Karp (1970), who used the minimum-spanning-tree heuristic to
solve the TSP. (See Exercise 3.30.)
The automation of the relaxation process was implemented successfully by Prieditis (1993), building on earlier work with Mostow (Mostow and Prieditis, 1989). Holte and
Hernadvolgyi (2001) describe more recent steps towards automating the process. The use of
pattern databases to derive admissible heuristics is due to Gasser (1995) and Culberson and
Schaeffer (1996, 1998); disjoint pattern databases are described by Korf and Felner (2002);
a similar method using symbolic patterns is due to Edelkamp (2009). Felner et al. (2007)
show how to compress pattern databases to save space. The probabilistic interpretation of
heuristics was investigated in depth by Pearl (1984) and Hansson and Mayer (1989).
By far the most comprehensive source on heuristics and heuristic search algorithms
is Pearl’s (1984) Heuristics text. This book provides especially good coverage of the wide
variety of offshoots and variations of A∗ , including rigorous proofs of their formal properties.
Kanal and Kumar (1988) present an anthology of important articles on heuristic search, and
Rayward-Smith et al. (1996) cover approaches from Operations Research. Papers about new
search algorithms—which, remarkably, continue to be discovered—appear in journals such
as Artificial Intelligence and Journal of the ACM.
The topic of parallel search algorithms was not covered in the chapter, partly because
it requires a lengthy discussion of parallel computer architectures. Parallel search became a
popular topic in the 1990s in both AI and theoretical computer science (Mahanti and Daniels,
1993; Grama and Kumar, 1995; Crauser et al., 1998) and is making a comeback in the era
of new multicore and cluster architectures (Ralphs et al., 2004; Korf and Schultze, 2005).
Also of increasing importance are search algorithms for very large graphs that require disk
storage (Korf, 2008).

E XERCISES
3.1

Explain why problem formulation must follow goal formulation.

3.2

Your goal is to navigate a robot out of a maze. The robot starts in the center of the maze

Exercises

113
facing north. You can turn the robot to face north, east, south, or west. You can direct the
robot to move forward a certain distance, although it will stop before hitting a wall.
a. Formulate this problem. How large is the state space?
b. In navigating a maze, the only place we need to turn is at the intersection of two or
more corridors. Reformulate this problem using this observation. How large is the state
space now?
c. From each point in the maze, we can move in any of the four directions until we reach a
turning point, and this is the only action we need to do. Reformulate the problem using
these actions. Do we need to keep track of the robot’s orientation now?
d. In our initial description of the problem we already abstracted from the real world,
restricting actions and removing details. List three such simplifications we made.
3.3 Suppose two friends live in different cities on a map, such as the Romania map shown
in Figure 3.2. On every turn, we can simultaneously move each friend to a neighboring city
on the map. The amount of time needed to move from city i to neighbor j is equal to the road
distance d(i, j) between the cities, but on each turn the friend that arrives first must wait until
the other one arrives (and calls the first on his/her cell phone) before the next turn can begin.
We want the two friends to meet as quickly as possible.
a. Write a detailed formulation for this search problem. (You will find it helpful to define
some formal notation here.)
b. Let D(i, j) be the straight-line distance between cities i and j. Which of the following
heuristic functions are admissible? (i) D(i, j); (ii) 2 · D(i, j); (iii) D(i, j)/2.
c. Are there completely connected maps for which no solution exists?
d. Are there maps in which all solutions require one friend to visit the same city twice?
3.4 Show that the 8-puzzle states are divided into two disjoint sets, such that any state is
reachable from any other state in the same set, while no state is reachable from any state in
the other set. (Hint: See Berlekamp et al. (1982).) Devise a procedure to decide which set a
given state is in, and explain why this is useful for generating random states.
3.5 Consider the n-queens problem using the “efficient”
incremental formulation given on
√
page 72. Explain why the state space has at least 3 n! states and estimate the largest n for
which exhaustive exploration is feasible. (Hint: Derive a lower bound on the branching factor
by considering the maximum number of squares that a queen can attack in any column.)
3.6 Give a complete problem formulation for each of the following. Choose a formulation
that is precise enough to be implemented.
a. Using only four colors, you have to color a planar map in such a way that no two
adjacent regions have the same color.
b. A 3-foot-tall monkey is in a room where some bananas are suspended from the 8-foot
ceiling. He would like to get the bananas. The room contains two stackable, movable,
climbable 3-foot-high crates.

114

Chapter

3.

Solving Problems by Searching

G

S
Figure 3.31

A scene with polygonal obstacles. S and G are the start and goal states.

c. You have a program that outputs the message “illegal input record” when fed a certain
file of input records. You know that processing of each record is independent of the
other records. You want to discover what record is illegal.
d. You have three jugs, measuring 12 gallons, 8 gallons, and 3 gallons, and a water faucet.
You can fill the jugs up or empty them out from one to another or onto the ground. You
need to measure out exactly one gallon.
3.7 Consider the problem of finding the shortest path between two points on a plane that has
convex polygonal obstacles as shown in Figure 3.31. This is an idealization of the problem
that a robot has to solve to navigate in a crowded environment.
a. Suppose the state space consists of all positions (x, y) in the plane. How many states
are there? How many paths are there to the goal?
b. Explain briefly why the shortest path from one polygon vertex to any other in the scene
must consist of straight-line segments joining some of the vertices of the polygons.
Define a good state space now. How large is this state space?
c. Define the necessary functions to implement the search problem, including an ACTIONS
function that takes a vertex as input and returns a set of vectors, each of which maps the
current vertex to one of the vertices that can be reached in a straight line. (Do not forget
the neighbors on the same polygon.) Use the straight-line distance for the heuristic
function.
d. Apply one or more of the algorithms in this chapter to solve a range of problems in the
domain, and comment on their performance.
3.8 On page 68, we said that we would not consider problems with negative path costs. In
this exercise, we explore this decision in more depth.
a. Suppose that actions can have arbitrarily large negative costs; explain why this possibility would force any optimal algorithm to explore the entire state space.

Exercises

115
b. Does it help if we insist that step costs must be greater than or equal to some negative
constant c? Consider both trees and graphs.
c. Suppose that a set of actions forms a loop in the state space such that executing the set in
some order results in no net change to the state. If all of these actions have negative cost,
what does this imply about the optimal behavior for an agent in such an environment?
d. One can easily imagine actions with high negative cost, even in domains such as route
finding. For example, some stretches of road might have such beautiful scenery as to
far outweigh the normal costs in terms of time and fuel. Explain, in precise terms,
within the context of state-space search, why humans do not drive around scenic loops
indefinitely, and explain how to define the state space and actions for route finding so
that artificial agents can also avoid looping.
e. Can you think of a real domain in which step costs are such as to cause looping?
3.9 The missionaries and cannibals problem is usually stated as follows. Three missionaries and three cannibals are on one side of a river, along with a boat that can hold one or
two people. Find a way to get everyone to the other side without ever leaving a group of missionaries in one place outnumbered by the cannibals in that place. This problem is famous in
AI because it was the subject of the first paper that approached problem formulation from an
analytical viewpoint (Amarel, 1968).
a. Formulate the problem precisely, making only those distinctions necessary to ensure a
valid solution. Draw a diagram of the complete state space.
b. Implement and solve the problem optimally using an appropriate search algorithm. Is it
a good idea to check for repeated states?
c. Why do you think people have a hard time solving this puzzle, given that the state space
is so simple?
3.10 Define in your own words the following terms: state, state space, search tree, search
node, goal, action, transition model, and branching factor.
3.11 What’s the difference between a world state, a state description, and a search node?
Why is this distinction useful?
3.12 An action such as Go(Sibiu) really consists of a long sequence of finer-grained actions:
turn on the car, release the brake, accelerate forward, etc. Having composite actions of this
kind reduces the number of steps in a solution sequence, thereby reducing the search time.
Suppose we take this to the logical extreme, by making super-composite actions out of every
possible sequence of Go actions. Then every problem instance is solved by a single supercomposite action, such as Go(Sibiu)Go(Rimnicu Vilcea)Go(Pitesti)Go(Bucharest). Explain
how search would work in this formulation. Is this a practical approach for speeding up
problem solving?
3.13 Prove that G RAPH -S EARCH satisfies the graph separation property illustrated in Figure 3.9. (Hint: Begin by showing that the property holds at the start, then show that if it holds
before an iteration of the algorithm, it holds afterwards.) Describe a search algorithm that
violates the property.

116

Chapter

x 12

x2

3.

Solving Problems by Searching

x2

x 16
Figure 3.32 The track pieces in a wooden railway set; each is labeled with the number of
copies in the set. Note that curved pieces and “fork” pieces (“switches” or “points”) can be
flipped over so they can curve in either direction. Each curve subtends 45 degrees.

3.14

Which of the following are true and which are false? Explain your answers.

a. Depth-first search always expands at least as many nodes as A∗ search with an admissible heuristic.
b. h(n) = 0 is an admissible heuristic for the 8-puzzle.
c. A∗ is of no use in robotics because percepts, states, and actions are continuous.
d. Breadth-first search is complete even if zero step costs are allowed.
e. Assume that a rook can move on a chessboard any number of squares in a straight line,
vertically or horizontally, but cannot jump over other pieces. Manhattan distance is an
admissible heuristic for the problem of moving the rook from square A to square B in
the smallest number of moves.
3.15 Consider a state space where the start state is number 1 and each state k has two
successors: numbers 2k and 2k + 1.
a. Draw the portion of the state space for states 1 to 15.
b. Suppose the goal state is 11. List the order in which nodes will be visited for breadthfirst search, depth-limited search with limit 3, and iterative deepening search.
c. How well would bidirectional search work on this problem? What is the branching
factor in each direction of the bidirectional search?
d. Does the answer to (c) suggest a reformulation of the problem that would allow you to
solve the problem of getting from state 1 to a given goal state with almost no search?
e. Call the action going from k to 2k Left, and the action going to 2k + 1 Right. Can you
find an algorithm that outputs the solution to this problem without any search at all?
3.16 A basic wooden railway set contains the pieces shown in Figure 3.32. The task is to
connect these pieces into a railway that has no overlapping tracks and no loose ends where a
train could run off onto the floor.
a. Suppose that the pieces fit together exactly with no slack. Give a precise formulation of
the task as a search problem.
b. Identify a suitable uninformed search algorithm for this task and explain your choice.
c. Explain why removing any one of the “fork” pieces makes the problem unsolvable.

Exercises

117
d. Give an upper bound on the total size of the state space defined by your formulation.
(Hint: think about the maximum branching factor for the construction process and the
maximum depth, ignoring the problem of overlapping pieces and loose ends. Begin by
pretending that every piece is unique.)
3.17 On page 90, we mentioned iterative lengthening search, an iterative analog of uniform cost search. The idea is to use increasing limits on path cost. If a node is generated
whose path cost exceeds the current limit, it is immediately discarded. For each new iteration, the limit is set to the lowest path cost of any node discarded in the previous iteration.
a. Show that this algorithm is optimal for general path costs.
b. Consider a uniform tree with branching factor b, solution depth d, and unit step costs.
How many iterations will iterative lengthening require?
c. Now consider step costs drawn from the continuous range [, 1], where 0 <  < 1. How
many iterations are required in the worst case?
d. Implement the algorithm and apply it to instances of the 8-puzzle and traveling salesperson problems. Compare the algorithm’s performance to that of uniform-cost search,
and comment on your results.
3.18 Describe a state space in which iterative deepening search performs much worse than
depth-first search (for example, O(n2 ) vs. O(n)).
3.19 Write a program that will take as input two Web page URLs and find a path of links
from one to the other. What is an appropriate search strategy? Is bidirectional search a good
idea? Could a search engine be used to implement a predecessor function?
3.20

Consider the vacuum-world problem defined in Figure 2.2.

a. Which of the algorithms defined in this chapter would be appropriate for this problem?
Should the algorithm use tree search or graph search?
b. Apply your chosen algorithm to compute an optimal sequence of actions for a 3 × 3
world whose initial state has dirt in the three top squares and the agent in the center.
c. Construct a search agent for the vacuum world, and evaluate its performance in a set of
3 × 3 worlds with probability 0.2 of dirt in each square. Include the search cost as well
as path cost in the performance measure, using a reasonable exchange rate.
d. Compare your best search agent with a simple randomized reflex agent that sucks if
there is dirt and otherwise moves randomly.
e. Consider what would happen if the world were enlarged to n × n. How does the performance of the search agent and of the reflex agent vary with n?
3.21

Prove each of the following statements, or give a counterexample:

a. Breadth-first search is a special case of uniform-cost search.
b. Depth-first search is a special case of best-first tree search.
c. Uniform-cost search is a special case of A∗ search.

118

Chapter

3.

Solving Problems by Searching

3.22 Compare the performance of A∗ and RBFS on a set of randomly generated problems
in the 8-puzzle (with Manhattan distance) and TSP (with MST—see Exercise 3.30) domains.
Discuss your results. What happens to the performance of RBFS when a small random number is added to the heuristic values in the 8-puzzle domain?
3.23 Trace the operation of A∗ search applied to the problem of getting to Bucharest from
Lugoj using the straight-line distance heuristic. That is, show the sequence of nodes that the
algorithm will consider and the f , g, and h score for each node.
3.24 Devise a state space in which A∗ using G RAPH -S EARCH returns a suboptimal solution
with an h(n) function that is admissible but inconsistent.
HEURISTIC PATH
ALGORITHM

3.25 The heuristic path algorithm (Pohl, 1977) is a best-first search in which the evaluation function is f (n) = (2 − w)g(n) + wh(n). For what values of w is this complete?
For what values is it optimal, assuming that h is admissible? What kind of search does this
perform for w = 0, w = 1, and w = 2?
3.26 Consider the unbounded version of the regular 2D grid shown in Figure 3.9. The start
state is at the origin, (0,0), and the goal state is at (x, y).
a. What is the branching factor b in this state space?
b. How many distinct states are there at depth k (for k > 0)?
c. What is the maximum number of nodes expanded by breadth-first tree search?
d. What is the maximum number of nodes expanded by breadth-first graph search?
e. Is h = |u − x| + |v − y| an admissible heuristic for a state at (u, v)? Explain.
f. How many nodes are expanded by A∗ graph search using h?
g. Does h remain admissible if some links are removed?
h. Does h remain admissible if some links are added between nonadjacent states?
3.27 n vehicles occupy squares (1, 1) through (n, 1) (i.e., the bottom row) of an n × n grid.
The vehicles must be moved to the top row but in reverse order; so the vehicle i that starts in
(i, 1) must end up in (n − i + 1, n). On each time step, every one of the n vehicles can move
one square up, down, left, or right, or stay put; but if a vehicle stays put, one other adjacent
vehicle (but not more than one) can hop over it. Two vehicles cannot occupy the same square.
a. Calculate the size of the state space as a function of n.
b. Calculate the branching factor as a function of n.
c. Suppose that vehicle i is at (xi , yi ); write a nontrivial admissible heuristic hi for the
number of moves it will require to get to its goal location (n − i + 1, n), assuming no
other vehicles are on the grid.
d. Which of the following heuristics are admissible for the problem of moving all n vehicles to their destinations? Explain.
n
(i)
i = 1 hi .
(ii) max{h1 , . . . , hn }.
(iii) min{h1 , . . . , hn }.

Exercises

119
3.28 Invent a heuristic function for the 8-puzzle that sometimes overestimates, and show
how it can lead to a suboptimal solution on a particular problem. (You can use a computer to
help if you want.) Prove that if h never overestimates by more than c, A∗ using h returns a
solution whose cost exceeds that of the optimal solution by no more than c.
3.29 Prove that if a heuristic is consistent, it must be admissible. Construct an admissible
heuristic that is not consistent.
3.30 The traveling salesperson problem (TSP) can be solved with the minimum-spanningtree (MST) heuristic, which estimates the cost of completing a tour, given that a partial tour
has already been constructed. The MST cost of a set of cities is the smallest sum of the link
costs of any tree that connects all the cities.
a. Show how this heuristic can be derived from a relaxed version of the TSP.
b. Show that the MST heuristic dominates straight-line distance.
c. Write a problem generator for instances of the TSP where cities are represented by
random points in the unit square.
d. Find an efficient algorithm in the literature for constructing the MST, and use it with A∗
graph search to solve instances of the TSP.
3.31 On page 105, we defined the relaxation of the 8-puzzle in which a tile can move from
square A to square B if B is blank. The exact solution of this problem defines Gaschnig’s
heuristic (Gaschnig, 1979). Explain why Gaschnig’s heuristic is at least as accurate as h1
(misplaced tiles), and show cases where it is more accurate than both h1 and h2 (Manhattan
distance). Explain how to calculate Gaschnig’s heuristic efficiently.
3.32 We gave two simple heuristics for the 8-puzzle: Manhattan distance and misplaced
tiles. Several heuristics in the literature purport to improve on this—see, for example, Nilsson (1971), Mostow and Prieditis (1989), and Hansson et al. (1992). Test these claims by
implementing the heuristics and comparing the performance of the resulting algorithms.

4

BEYOND CLASSICAL
SEARCH

In which we relax the simplifying assumptions of the previous chapter, thereby
getting closer to the real world.

Chapter 3 addressed a single category of problems: observable, deterministic, known environments where the solution is a sequence of actions. In this chapter, we look at what happens
when these assumptions are relaxed. We begin with a fairly simple case: Sections 4.1 and 4.2
cover algorithms that perform purely local search in the state space, evaluating and modifying one or more current states rather than systematically exploring paths from an initial state.
These algorithms are suitable for problems in which all that matters is the solution state, not
the path cost to reach it. The family of local search algorithms includes methods inspired by
statistical physics (simulated annealing) and evolutionary biology (genetic algorithms).
Then, in Sections 4.3–4.4, we examine what happens when we relax the assumptions
of determinism and observability. The key idea is that if an agent cannot predict exactly what
percept it will receive, then it will need to consider what to do under each contingency that
its percepts may reveal. With partial observability, the agent will also need to keep track of
the states it might be in.
Finally, Section 4.5 investigates online search, in which the agent is faced with a state
space that is initially unknown and must be explored.

4.1

L OCAL S EARCH A LGORITHMS AND O PTIMIZATION P ROBLEMS
The search algorithms that we have seen so far are designed to explore search spaces systematically. This systematicity is achieved by keeping one or more paths in memory and by
recording which alternatives have been explored at each point along the path. When a goal is
found, the path to that goal also constitutes a solution to the problem. In many problems, however, the path to the goal is irrelevant. For example, in the 8-queens problem (see page 71),
what matters is the final configuration of queens, not the order in which they are added. The
same general property holds for many important applications such as integrated-circuit design, factory-floor layout, job-shop scheduling, automatic programming, telecommunications
network optimization, vehicle routing, and portfolio management.
120

Section 4.1.

LOCAL SEARCH
CURRENT NODE

OPTIMIZATION
PROBLEM
OBJECTIVE
FUNCTION

STATE-SPACE
LANDSCAPE

GLOBAL MINIMUM
GLOBAL MAXIMUM

Local Search Algorithms and Optimization Problems

121

If the path to the goal does not matter, we might consider a different class of algorithms, ones that do not worry about paths at all. Local search algorithms operate using
a single current node (rather than multiple paths) and generally move only to neighbors
of that node. Typically, the paths followed by the search are not retained. Although local
search algorithms are not systematic, they have two key advantages: (1) they use very little
memory—usually a constant amount; and (2) they can often find reasonable solutions in large
or infinite (continuous) state spaces for which systematic algorithms are unsuitable.
In addition to finding goals, local search algorithms are useful for solving pure optimization problems, in which the aim is to find the best state according to an objective
function. Many optimization problems do not fit the “standard” search model introduced in
Chapter 3. For example, nature provides an objective function—reproductive fitness—that
Darwinian evolution could be seen as attempting to optimize, but there is no “goal test” and
no “path cost” for this problem.
To understand local search, we find it useful to consider the state-space landscape (as
in Figure 4.1). A landscape has both “location” (defined by the state) and “elevation” (defined
by the value of the heuristic cost function or objective function). If elevation corresponds to
cost, then the aim is to find the lowest valley—a global minimum; if elevation corresponds
to an objective function, then the aim is to find the highest peak—a global maximum. (You
can convert from one to the other just by inserting a minus sign.) Local search algorithms
explore this landscape. A complete local search algorithm always finds a goal if one exists;
an optimal algorithm always finds a global minimum/maximum.

objective function

global maximum

shoulder
local maximum
“flat” local maximum

state space
current
state

Figure 4.1 A one-dimensional state-space landscape in which elevation corresponds to the
objective function. The aim is to find the global maximum. Hill-climbing search modifies
the current state to try to improve it, as shown by the arrow. The various topographic features
are defined in the text.

122

Chapter 4.

Beyond Classical Search

function H ILL -C LIMBING( problem) returns a state that is a local maximum
current ← M AKE -N ODE(problem.I NITIAL -S TATE)
loop do
neighbor ← a highest-valued successor of current
if neighbor.VALUE ≤ current.VALUE then return current.S TATE
current ← neighbor
Figure 4.2 The hill-climbing search algorithm, which is the most basic local search technique. At each step the current node is replaced by the best neighbor; in this version, that
means the neighbor with the highest VALUE, but if a heuristic cost estimate h is used, we
would find the neighbor with the lowest h.

4.1.1 Hill-climbing search
HILL CLIMBING
STEEPEST ASCENT

GREEDY LOCAL
SEARCH

LOCAL MAXIMUM

The hill-climbing search algorithm (steepest-ascent version) is shown in Figure 4.2. It is
simply a loop that continually moves in the direction of increasing value—that is, uphill. It
terminates when it reaches a “peak” where no neighbor has a higher value. The algorithm
does not maintain a search tree, so the data structure for the current node need only record
the state and the value of the objective function. Hill climbing does not look ahead beyond
the immediate neighbors of the current state. This resembles trying to find the top of Mount
Everest in a thick fog while suffering from amnesia.
To illustrate hill climbing, we will use the 8-queens problem introduced on page 71.
Local search algorithms typically use a complete-state formulation, where each state has
8 queens on the board, one per column. The successors of a state are all possible states
generated by moving a single queen to another square in the same column (so each state has
8 × 7 = 56 successors). The heuristic cost function h is the number of pairs of queens that
are attacking each other, either directly or indirectly. The global minimum of this function
is zero, which occurs only at perfect solutions. Figure 4.3(a) shows a state with h = 17. The
figure also shows the values of all its successors, with the best successors having h = 12.
Hill-climbing algorithms typically choose randomly among the set of best successors if there
is more than one.
Hill climbing is sometimes called greedy local search because it grabs a good neighbor
state without thinking ahead about where to go next. Although greed is considered one of the
seven deadly sins, it turns out that greedy algorithms often perform quite well. Hill climbing
often makes rapid progress toward a solution because it is usually quite easy to improve a bad
state. For example, from the state in Figure 4.3(a), it takes just five steps to reach the state
in Figure 4.3(b), which has h = 1 and is very nearly a solution. Unfortunately, hill climbing
often gets stuck for the following reasons:
• Local maxima: a local maximum is a peak that is higher than each of its neighboring
states but lower than the global maximum. Hill-climbing algorithms that reach the
vicinity of a local maximum will be drawn upward toward the peak but will then be
stuck with nowhere else to go. Figure 4.1 illustrates the problem schematically. More

Section 4.1.

Local Search Algorithms and Optimization Problems

123

18 12 14 13 13 12 14 14
14 16 13 15 12 14 12 16
14 12 18 13 15 12 14 14
13 16 13 16

15 14 14

14 16 16

14 17 15
17
18 14

16 18 15
15 15 14

15
16

14 14 13 17 12 14 12 18

(a)

(b)

Figure 4.3 (a) An 8-queens state with heuristic cost estimate h = 17, showing the value of
h for each possible successor obtained by moving a queen within its column. The best moves
are marked. (b) A local minimum in the 8-queens state space; the state has h = 1 but every
successor has a higher cost.

RIDGE

PLATEAU
SHOULDER

SIDEWAYS MOVE

concretely, the state in Figure 4.3(b) is a local maximum (i.e., a local minimum for the
cost h); every move of a single queen makes the situation worse.
• Ridges: a ridge is shown in Figure 4.4. Ridges result in a sequence of local maxima
that is very difficult for greedy algorithms to navigate.
• Plateaux: a plateau is a flat area of the state-space landscape. It can be a flat local
maximum, from which no uphill exit exists, or a shoulder, from which progress is
possible. (See Figure 4.1.) A hill-climbing search might get lost on the plateau.
In each case, the algorithm reaches a point at which no progress is being made. Starting from
a randomly generated 8-queens state, steepest-ascent hill climbing gets stuck 86% of the time,
solving only 14% of problem instances. It works quickly, taking just 4 steps on average when
it succeeds and 3 when it gets stuck—not bad for a state space with 88 ≈ 17 million states.
The algorithm in Figure 4.2 halts if it reaches a plateau where the best successor has
the same value as the current state. Might it not be a good idea to keep going—to allow a
sideways move in the hope that the plateau is really a shoulder, as shown in Figure 4.1? The
answer is usually yes, but we must take care. If we always allow sideways moves when there
are no uphill moves, an infinite loop will occur whenever the algorithm reaches a flat local
maximum that is not a shoulder. One common solution is to put a limit on the number of consecutive sideways moves allowed. For example, we could allow up to, say, 100 consecutive
sideways moves in the 8-queens problem. This raises the percentage of problem instances
solved by hill climbing from 14% to 94%. Success comes at a cost: the algorithm averages
roughly 21 steps for each successful instance and 64 for each failure.

124

Chapter 4.

Beyond Classical Search

Figure 4.4 Illustration of why ridges cause difficulties for hill climbing. The grid of states
(dark circles) is superimposed on a ridge rising from left to right, creating a sequence of local
maxima that are not directly connected to each other. From each local maximum, all the
available actions point downhill.
STOCHASTIC HILL
CLIMBING

FIRST-CHOICE HILL
CLIMBING

RANDOM-RESTART
HILL CLIMBING

Many variants of hill climbing have been invented. Stochastic hill climbing chooses at
random from among the uphill moves; the probability of selection can vary with the steepness
of the uphill move. This usually converges more slowly than steepest ascent, but in some
state landscapes, it finds better solutions. First-choice hill climbing implements stochastic
hill climbing by generating successors randomly until one is generated that is better than the
current state. This is a good strategy when a state has many (e.g., thousands) of successors.
The hill-climbing algorithms described so far are incomplete—they often fail to find
a goal when one exists because they can get stuck on local maxima. Random-restart hill
climbing adopts the well-known adage, “If at first you don’t succeed, try, try again.” It conducts a series of hill-climbing searches from randomly generated initial states,1 until a goal
is found. It is trivially complete with probability approaching 1, because it will eventually
generate a goal state as the initial state. If each hill-climbing search has a probability p of
success, then the expected number of restarts required is 1/p. For 8-queens instances with
no sideways moves allowed, p ≈ 0.14, so we need roughly 7 iterations to find a goal (6 failures and 1 success). The expected number of steps is the cost of one successful iteration plus
(1−p)/p times the cost of failure, or roughly 22 steps in all. When we allow sideways moves,
1/0.94 ≈ 1.06 iterations are needed on average and (1 × 21) + (0.06/0.94) × 64 ≈ 25 steps.
For 8-queens, then, random-restart hill climbing is very effective indeed. Even for three million queens, the approach can find solutions in under a minute.2
1

Generating a random state from an implicitly specified state space can be a hard problem in itself.
Luby et al. (1993) prove that it is best, in some cases, to restart a randomized search algorithm after a particular,
fixed amount of time and that this can be much more efficient than letting each search continue indefinitely.
Disallowing or limiting the number of sideways moves is an example of this idea.
2

Section 4.1.

Local Search Algorithms and Optimization Problems

125

The success of hill climbing depends very much on the shape of the state-space landscape: if there are few local maxima and plateaux, random-restart hill climbing will find a
good solution very quickly. On the other hand, many real problems have a landscape that
looks more like a widely scattered family of balding porcupines on a flat floor, with miniature
porcupines living on the tip of each porcupine needle, ad infinitum. NP-hard problems typically have an exponential number of local maxima to get stuck on. Despite this, a reasonably
good local maximum can often be found after a small number of restarts.

4.1.2 Simulated annealing

SIMULATED
ANNEALING

GRADIENT DESCENT

A hill-climbing algorithm that never makes “downhill” moves toward states with lower value
(or higher cost) is guaranteed to be incomplete, because it can get stuck on a local maximum. In contrast, a purely random walk—that is, moving to a successor chosen uniformly
at random from the set of successors—is complete but extremely inefficient. Therefore, it
seems reasonable to try to combine hill climbing with a random walk in some way that yields
both efficiency and completeness. Simulated annealing is such an algorithm. In metallurgy,
annealing is the process used to temper or harden metals and glass by heating them to a
high temperature and then gradually cooling them, thus allowing the material to reach a lowenergy crystalline state. To explain simulated annealing, we switch our point of view from
hill climbing to gradient descent (i.e., minimizing cost) and imagine the task of getting a
ping-pong ball into the deepest crevice in a bumpy surface. If we just let the ball roll, it will
come to rest at a local minimum. If we shake the surface, we can bounce the ball out of the
local minimum. The trick is to shake just hard enough to bounce the ball out of local minima but not hard enough to dislodge it from the global minimum. The simulated-annealing
solution is to start by shaking hard (i.e., at a high temperature) and then gradually reduce the
intensity of the shaking (i.e., lower the temperature).
The innermost loop of the simulated-annealing algorithm (Figure 4.5) is quite similar to
hill climbing. Instead of picking the best move, however, it picks a random move. If the move
improves the situation, it is always accepted. Otherwise, the algorithm accepts the move with
some probability less than 1. The probability decreases exponentially with the “badness” of
the move—the amount ΔE by which the evaluation is worsened. The probability also decreases as the “temperature” T goes down: “bad” moves are more likely to be allowed at the
start when T is high, and they become more unlikely as T decreases. If the schedule lowers
T slowly enough, the algorithm will find a global optimum with probability approaching 1.
Simulated annealing was first used extensively to solve VLSI layout problems in the
early 1980s. It has been applied widely to factory scheduling and other large-scale optimization tasks. In Exercise 4.4, you are asked to compare its performance to that of random-restart
hill climbing on the 8-queens puzzle.

4.1.3 Local beam search
LOCAL BEAM
SEARCH

Keeping just one node in memory might seem to be an extreme reaction to the problem of
memory limitations. The local beam search algorithm3 keeps track of k states rather than
3

Local beam search is an adaptation of beam search, which is a path-based algorithm.

126

Chapter 4.

Beyond Classical Search

function S IMULATED -A NNEALING( problem, schedule) returns a solution state
inputs: problem, a problem
schedule, a mapping from time to “temperature”
current ← M AKE -N ODE(problem.I NITIAL -S TATE)
for t = 1 to ∞ do
T ← schedule(t )
if T = 0 then return current
next ← a randomly selected successor of current
ΔE ← next.VALUE – current.VALUE
if ΔE > 0 then current ← next
else current ← next only with probability eΔE/T
Figure 4.5 The simulated annealing algorithm, a version of stochastic hill climbing where
some downhill moves are allowed. Downhill moves are accepted readily early in the annealing schedule and then less often as time goes on. The schedule input determines the value of
the temperature T as a function of time.

STOCHASTIC BEAM
SEARCH

just one. It begins with k randomly generated states. At each step, all the successors of all k
states are generated. If any one is a goal, the algorithm halts. Otherwise, it selects the k best
successors from the complete list and repeats.
At first sight, a local beam search with k states might seem to be nothing more than
running k random restarts in parallel instead of in sequence. In fact, the two algorithms
are quite different. In a random-restart search, each search process runs independently of
the others. In a local beam search, useful information is passed among the parallel search
threads. In effect, the states that generate the best successors say to the others, “Come over
here, the grass is greener!” The algorithm quickly abandons unfruitful searches and moves
its resources to where the most progress is being made.
In its simplest form, local beam search can suffer from a lack of diversity among the
k states—they can quickly become concentrated in a small region of the state space, making
the search little more than an expensive version of hill climbing. A variant called stochastic
beam search, analogous to stochastic hill climbing, helps alleviate this problem. Instead
of choosing the best k from the the pool of candidate successors, stochastic beam search
chooses k successors at random, with the probability of choosing a given successor being
an increasing function of its value. Stochastic beam search bears some resemblance to the
process of natural selection, whereby the “successors” (offspring) of a “state” (organism)
populate the next generation according to its “value” (fitness).

4.1.4 Genetic algorithms
GENETIC
ALGORITHM

A genetic algorithm (or GA) is a variant of stochastic beam search in which successor states
are generated by combining two parent states rather than by modifying a single state. The
analogy to natural selection is the same as in stochastic beam search, except that now we are
dealing with sexual rather than asexual reproduction.

Section 4.1.

Local Search Algorithms and Optimization Problems

127

24748552

24 31%

32752411

32748552

32748152

32752411

23 29%

24748552

24752411

24752411

24415124

20 26%

32752411

32752124

32252124

32543213

11 14%

24415124

24415411

24415417

(a)
Initial Population

(b)
Fitness Function

(c)
Selection

(d)
Crossover

(e)
Mutation

Figure 4.6 The genetic algorithm, illustrated for digit strings representing 8-queens states.
The initial population in (a) is ranked by the fitness function in (b), resulting in pairs for
mating in (c). They produce offspring in (d), which are subject to mutation in (e).

+

=

Figure 4.7 The 8-queens states corresponding to the first two parents in Figure 4.6(c) and
the first offspring in Figure 4.6(d). The shaded columns are lost in the crossover step and the
unshaded columns are retained.

POPULATION
INDIVIDUAL

FITNESS FUNCTION

Like beam searches, GAs begin with a set of k randomly generated states, called the
population. Each state, or individual, is represented as a string over a finite alphabet—most
commonly, a string of 0s and 1s. For example, an 8-queens state must specify the positions of
8 queens, each in a column of 8 squares, and so requires 8 × log2 8 = 24 bits. Alternatively,
the state could be represented as 8 digits, each in the range from 1 to 8. (We demonstrate later
that the two encodings behave differently.) Figure 4.6(a) shows a population of four 8-digit
strings representing 8-queens states.
The production of the next generation of states is shown in Figure 4.6(b)–(e). In (b),
each state is rated by the objective function, or (in GA terminology) the fitness function. A
fitness function should return higher values for better states, so, for the 8-queens problem
we use the number of nonattacking pairs of queens, which has a value of 28 for a solution.
The values of the four states are 24, 23, 20, and 11. In this particular variant of the genetic
algorithm, the probability of being chosen for reproducing is directly proportional to the
fitness score, and the percentages are shown next to the raw scores.
In (c), two pairs are selected at random for reproduction, in accordance with the prob-

128

CROSSOVER

MUTATION

SCHEMA

INSTANCE

Chapter 4.

Beyond Classical Search

abilities in (b). Notice that one individual is selected twice and one not at all.4 For each
pair to be mated, a crossover point is chosen randomly from the positions in the string. In
Figure 4.6, the crossover points are after the third digit in the first pair and after the fifth digit
in the second pair.5
In (d), the offspring themselves are created by crossing over the parent strings at the
crossover point. For example, the first child of the first pair gets the first three digits from the
first parent and the remaining digits from the second parent, whereas the second child gets
the first three digits from the second parent and the rest from the first parent. The 8-queens
states involved in this reproduction step are shown in Figure 4.7. The example shows that
when two parent states are quite different, the crossover operation can produce a state that is
a long way from either parent state. It is often the case that the population is quite diverse
early on in the process, so crossover (like simulated annealing) frequently takes large steps in
the state space early in the search process and smaller steps later on when most individuals
are quite similar.
Finally, in (e), each location is subject to random mutation with a small independent
probability. One digit was mutated in the first, third, and fourth offspring. In the 8-queens
problem, this corresponds to choosing a queen at random and moving it to a random square
in its column. Figure 4.8 describes an algorithm that implements all these steps.
Like stochastic beam search, genetic algorithms combine an uphill tendency with random exploration and exchange of information among parallel search threads. The primary
advantage, if any, of genetic algorithms comes from the crossover operation. Yet it can be
shown mathematically that, if the positions of the genetic code are permuted initially in a
random order, crossover conveys no advantage. Intuitively, the advantage comes from the
ability of crossover to combine large blocks of letters that have evolved independently to perform useful functions, thus raising the level of granularity at which the search operates. For
example, it could be that putting the first three queens in positions 2, 4, and 6 (where they do
not attack each other) constitutes a useful block that can be combined with other blocks to
construct a solution.
The theory of genetic algorithms explains how this works using the idea of a schema,
which is a substring in which some of the positions can be left unspecified. For example,
the schema 246***** describes all 8-queens states in which the first three queens are in
positions 2, 4, and 6, respectively. Strings that match the schema (such as 24613578) are
called instances of the schema. It can be shown that if the average fitness of the instances of
a schema is above the mean, then the number of instances of the schema within the population
will grow over time. Clearly, this effect is unlikely to be significant if adjacent bits are totally
unrelated to each other, because then there will be few contiguous blocks that provide a
consistent benefit. Genetic algorithms work best when schemata correspond to meaningful
components of a solution. For example, if the string is a representation of an antenna, then the
schemata may represent components of the antenna, such as reflectors and deflectors. A good
4 There are many variants of this selection rule. The method of culling, in which all individuals below a given
threshold are discarded, can be shown to converge faster than the random version (Baum et al., 1995).
5 It is here that the encoding matters. If a 24-bit encoding is used instead of 8 digits, then the crossover point
has a 2/3 chance of being in the middle of a digit, which results in an essentially arbitrary mutation of that digit.

Section 4.2.

Local Search in Continuous Spaces

129

function G ENETIC -A LGORITHM( population , F ITNESS -F N) returns an individual
inputs: population , a set of individuals
F ITNESS -F N, a function that measures the fitness of an individual
repeat
new population ← empty set
for i = 1 to S IZE( population) do
x ← R ANDOM -S ELECTION ( population, F ITNESS -F N )
y ← R ANDOM -S ELECTION ( population , F ITNESS -F N)
child ← R EPRODUCE (x , y)
if (small random probability) then child ← M UTATE(child )
add child to new population
population ← new population
until some individual is fit enough, or enough time has elapsed
return the best individual in population , according to F ITNESS -F N
function R EPRODUCE (x , y) returns an individual
inputs: x , y, parent individuals
n ← L ENGTH(x ); c ← random number from 1 to n
return A PPEND(S UBSTRING(x , 1, c), S UBSTRING(y, c + 1, n))
Figure 4.8 A genetic algorithm. The algorithm is the same as the one diagrammed in
Figure 4.6, with one variation: in this more popular version, each mating of two parents
produces only one offspring, not two.

component is likely to be good in a variety of different designs. This suggests that successful
use of genetic algorithms requires careful engineering of the representation.
In practice, genetic algorithms have had a widespread impact on optimization problems,
such as circuit layout and job-shop scheduling. At present, it is not clear whether the appeal
of genetic algorithms arises from their performance or from their æsthetically pleasing origins
in the theory of evolution. Much work remains to be done to identify the conditions under
which genetic algorithms perform well.

4.2

L OCAL S EARCH IN C ONTINUOUS S PACES
In Chapter 2, we explained the distinction between discrete and continuous environments,
pointing out that most real-world environments are continuous. Yet none of the algorithms
we have described (except for first-choice hill climbing and simulated annealing) can handle
continuous state and action spaces, because they have infinite branching factors. This section
provides a very brief introduction to some local search techniques for finding optimal solutions in continuous spaces. The literature on this topic is vast; many of the basic techniques

130

Chapter 4.

Beyond Classical Search

E VOLUTION AND S EARCH
The theory of evolution was developed in Charles Darwin’s On the Origin of
Species by Means of Natural Selection (1859) and independently by Alfred Russel
Wallace (1858). The central idea is simple: variations occur in reproduction and
will be preserved in successive generations approximately in proportion to their
effect on reproductive fitness.
Darwin’s theory was developed with no knowledge of how the traits of organisms can be inherited and modified. The probabilistic laws governing these processes were first identified by Gregor Mendel (1866), a monk who experimented
with sweet peas. Much later, Watson and Crick (1953) identified the structure of the
DNA molecule and its alphabet, AGTC (adenine, guanine, thymine, cytosine). In
the standard model, variation occurs both by point mutations in the letter sequence
and by “crossover” (in which the DNA of an offspring is generated by combining
long sections of DNA from each parent).
The analogy to local search algorithms has already been described; the principal difference between stochastic beam search and evolution is the use of sexual reproduction, wherein successors are generated from multiple organisms rather than
just one. The actual mechanisms of evolution are, however, far richer than most
genetic algorithms allow. For example, mutations can involve reversals, duplications, and movement of large chunks of DNA; some viruses borrow DNA from one
organism and insert it in another; and there are transposable genes that do nothing
but copy themselves many thousands of times within the genome. There are even
genes that poison cells from potential mates that do not carry the gene, thereby increasing their own chances of replication. Most important is the fact that the genes
themselves encode the mechanisms whereby the genome is reproduced and translated into an organism. In genetic algorithms, those mechanisms are a separate
program that is not represented within the strings being manipulated.
Darwinian evolution may appear inefficient, having generated blindly some
45
10 or so organisms without improving its search heuristics one iota. Fifty
years before Darwin, however, the otherwise great French naturalist Jean Lamarck
(1809) proposed a theory of evolution whereby traits acquired by adaptation during an organism’s lifetime would be passed on to its offspring. Such a process
would be effective but does not seem to occur in nature. Much later, James Baldwin (1896) proposed a superficially similar theory: that behavior learned during an
organism’s lifetime could accelerate the rate of evolution. Unlike Lamarck’s, Baldwin’s theory is entirely consistent with Darwinian evolution because it relies on selection pressures operating on individuals that have found local optima among the
set of possible behaviors allowed by their genetic makeup. Computer simulations
confirm that the “Baldwin effect” is real, once “ordinary” evolution has created
organisms whose internal performance measure correlates with actual fitness.

Section 4.2.

VARIABLE

Local Search in Continuous Spaces

131

originated in the 17th century, after the development of calculus by Newton and Leibniz.6 We
find uses for these techniques at several places in the book, including the chapters on learning,
vision, and robotics.
We begin with an example. Suppose we want to place three new airports anywhere
in Romania, such that the sum of squared distances from each city on the map (Figure 3.2)
to its nearest airport is minimized. The state space is then defined by the coordinates of
the airports: (x1 , y1 ), (x2 , y2 ), and (x3 , y3 ). This is a six-dimensional space; we also say
that states are defined by six variables. (In general, states are defined by an n-dimensional
vector of variables, x.) Moving around in this space corresponds to moving one or more of
the airports on the map. The objective function f (x1 , y1 , x2 , y2 , x3 , y3 ) is relatively easy to
compute for any particular state once we compute the closest cities. Let Ci be the set of
cities whose closest airport (in the current state) is airport i. Then, in the neighborhood of the
current state, where the Ci s remain constant, we have
3

(xi − xc )2 + (yi − yc )2 .

f (x1 , y1 , x2 , y2 , x3 , y3 ) =

(4.1)

i = 1 c∈Ci

DISCRETIZATION

GRADIENT

This expression is correct locally, but not globally because the sets Ci are (discontinuous)
functions of the state.
One way to avoid continuous problems is simply to discretize the neighborhood of each
state. For example, we can move only one airport at a time in either the x or y direction by
a fixed amount ±δ. With 6 variables, this gives 12 possible successors for each state. We
can then apply any of the local search algorithms described previously. We could also apply stochastic hill climbing and simulated annealing directly, without discretizing the space.
These algorithms choose successors randomly, which can be done by generating random vectors of length δ.
Many methods attempt to use the gradient of the landscape to find a maximum. The
gradient of the objective function is a vector ∇f that gives the magnitude and direction of the
steepest slope. For our problem, we have

∂f ∂f ∂f ∂f ∂f ∂f
∇f =
.
,
,
,
,
,
∂x1 ∂y1 ∂x2 ∂y2 ∂x3 ∂y3
In some cases, we can find a maximum by solving the equation ∇f = 0. (This could be done,
for example, if we were placing just one airport; the solution is the arithmetic mean of all the
cities’ coordinates.) In many cases, however, this equation cannot be solved in closed form.
For example, with three airports, the expression for the gradient depends on what cities are
closest to each airport in the current state. This means we can compute the gradient locally
(but not globally); for example,
∂f
=2
∂x1

(xi − xc ) .

(4.2)

c∈C1

Given a locally correct expression for the gradient, we can perform steepest-ascent hill climb6

A basic knowledge of multivariate calculus and vector arithmetic is useful for reading this section.

132

Chapter 4.

Beyond Classical Search

ing by updating the current state according to the formula
x ← x + α∇f (x) ,
STEP SIZE

EMPIRICAL
GRADIENT

LINE SEARCH

NEWTON–RAPHSON

where α is a small constant often called the step size. In other cases, the objective function
might not be available in a differentiable form at all—for example, the value of a particular set
of airport locations might be determined by running some large-scale economic simulation
package. In those cases, we can calculate a so-called empirical gradient by evaluating the
response to small increments and decrements in each coordinate. Empirical gradient search
is the same as steepest-ascent hill climbing in a discretized version of the state space.
Hidden beneath the phrase “α is a small constant” lies a huge variety of methods for
adjusting α. The basic problem is that, if α is too small, too many steps are needed; if α
is too large, the search could overshoot the maximum. The technique of line search tries to
overcome this dilemma by extending the current gradient direction—usually by repeatedly
doubling α—until f starts to decrease again. The point at which this occurs becomes the new
current state. There are several schools of thought about how the new direction should be
chosen at this point.
For many problems, the most effective algorithm is the venerable Newton–Raphson
method. This is a general technique for finding roots of functions—that is, solving equations
of the form g(x) = 0. It works by computing a new estimate for the root x according to
Newton’s formula
x ← x − g(x)/g (x) .
To find a maximum or minimum of f , we need to find x such that the gradient is zero (i.e.,
∇f (x) = 0). Thus, g(x) in Newton’s formula becomes ∇f (x), and the update equation can
be written in matrix–vector form as
x ← x − H−1
f (x)∇f (x) ,

HESSIAN

CONSTRAINED
OPTIMIZATION

where Hf (x) is the Hessian matrix of second derivatives, whose elements Hij are given
by ∂ 2 f /∂xi ∂xj . For our airport example, we can see from Equation (4.2) that Hf (x) is
particularly simple: the off-diagonal elements are zero and the diagonal elements for airport
i are just twice the number of cities in Ci . A moment’s calculation shows that one step of
the update moves airport i directly to the centroid of Ci , which is the minimum of the local
expression for f from Equation (4.1).7 For high-dimensional problems, however, computing
the n2 entries of the Hessian and inverting it may be expensive, so many approximate versions
of the Newton–Raphson method have been developed.
Local search methods suffer from local maxima, ridges, and plateaux in continuous
state spaces just as much as in discrete spaces. Random restarts and simulated annealing can
be used and are often helpful. High-dimensional continuous spaces are, however, big places
in which it is easy to get lost.
A final topic with which a passing acquaintance is useful is constrained optimization.
An optimization problem is constrained if solutions must satisfy some hard constraints on the
values of the variables. For example, in our airport-siting problem, we might constrain sites
7

In general, the Newton–Raphson update can be seen as fitting a quadratic surface to f at x and then moving
directly to the minimum of that surface—which is also the minimum of f if f is quadratic.

Section 4.3.

LINEAR
PROGRAMMING
CONVEX SET

CONVEX
OPTIMIZATION

4.3

133

to be inside Romania and on dry land (rather than in the middle of lakes). The difficulty of
constrained optimization problems depends on the nature of the constraints and the objective
function. The best-known category is that of linear programming problems, in which constraints must be linear inequalities forming a convex set 8 and the objective function is also
linear. The time complexity of linear programming is polynomial in the number of variables.
Linear programming is probably the most widely studied and broadly useful class of
optimization problems. It is a special case of the more general problem of convex optimization, which allows the constraint region to be any convex region and the objective to
be any function that is convex within the constraint region. Under certain conditions, convex
optimization problems are also polynomially solvable and may be feasible in practice with
thousands of variables. Several important problems in machine learning and control theory
can be formulated as convex optimization problems (see Chapter 20).

S EARCHING WITH N ONDETERMINISTIC ACTIONS

CONTINGENCY PLAN
STRATEGY

Searching with Nondeterministic Actions

In Chapter 3, we assumed that the environment is fully observable and deterministic and that
the agent knows what the effects of each action are. Therefore, the agent can calculate exactly
which state results from any sequence of actions and always knows which state it is in. Its
percepts provide no new information after each action, although of course they tell the agent
the initial state.
When the environment is either partially observable or nondeterministic (or both), percepts become useful. In a partially observable environment, every percept helps narrow down
the set of possible states the agent might be in, thus making it easier for the agent to achieve
its goals. When the environment is nondeterministic, percepts tell the agent which of the possible outcomes of its actions has actually occurred. In both cases, the future percepts cannot
be determined in advance and the agent’s future actions will depend on those future percepts.
So the solution to a problem is not a sequence but a contingency plan (also known as a strategy) that specifies what to do depending on what percepts are received. In this section, we
examine the case of nondeterminism, deferring partial observability to Section 4.4.

4.3.1 The erratic vacuum world
As an example, we use the vacuum world, first introduced in Chapter 2 and defined as a
search problem in Section 3.2.1. Recall that the state space has eight states, as shown in
Figure 4.9. There are three actions—Left, Right, and Suck—and the goal is to clean up all
the dirt (states 7 and 8). If the environment is observable, deterministic, and completely
known, then the problem is trivially solvable by any of the algorithms in Chapter 3 and the
solution is an action sequence. For example, if the initial state is 1, then the action sequence
[Suck,Right,Suck] will reach a goal state, 8.
8 A set of points S is convex if the line joining any two points in S is also contained in S. A convex function is
one for which the space “above” it forms a convex set; by definition, convex functions have no local (as opposed
to global) minima.

134

Chapter 4.

Figure 4.9

ERRATIC VACUUM
WORLD

1

2

3

4

5

6

7

8

Beyond Classical Search

The eight possible states of the vacuum world; states 7 and 8 are goal states.

Now suppose that we introduce nondeterminism in the form of a powerful but erratic
vacuum cleaner. In the erratic vacuum world, the Suck action works as follows:
• When applied to a dirty square the action cleans the square and sometimes cleans up
dirt in an adjacent square, too.
• When applied to a clean square the action sometimes deposits dirt on the carpet.9
To provide a precise formulation of this problem, we need to generalize the notion of a transition model from Chapter 3. Instead of defining the transition model by a R ESULT function
that returns a single state, we use a R ESULTS function that returns a set of possible outcome
states. For example, in the erratic vacuum world, the Suck action in state 1 leads to a state in
the set {5, 7}—the dirt in the right-hand square may or may not be vacuumed up.
We also need to generalize the notion of a solution to the problem. For example, if we
start in state 1, there is no single sequence of actions that solves the problem. Instead, we
need a contingency plan such as the following:
[Suck, if State = 5 then [Right, Suck] else [ ]] .

(4.3)

Thus, solutions for nondeterministic problems can contain nested if–then–else statements;
this means that they are trees rather than sequences. This allows the selection of actions
based on contingencies arising during execution. Many problems in the real, physical world
are contingency problems because exact prediction is impossible. For this reason, many
people keep their eyes open while walking around or driving.
9

We assume that most readers face similar problems and can sympathize with our agent. We apologize to
owners of modern, efficient home appliances who cannot take advantage of this pedagogical device.

Section 4.3.

Searching with Nondeterministic Actions

4.3.2

OR NODE

AND NODE

AND–OR TREE

135

AND – OR search trees

The next question is how to find contingent solutions to nondeterministic problems. As in
Chapter 3, we begin by constructing search trees, but here the trees have a different character.
In a deterministic environment, the only branching is introduced by the agent’s own choices
in each state. We call these nodes OR nodes. In the vacuum world, for example, at an OR
node the agent chooses Left or Right or Suck. In a nondeterministic environment, branching
is also introduced by the environment’s choice of outcome for each action. We call these
nodes AND nodes. For example, the Suck action in state 1 leads to a state in the set {5, 7},
so the agent would need to find a plan for state 5 and for state 7. These two kinds of nodes
alternate, leading to an AND – OR tree as illustrated in Figure 4.10.
A solution for an AND – OR search problem is a subtree that (1) has a goal node at every
leaf, (2) specifies one action at each of its OR nodes, and (3) includes every outcome branch
at each of its AND nodes. The solution is shown in bold lines in the figure; it corresponds
to the plan given in Equation (4.3). (The plan uses if–then–else notation to handle the AND
branches, but when there are more than two branches at a node, it might be better to use a case

1

7

GOAL

5

Suck

Right

5

2

Suck

6

1

LOOP

Left

Right

LOOP

Suck

8

1

Left

Suck

4

8

LOOP

GOAL

5

GOAL

LOOP

Figure 4.10 The first two levels of the search tree for the erratic vacuum world. State
nodes are OR nodes where some action must be chosen. At the AND nodes, shown as circles,
every outcome must be handled, as indicated by the arc linking the outgoing branches. The
solution found is shown in bold lines.

136

Chapter 4.

Beyond Classical Search

function A ND -O R -G RAPH -S EARCH (problem) returns a conditional plan, or failure
O R -S EARCH (problem.I NITIAL -S TATE, problem, [ ])
function O R -S EARCH (state, problem, path) returns a conditional plan, or failure
if problem.G OAL -T EST(state) then return the empty plan
if state is on path then return failure
for each action in problem.ACTIONS (state) do
plan ← A ND -S EARCH (R ESULTS(state, action), problem, [state | path])
if plan  = failure then return [action | plan]
return failure
function A ND -S EARCH (states, problem, path) returns a conditional plan, or failure
for each si in states do
plan i ← O R -S EARCH (si , problem, path)
if plan i = failure then return failure
return [if s1 then plan 1 else if s2 then plan 2 else . . . if sn−1 then plan n−1 else plan n ]
Figure 4.11 An algorithm for searching AND – OR graphs generated by nondeterministic
environments. It returns a conditional plan that reaches a goal state in all circumstances. (The
notation [x | l] refers to the list formed by adding object x to the front of list l.)

INTERLEAVING

construct.) Modifying the basic problem-solving agent shown in Figure 3.1 to execute contingent solutions of this kind is straightforward. One may also consider a somewhat different
agent design, in which the agent can act before it has found a guaranteed plan and deals with
some contingencies only as they arise during execution. This type of interleaving of search
and execution is also useful for exploration problems (see Section 4.5) and for game playing
(see Chapter 5).
Figure 4.11 gives a recursive, depth-first algorithm for AND – OR graph search. One
key aspect of the algorithm is the way in which it deals with cycles, which often arise in
nondeterministic problems (e.g., if an action sometimes has no effect or if an unintended
effect can be corrected). If the current state is identical to a state on the path from the root,
then it returns with failure. This doesn’t mean that there is no solution from the current state;
it simply means that if there is a noncyclic solution, it must be reachable from the earlier
incarnation of the current state, so the new incarnation can be discarded. With this check, we
ensure that the algorithm terminates in every finite state space, because every path must reach
a goal, a dead end, or a repeated state. Notice that the algorithm does not check whether the
current state is a repetition of a state on some other path from the root, which is important for
efficiency. Exercise 4.5 investigates this issue.
AND – OR graphs can also be explored by breadth-first or best-first methods. The concept
of a heuristic function must be modified to estimate the cost of a contingent solution rather
than a sequence, but the notion of admissibility carries over and there is an analog of the A∗
algorithm for finding optimal solutions. Pointers are given in the bibliographical notes at the
end of the chapter.

Section 4.3.

Searching with Nondeterministic Actions

137

1

Suck

Right

5

2

Right

6

Figure 4.12 Part of the search graph for the slippery vacuum world, where we have shown
(some) cycles explicitly. All solutions for this problem are cyclic plans because there is no
way to move reliably.

4.3.3 Try, try again

CYCLIC SOLUTION
LABEL

Consider the slippery vacuum world, which is identical to the ordinary (non-erratic) vacuum world except that movement actions sometimes fail, leaving the agent in the same location. For example, moving Right in state 1 leads to the state set {1, 2}. Figure 4.12 shows
part of the search graph; clearly, there are no longer any acyclic solutions from state 1, and
A ND -O R -G RAPH -S EARCH would return with failure. There is, however, a cyclic solution,
which is to keep trying Right until it works. We can express this solution by adding a label to
denote some portion of the plan and using that label later instead of repeating the plan itself.
Thus, our cyclic solution is
[Suck, L1 : Right, if State = 5 then L1 else Suck ] .
(A better syntax for the looping part of this plan would be “while State = 5 do Right.”)
In general a cyclic plan may be considered a solution provided that every leaf is a goal
state and that a leaf is reachable from every point in the plan. The modifications needed
to A ND -O R -G RAPH -S EARCH are covered in Exercise 4.6. The key realization is that a loop
in the state space back to a state L translates to a loop in the plan back to the point where the
subplan for state L is executed.
Given the definition of a cyclic solution, an agent executing such a solution will eventually reach the goal provided that each outcome of a nondeterministic action eventually occurs.
Is this condition reasonable? It depends on the reason for the nondeterminism. If the action
rolls a die, then it’s reasonable to suppose that eventually a six will be rolled. If the action is
to insert a hotel card key into the door lock, but it doesn’t work the first time, then perhaps it
will eventually work, or perhaps one has the wrong key (or the wrong room!). After seven or

138

Chapter 4.

Beyond Classical Search

eight tries, most people will assume the problem is with the key and will go back to the front
desk to get a new one. One way to understand this decision is to say that the initial problem
formulation (observable, nondeterministic) is abandoned in favor of a different formulation
(partially observable, deterministic) where the failure is attributed to an unobservable property of the key. We have more to say on this issue in Chapter 13.

4.4

S EARCHING WITH PARTIAL O BSERVATIONS

BELIEF STATE

We now turn to the problem of partial observability, where the agent’s percepts do not suffice to pin down the exact state. As noted at the beginning of the previous section, if the
agent is in one of several possible states, then an action may lead to one of several possible
outcomes—even if the environment is deterministic. The key concept required for solving
partially observable problems is the belief state, representing the agent’s current belief about
the possible physical states it might be in, given the sequence of actions and percepts up to
that point. We begin with the simplest scenario for studying belief states, which is when the
agent has no sensors at all; then we add in partial sensing as well as nondeterministic actions.

4.4.1 Searching with no observation
SENSORLESS
CONFORMANT

COERCION

When the agent’s percepts provide no information at all, we have what is called a sensorless problem or sometimes a conformant problem. At first, one might think the sensorless
agent has no hope of solving a problem if it has no idea what state it’s in; in fact, sensorless
problems are quite often solvable. Moreover, sensorless agents can be surprisingly useful,
primarily because they don’t rely on sensors working properly. In manufacturing systems,
for example, many ingenious methods have been developed for orienting parts correctly from
an unknown initial position by using a sequence of actions with no sensing at all. The high
cost of sensing is another reason to avoid it: for example, doctors often prescribe a broadspectrum antibiotic rather than using the contingent plan of doing an expensive blood test,
then waiting for the results to come back, and then prescribing a more specific antibiotic and
perhaps hospitalization because the infection has progressed too far.
We can make a sensorless version of the vacuum world. Assume that the agent knows
the geography of its world, but doesn’t know its location or the distribution of dirt. In that
case, its initial state could be any element of the set {1, 2, 3, 4, 5, 6, 7, 8}. Now, consider what
happens if it tries the action Right. This will cause it to be in one of the states {2, 4, 6, 8}—the
agent now has more information! Furthermore, the action sequence [Right,Suck] will always
end up in one of the states {4, 8}. Finally, the sequence [Right,Suck,Left,Suck] is guaranteed
to reach the goal state 7 no matter what the start state. We say that the agent can coerce the
world into state 7.
To solve sensorless problems, we search in the space of belief states rather than physical
states.10 Notice that in belief-state space, the problem is fully observable because the agent
10 In a fully observable environment, each belief state contains one physical state. Thus, we can view the algo-

rithms in Chapter 3 as searching in a belief-state space of singleton belief states.

Section 4.4.

Searching with Partial Observations

139

always knows its own belief state. Furthermore, the solution (if any) is always a sequence of
actions. This is because, as in the ordinary problems of Chapter 3, the percepts received after
each action are completely predictable—they’re always empty! So there are no contingencies
to plan for. This is true even if the environment is nondeterminstic.
It is instructive to see how the belief-state search problem is constructed. Suppose
the underlying physical problem P is defined by ACTIONS P , R ESULT P , G OAL -T EST P , and
S TEP -C OST P . Then we can define the corresponding sensorless problem as follows:
• Belief states: The entire belief-state space contains every possible set of physical states.
If P has N states, then the sensorless problem has up to 2N states, although many may
be unreachable from the initial state.
• Initial state: Typically the set of all states in P , although in some cases the agent will
have more knowledge than this.
• Actions: This is slightly tricky. Suppose the agent is in belief state b = {s1 , s2 }, but
ACTIONS P (s1 )  = ACTIONS P (s2 ); then the agent is unsure of which actions are legal.
If we assume that illegal actions have no effect on the environment, then it is safe to
take the union of all the actions in any of the physical states in the current belief state b:

ACTIONS (b) =
ACTIONS P (s) .
s∈b

On the other hand, if an illegal action might be the end of the world, it is safer to allow
only the intersection, that is, the set of actions legal in all the states. For the vacuum
world, every state has the same legal actions, so both methods give the same result.
• Transition model: The agent doesn’t know which state in the belief state is the right
one; so as far as it knows, it might get to any of the states resulting from applying the
action to one of the physical states in the belief state. For deterministic actions, the set
of states that might be reached is
b = R ESULT (b, a) = {s : s = R ESULT P (s, a) and s ∈ b} .

(4.4)

With deterministic actions, b is never larger than b. With nondeterminism, we have
b = R ESULT (b, a) = {s : s ∈ R ESULTS P (s, a) and s ∈ b}

=
R ESULTS P (s, a) ,
s∈b

PREDICTION

which may be larger than b, as shown in Figure 4.13. The process of generating
the new belief state after the action is called the prediction step; the notation b =
P REDICTP (b, a) will come in handy.
• Goal test: The agent wants a plan that is sure to work, which means that a belief state
satisfies the goal only if all the physical states in it satisfy G OAL -T EST P . The agent
may accidentally achieve the goal earlier, but it won’t know that it has done so.
• Path cost: This is also tricky. If the same action can have different costs in different
states, then the cost of taking an action in a given belief state could be one of several
values. (This gives rise to a new class of problems, which we explore in Exercise 4.9.)
For now we assume that the cost of an action is the same in all states and so can be
transferred directly from the underlying physical problem.

140

Chapter 4.

Beyond Classical Search

1

1

2

1

2

3

4

3

4

3

(a)

(b)

Figure 4.13 (a) Predicting the next belief state for the sensorless vacuum world with a
deterministic action, Right . (b) Prediction for the same belief state and action in the slippery
version of the sensorless vacuum world.

Figure 4.14 shows the reachable belief-state space for the deterministic, sensorless vacuum
world. There are only 12 reachable belief states out of 28 = 256 possible belief states.
The preceding definitions enable the automatic construction of the belief-state problem
formulation from the definition of the underlying physical problem. Once this is done, we
can apply any of the search algorithms of Chapter 3. In fact, we can do a little bit more
than that. In “ordinary” graph search, newly generated states are tested to see if they are
identical to existing states. This works for belief states, too; for example, in Figure 4.14, the
action sequence [Suck,Left,Suck] starting at the initial state reaches the same belief state as
[Right,Left,Suck], namely, {5, 7}. Now, consider the belief state reached by [Left], namely,
{1, 3, 5, 7}. Obviously, this is not identical to {5, 7}, but it is a superset. It is easy to prove
(Exercise 4.8) that if an action sequence is a solution for a belief state b, it is also a solution for
any subset of b. Hence, we can discard a path reaching {1, 3, 5, 7} if {5, 7} has already been
generated. Conversely, if {1, 3, 5, 7} has already been generated and found to be solvable,
then any subset, such as {5, 7}, is guaranteed to be solvable. This extra level of pruning may
dramatically improve the efficiency of sensorless problem solving.
Even with this improvement, however, sensorless problem-solving as we have described
it is seldom feasible in practice. The difficulty is not so much the vastness of the belief-state
space—even though it is exponentially larger than the underlying physical state space; in
most cases the branching factor and solution length in the belief-state space and physical
state space are not so different. The real difficulty lies with the size of each belief state. For
example, the initial belief state for the 10 × 10 vacuum world contains 100 × 2100 or around
1032 physical states—far too many if we use the atomic representation, which is an explicit
list of states.
One solution is to represent the belief state by some more compact description. In
English, we could say the agent knows “Nothing” in the initial state; after moving Left, we
could say, “Not in the rightmost column,” and so on. Chapter 7 explains how to do this in a
formal representation scheme. Another approach is to avoid the standard search algorithms,
which treat belief states as black boxes just like any other problem state. Instead, we can look

Section 4.4.

Searching with Partial Observations

141
L
R

1

3

5

1

2

3

L

7

R
4

5

7

8

6

2

4

6

8

S
4

5

7

8

S

S

L
5

5

S

7

3

R
L

6

4

S

8

7

4
8

R
R

L
6
8

L
S

L
8

7

R

S

R

3
7

Figure 4.14 The reachable portion of the belief-state space for the deterministic, sensorless vacuum world. Each shaded box corresponds to a single belief state. At any given point,
the agent is in a particular belief state but does not know which physical state it is in. The
initial belief state (complete ignorance) is the top center box. Actions are represented by
labeled links. Self-loops are omitted for clarity.
INCREMENTAL
BELIEF-STATE
SEARCH

inside the belief states and develop incremental belief-state search algorithms that build up
the solution one physical state at a time. For example, in the sensorless vacuum world, the
initial belief state is {1, 2, 3, 4, 5, 6, 7, 8}, and we have to find an action sequence that works
in all 8 states. We can do this by first finding a solution that works for state 1; then we check
if it works for state 2; if not, go back and find a different solution for state 1, and so on. Just
as an AND – OR search has to find a solution for every branch at an AND node, this algorithm
has to find a solution for every state in the belief state; the difference is that AND – OR search
can find a different solution for each branch, whereas an incremental belief-state search has
to find one solution that works for all the states.
The main advantage of the incremental approach is that it is typically able to detect
failure quickly—when a belief state is unsolvable, it is usually the case that a small subset of
the belief state, consisting of the first few states examined, is also unsolvable. In some cases,

142

Chapter 4.

Beyond Classical Search

this leads to a speedup proportional to the size of the belief states, which may themselves be
as large as the physical state space itself.
Even the most efficient solution algorithm is not of much use when no solutions exist.
Many things just cannot be done without sensing. For example, the sensorless 8-puzzle is
impossible. On the other hand, a little bit of sensing can go a long way. For example, every
8-puzzle instance is solvable if just one square is visible—the solution involves moving each
tile in turn into the visible square and then keeping track of its location.

4.4.2 Searching with observations
For a general partially observable problem, we have to specify how the environment generates
percepts for the agent. For example, we might define the local-sensing vacuum world to be
one in which the agent has a position sensor and a local dirt sensor but has no sensor capable
of detecting dirt in other squares. The formal problem specification includes a P ERCEPT (s)
function that returns the percept received in a given state. (If sensing is nondeterministic,
then we use a P ERCEPTS function that returns a set of possible percepts.) For example, in the
local-sensing vacuum world, the P ERCEPT in state 1 is [A, Dirty]. Fully observable problems
are a special case in which P ERCEPT (s) = s for every state s, while sensorless problems are
a special case in which P ERCEPT (s) = null.
When observations are partial, it will usually be the case that several states could have
produced any given percept. For example, the percept [A, Dirty] is produced by state 3 as
well as by state 1. Hence, given this as the initial percept, the initial belief state for the
local-sensing vacuum world will be {1, 3}. The ACTIONS , S TEP -C OST , and G OAL -T EST
are constructed from the underlying physical problem just as for sensorless problems, but the
transition model is a bit more complicated. We can think of transitions from one belief state
to the next for a particular action as occurring in three stages, as shown in Figure 4.15:
• The prediction stage is the same as for sensorless problems: given the action a in belief
state b, the predicted belief state is b̂ = P REDICT(b, a).11
• The observation prediction stage determines the set of percepts o that could be observed in the predicted belief state:
P OSSIBLE -P ERCEPTS (b̂) = {o : o = P ERCEPT (s) and s ∈ b̂} .
• The update stage determines, for each possible percept, the belief state that would
result from the percept. The new belief state bo is just the set of states in b̂ that could
have produced the percept:
bo = U PDATE (b̂, o) = {s : o = P ERCEPT (s) and s ∈ b̂} .
Notice that each updated belief state bo can be no larger than the predicted belief state b̂;
observations can only help reduce uncertainty compared to the sensorless case. Moreover, for deterministic sensing, the belief states for the different possible percepts will
be disjoint, forming a partition of the original predicted belief state.
11 Here, and throughout the book, the “hat” in b̂ means an estimated or predicted value for b.

Section 4.4.

Searching with Partial Observations

143

Right
1

2

3

4

[B,Dirty]

2

[B,Clean]

4

(a)

[B,Dirty]
Right

2

2

1

1

3

3

[A,Dirty]

1

(b)
3

4

[B,Clean]
4

Figure 4.15 Two example of transitions in local-sensing vacuum worlds. (a) In the deterministic world, Right is applied in the initial belief state, resulting in a new belief state
with two possible physical states; for those states, the possible percepts are [B, Dirty] and
[B, Clean], leading to two belief states, each of which is a singleton. (b) In the slippery
world, Right is applied in the initial belief state, giving a new belief state with four physical states; for those states, the possible percepts are [A, Dirty], [B, Dirty], and [B, Clean],
leading to three belief states as shown.

Putting these three stages together, we obtain the possible belief states resulting from a given
action and the subsequent possible percepts:
R ESULTS (b, a) = {bo : bo = U PDATE (P REDICT (b, a), o) and
o ∈ P OSSIBLE -P ERCEPTS (P REDICT (b, a))} .

(4.5)

Again, the nondeterminism in the partially observable problem comes from the inability
to predict exactly which percept will be received after acting; underlying nondeterminism in
the physical environment may contribute to this inability by enlarging the belief state at the
prediction stage, leading to more percepts at the observation stage.

4.4.3 Solving partially observable problems
The preceding section showed how to derive the R ESULTS function for a nondeterministic
belief-state problem from an underlying physical problem and the P ERCEPT function. Given

144

Chapter 4.

Beyond Classical Search

1

3

Suck

Right

[B,Dirty]

[A,Clean]

[B,Clean]

5
2

4

7

Figure 4.16 The first level of the AND – OR search tree for a problem in the local-sensing
vacuum world; Suck is the first step of the solution.

such a formulation, the AND – OR search algorithm of Figure 4.11 can be applied directly to
derive a solution. Figure 4.16 shows part of the search tree for the local-sensing vacuum
world, assuming an initial percept [A, Dirty]. The solution is the conditional plan
[Suck, Right, if Bstate = {6} then Suck else [ ]] .
Notice that, because we supplied a belief-state problem to the AND – OR search algorithm, it
returned a conditional plan that tests the belief state rather than the actual state. This is as it
should be: in a partially observable environment the agent won’t be able to execute a solution
that requires testing the actual state.
As in the case of standard search algorithms applied to sensorless problems, the AND –
OR search algorithm treats belief states as black boxes, just like any other states. One can
improve on this by checking for previously generated belief states that are subsets or supersets
of the current state, just as for sensorless problems. One can also derive incremental search
algorithms, analogous to those described for sensorless problems, that provide substantial
speedups over the black-box approach.

4.4.4 An agent for partially observable environments
The design of a problem-solving agent for partially observable environments is quite similar
to the simple problem-solving agent in Figure 3.1: the agent formulates a problem, calls a
search algorithm (such as A ND -O R -G RAPH -S EARCH ) to solve it, and executes the solution.
There are two main differences. First, the solution to a problem will be a conditional plan
rather than a sequence; if the first step is an if–then–else expression, the agent will need to
test the condition in the if-part and execute the then-part or the else-part accordingly. Second,
the agent will need to maintain its belief state as it performs actions and receives percepts.
This process resembles the prediction–observation–update process in Equation (4.5) but is
actually simpler because the percept is given by the environment rather than calculated by the

Section 4.4.

Searching with Partial Observations

Suck

145

[A,Clean]

Right

2

[B,Dirty]

1

5

5

6

2

3

7

7

4

6

8

Figure 4.17 Two prediction–update cycles of belief-state maintenance in the kindergarten
vacuum world with local sensing.

agent. Given an initial belief state b, an action a, and a percept o, the new belief state is:
b = U PDATE (P REDICT (b, a), o) .

MONITORING
FILTERING
STATE ESTIMATION
RECURSIVE

LOCALIZATION

(4.6)

Figure 4.17 shows the belief state being maintained in the kindergarten vacuum world with
local sensing, wherein any square may become dirty at any time unless the agent is actively
cleaning it at that moment.12
In partially observable environments—which include the vast majority of real-world
environments—maintaining one’s belief state is a core function of any intelligent system.
This function goes under various names, including monitoring, filtering and state estimation. Equation (4.6) is called a recursive state estimator because it computes the new belief
state from the previous one rather than by examining the entire percept sequence. If the agent
is not to “fall behind,” the computation has to happen as fast as percepts are coming in. As
the environment becomes more complex, the exact update computation becomes infeasible
and the agent will have to compute an approximate belief state, perhaps focusing on the implications of the percept for the aspects of the environment that are of current interest. Most
work on this problem has been done for stochastic, continuous-state environments with the
tools of probability theory, as explained in Chapter 15. Here we will show an example in a
discrete environment with detrministic sensors and nondeterministic actions.
The example concerns a robot with the task of localization: working out where it is,
given a map of the world and a sequence of percepts and actions. Our robot is placed in the
maze-like environment of Figure 4.18. The robot is equipped with four sonar sensors that
tell whether there is an obstacle—the outer wall or a black square in the figure—in each of
the four compass directions. We assume that the sensors give perfectly correct data, and that
the robot has a correct map of the enviornment. But unfortunately the robot’s navigational
system is broken, so when it executes a Move action, it moves randomly to one of the adjacent
squares. The robot’s task is to determine its current location.
Suppose the robot has just been switched on, so it does not know where it is. Thus its
initial belief state b consists of the set of all locations. The the robot receives the percept
12 The usual apologies to those who are unfamiliar with the effect of small children on the environment.

146

Chapter 4.

Beyond Classical Search

(a) Possible locations of robot after E 1 = N SW

(b) Possible locations of robot After E 1 = N SW, E 2 = N S
Figure 4.18 Possible positions of the robot, , (a) after one observation E1 = N SW and
(b) after a second observation E2 = N S. When sensors are noiseless and the transition model
is accurate, there are no other possible locations for the robot consistent with this sequence
of two observations.

NSW, meaning there are obstacles to the north, west, and south, and does an update using the
equation bo = U PDATE (b), yielding the 4 locations shown in Figure 4.18(a). You can inspect
the maze to see that those are the only four locations that yield the percept NWS .
Next the robot executes a Move action, but the result is nondeterministic. The new belief state, ba = P REDICT (bo , Move), contains all the locations that are one step away from the
locations in bo . When the second percept, NS , arrives, the robot does U PDATE (ba , NS ) and
finds that the belief state has collapsed down to the single location shown in Figure 4.18(b).
That’s the only location that could be the result of
U PDATE (P REDICT (U PDATE (b, NSW ), Move), NS ) .
With nondetermnistic actions the P REDICT step grows the belief state, but the U PDATE step
shrinks it back down—as long as the percepts provide some useful identifying information.
Sometimes the percepts don’t help much for localization: If there were one or more long
east-west corridors, then a robot could receive a long sequence of N S percepts, but never
know where in the corridor(s) it was.

Section 4.5.

4.5

Online Search Agents and Unknown Environments

147

O NLINE S EARCH AGENTS AND U NKNOWN E NVIRONMENTS

OFFLINE SEARCH

ONLINE SEARCH

EXPLORATION
PROBLEM

So far we have concentrated on agents that use offline search algorithms. They compute
a complete solution before setting foot in the real world and then execute the solution. In
contrast, an online search13 agent interleaves computation and action: first it takes an action,
then it observes the environment and computes the next action. Online search is a good idea
in dynamic or semidynamic domains—domains where there is a penalty for sitting around
and computing too long. Online search is also helpful in nondeterministic domains because
it allows the agent to focus its computational efforts on the contingencies that actually arise
rather than those that might happen but probably won’t. Of course, there is a tradeoff: the
more an agent plans ahead, the less often it will find itself up the creek without a paddle.
Online search is a necessary idea for unknown environments, where the agent does not
know what states exist or what its actions do. In this state of ignorance, the agent faces an
exploration problem and must use its actions as experiments in order to learn enough to
make deliberation worthwhile.
The canonical example of online search is a robot that is placed in a new building and
must explore it to build a map that it can use for getting from A to B. Methods for escaping
from labyrinths—required knowledge for aspiring heroes of antiquity—are also examples of
online search algorithms. Spatial exploration is not the only form of exploration, however.
Consider a newborn baby: it has many possible actions but knows the outcomes of none of
them, and it has experienced only a few of the possible states that it can reach. The baby’s
gradual discovery of how the world works is, in part, an online search process.

4.5.1 Online search problems
An online search problem must be solved by an agent executing actions, rather than by pure
computation. We assume a deterministic and fully observable environment (Chapter 17 relaxes these assumptions), but we stipulate that the agent knows only the following:
• ACTIONS (s), which returns a list of actions allowed in state s;
• The step-cost function c(s, a, s )—note that this cannot be used until the agent knows
that s is the outcome; and
• G OAL -T EST (s).
Note in particular that the agent cannot determine R ESULT (s, a) except by actually being
in s and doing a. For example, in the maze problem shown in Figure 4.19, the agent does
not know that going Up from (1,1) leads to (1,2); nor, having done that, does it know that
going Down will take it back to (1,1). This degree of ignorance can be reduced in some
applications—for example, a robot explorer might know how its movement actions work and
be ignorant only of the locations of obstacles.
13 The term “online” is commonly used in computer science to refer to algorithms that must process input data

as they are received rather than waiting for the entire input data set to become available.

148

Chapter 4.

Beyond Classical Search

G

3

2

1

S
1

2

3

Figure 4.19 A simple maze problem. The agent starts at S and must reach G but knows
nothing of the environment.

G
S

A

G

S

S

A
G
(a)

(b)

Figure 4.20 (a) Two state spaces that might lead an online search agent into a dead end.
Any given agent will fail in at least one of these spaces. (b) A two-dimensional environment
that can cause an online search agent to follow an arbitrarily inefficient route to the goal.
Whichever choice the agent makes, the adversary blocks that route with another long, thin
wall, so that the path followed is much longer than the best possible path.

COMPETITIVE RATIO

Finally, the agent might have access to an admissible heuristic function h(s) that estimates the distance from the current state to a goal state. For example, in Figure 4.19, the
agent might know the location of the goal and be able to use the Manhattan-distance heuristic.
Typically, the agent’s objective is to reach a goal state while minimizing cost. (Another
possible objective is simply to explore the entire environment.) The cost is the total path cost
of the path that the agent actually travels. It is common to compare this cost with the path
cost of the path the agent would follow if it knew the search space in advance—that is, the
actual shortest path (or shortest complete exploration). In the language of online algorithms,
this is called the competitive ratio; we would like it to be as small as possible.

Section 4.5.

IRREVERSIBLE

DEAD END

ADVERSARY
ARGUMENT

SAFELY EXPLORABLE

Online Search Agents and Unknown Environments

149

Although this sounds like a reasonable request, it is easy to see that the best achievable
competitive ratio is infinite in some cases. For example, if some actions are irreversible—
i.e., they lead to a state from which no action leads back to the previous state—the online
search might accidentally reach a dead-end state from which no goal state is reachable. Perhaps the term “accidentally” is unconvincing—after all, there might be an algorithm that
happens not to take the dead-end path as it explores. Our claim, to be more precise, is that no
algorithm can avoid dead ends in all state spaces. Consider the two dead-end state spaces in
Figure 4.20(a). To an online search algorithm that has visited states S and A, the two state
spaces look identical, so it must make the same decision in both. Therefore, it will fail in
one of them. This is an example of an adversary argument—we can imagine an adversary
constructing the state space while the agent explores it and putting the goals and dead ends
wherever it chooses.
Dead ends are a real difficulty for robot exploration—staircases, ramps, cliffs, one-way
streets, and all kinds of natural terrain present opportunities for irreversible actions. To make
progress, we simply assume that the state space is safely explorable—that is, some goal state
is reachable from every reachable state. State spaces with reversible actions, such as mazes
and 8-puzzles, can be viewed as undirected graphs and are clearly safely explorable.
Even in safely explorable environments, no bounded competitive ratio can be guaranteed if there are paths of unbounded cost. This is easy to show in environments with irreversible actions, but in fact it remains true for the reversible case as well, as Figure 4.20(b)
shows. For this reason, it is common to describe the performance of online search algorithms
in terms of the size of the entire state space rather than just the depth of the shallowest goal.

4.5.2 Online search agents
After each action, an online agent receives a percept telling it what state it has reached; from
this information, it can augment its map of the environment. The current map is used to
decide where to go next. This interleaving of planning and action means that online search
algorithms are quite different from the offline search algorithms we have seen previously. For
example, offline algorithms such as A∗ can expand a node in one part of the space and then
immediately expand a node in another part of the space, because node expansion involves
simulated rather than real actions. An online algorithm, on the other hand, can discover
successors only for a node that it physically occupies. To avoid traveling all the way across
the tree to expand the next node, it seems better to expand nodes in a local order. Depth-first
search has exactly this property because (except when backtracking) the next node expanded
is a child of the previous node expanded.
An online depth-first search agent is shown in Figure 4.21. This agent stores its map
in a table, R ESULT [s, a], that records the state resulting from executing action a in state s.
Whenever an action from the current state has not been explored, the agent tries that action.
The difficulty comes when the agent has tried all the actions in a state. In offline depth-first
search, the state is simply dropped from the queue; in an online search, the agent has to
backtrack physically. In depth-first search, this means going back to the state from which the
agent most recently entered the current state. To achieve that, the algorithm keeps a table that

150

Chapter 4.

Beyond Classical Search

function O NLINE -DFS-AGENT(s  ) returns an action
inputs: s  , a percept that identifies the current state
persistent: result, a table indexed by state and action, initially empty
untried, a table that lists, for each state, the actions not yet tried
unbacktracked , a table that lists, for each state, the backtracks not yet tried
s, a, the previous state and action, initially null
if G OAL -T EST(s  ) then return stop
if s  is a new state (not in untried) then untried[s  ] ← ACTIONS (s  )
if s is not null then
result[s, a] ← s 
add s to the front of unbacktracked [s  ]
if untried[s  ] is empty then
if unbacktracked [s  ] is empty then return stop
else a ← an action b such that result[s  , b] = P OP(unbacktracked [s  ])
else a ← P OP (untried[s  ])
s ← s
return a
Figure 4.21 An online search agent that uses depth-first exploration. The agent is applicable only in state spaces in which every action can be “undone” by some other action.

lists, for each state, the predecessor states to which the agent has not yet backtracked. If the
agent has run out of states to which it can backtrack, then its search is complete.
We recommend that the reader trace through the progress of O NLINE -DFS-AGENT
when applied to the maze given in Figure 4.19. It is fairly easy to see that the agent will, in
the worst case, end up traversing every link in the state space exactly twice. For exploration,
this is optimal; for finding a goal, on the other hand, the agent’s competitive ratio could be
arbitrarily bad if it goes off on a long excursion when there is a goal right next to the initial
state. An online variant of iterative deepening solves this problem; for an environment that is
a uniform tree, the competitive ratio of such an agent is a small constant.
Because of its method of backtracking, O NLINE -DFS-AGENT works only in state
spaces where the actions are reversible. There are slightly more complex algorithms that
work in general state spaces, but no such algorithm has a bounded competitive ratio.

4.5.3 Online local search

RANDOM WALK

Like depth-first search, hill-climbing search has the property of locality in its node expansions. In fact, because it keeps just one current state in memory, hill-climbing search is
already an online search algorithm! Unfortunately, it is not very useful in its simplest form
because it leaves the agent sitting at local maxima with nowhere to go. Moreover, random
restarts cannot be used, because the agent cannot transport itself to a new state.
Instead of random restarts, one might consider using a random walk to explore the
environment. A random walk simply selects at random one of the available actions from the

Section 4.5.

Online Search Agents and Unknown Environments

S

151

G

Figure 4.22 An environment in which a random walk will take exponentially many steps
to find the goal.

LRTA*

OPTIMISM UNDER
UNCERTAINTY

current state; preference can be given to actions that have not yet been tried. It is easy to
prove that a random walk will eventually find a goal or complete its exploration, provided
that the space is finite.14 On the other hand, the process can be very slow. Figure 4.22 shows
an environment in which a random walk will take exponentially many steps to find the goal
because, at each step, backward progress is twice as likely as forward progress. The example
is contrived, of course, but there are many real-world state spaces whose topology causes
these kinds of “traps” for random walks.
Augmenting hill climbing with memory rather than randomness turns out to be a more
effective approach. The basic idea is to store a “current best estimate” H(s) of the cost to
reach the goal from each state that has been visited. H(s) starts out being just the heuristic
estimate h(s) and is updated as the agent gains experience in the state space. Figure 4.23
shows a simple example in a one-dimensional state space. In (a), the agent seems to be
stuck in a flat local minimum at the shaded state. Rather than staying where it is, the agent
should follow what seems to be the best path to the goal given the current cost estimates for
its neighbors. The estimated cost to reach the goal through a neighbor s is the cost to get
to s plus the estimated cost to get to a goal from there—that is, c(s, a, s ) + H(s ). In the
example, there are two actions, with estimated costs 1 + 9 and 1 + 2, so it seems best to move
right. Now, it is clear that the cost estimate of 2 for the shaded state was overly optimistic.
Since the best move cost 1 and led to a state that is at least 2 steps from a goal, the shaded
state must be at least 3 steps from a goal, so its H should be updated accordingly, as shown
in Figure 4.23(b). Continuing this process, the agent will move back and forth twice more,
updating H each time and “flattening out” the local minimum until it escapes to the right.
An agent implementing this scheme, which is called learning real-time A∗ (LRTA∗ ), is
shown in Figure 4.24. Like O NLINE -DFS-AGENT , it builds a map of the environment in
the result table. It updates the cost estimate for the state it has just left and then chooses the
“apparently best” move according to its current cost estimates. One important detail is that
actions that have not yet been tried in a state s are always assumed to lead immediately to the
goal with the least possible cost, namely h(s). This optimism under uncertainty encourages
the agent to explore new, possibly promising paths.
An LRTA∗ agent is guaranteed to find a goal in any finite, safely explorable environment.
Unlike A∗ , however, it is not complete for infinite state spaces—there are cases where it can be
led infinitely astray. It can explore an environment of n states in O(n2 ) steps in the worst case,
14 Random walks are complete on infinite one-dimensional and two-dimensional grids. On a three-dimensional

grid, the probability that the walk ever returns to the starting point is only about 0.3405 (Hughes, 1995).

152

Chapter 4.

(a)

(b)

(c)

(d)

(e)

1

1

1

1

1

8
8

8

8

8

1

1

1

1

1

9
9

9

9

9

1

1

1

1

1

2
3

3

5

5

1

1

1

1

1

2
2

4

4

5

1

1

1

1

1

Beyond Classical Search

4
4

4

4

4

1

1

1

1

1

3
3

3

3

3

1

1

1

1

1

Figure 4.23 Five iterations of LRTA∗ on a one-dimensional state space. Each state is
labeled with H(s), the current cost estimate to reach a goal, and each link is labeled with its
step cost. The shaded state marks the location of the agent, and the updated cost estimates at
each iteration are circled.

function LRTA*-AGENT(s  ) returns an action
inputs: s  , a percept that identifies the current state
persistent: result, a table, indexed by state and action, initially empty
H , a table of cost estimates indexed by state, initially empty
s, a, the previous state and action, initially null
if G OAL -T EST(s  ) then return stop
if s  is a new state (not in H ) then H [s  ] ← h(s  )
if s is not null
result[s, a] ← s 
H [s] ←
min LRTA*-C OST(s, b, result[s, b], H )
b ∈ A CTIONS(s)

a ← an action b in ACTIONS(s  ) that minimizes LRTA*-C OST (s  , b, result[s  , b], H )
s ← s
return a
function LRTA*-C OST(s, a, s  , H ) returns a cost estimate
if s  is undefined then return h(s)
else return c(s, a, s ) + H[s ]
Figure 4.24
LRTA*-AGENT selects an action according to the values of neighboring
states, which are updated as the agent moves about the state space.

Section 4.6.

Summary

153

but often does much better. The LRTA∗ agent is just one of a large family of online agents that
one can define by specifying the action selection rule and the update rule in different ways.
We discuss this family, developed originally for stochastic environments, in Chapter 21.

4.5.4 Learning in online search
The initial ignorance of online search agents provides several opportunities for learning. First,
the agents learn a “map” of the environment—more precisely, the outcome of each action in
each state—simply by recording each of their experiences. (Notice that the assumption of
deterministic environments means that one experience is enough for each action.) Second,
the local search agents acquire more accurate estimates of the cost of each state by using local
updating rules, as in LRTA∗. In Chapter 21, we show that these updates eventually converge
to exact values for every state, provided that the agent explores the state space in the right
way. Once exact values are known, optimal decisions can be taken simply by moving to the
lowest-cost successor—that is, pure hill climbing is then an optimal strategy.
If you followed our suggestion to trace the behavior of O NLINE -DFS-AGENT in the
environment of Figure 4.19, you will have noticed that the agent is not very bright. For
example, after it has seen that the Up action goes from (1,1) to (1,2), the agent still has no
idea that the Down action goes back to (1,1) or that the Up action also goes from (2,1) to
(2,2), from (2,2) to (2,3), and so on. In general, we would like the agent to learn that Up
increases the y-coordinate unless there is a wall in the way, that Down reduces it, and so on.
For this to happen, we need two things. First, we need a formal and explicitly manipulable
representation for these kinds of general rules; so far, we have hidden the information inside
the black box called the R ESULT function. Part III is devoted to this issue. Second, we need
algorithms that can construct suitable general rules from the specific observations made by
the agent. These are covered in Chapter 18.

4.6

S UMMARY
This chapter has examined search algorithms for problems beyond the “classical” case of
finding the shortest path to a goal in an observable, deterministic, discrete environment.
• Local search methods such as hill climbing operate on complete-state formulations,
keeping only a small number of nodes in memory. Several stochastic algorithms have
been developed, including simulated annealing, which returns optimal solutions when
given an appropriate cooling schedule.
• Many local search methods apply also to problems in continuous spaces. Linear programming and convex optimization problems obey certain restrictions on the shape
of the state space and the nature of the objective function, and admit polynomial-time
algorithms that are often extremely efficient in practice.
• A genetic algorithm is a stochastic hill-climbing search in which a large population of
states is maintained. New states are generated by mutation and by crossover, which
combines pairs of states from the population.

154

Chapter 4.

Beyond Classical Search

• In nondeterministic environments, agents can apply AND – OR search to generate contingent plans that reach the goal regardless of which outcomes occur during execution.
• When the environment is partially observable, the belief state represents the set of
possible states that the agent might be in.
• Standard search algorithms can be applied directly to belief-state space to solve sensorless problems, and belief-state AND – OR search can solve general partially observable
problems. Incremental algorithms that construct solutions state-by-state within a belief
state are often more efficient.
• Exploration problems arise when the agent has no idea about the states and actions of
its environment. For safely explorable environments, online search agents can build a
map and find a goal if one exists. Updating heuristic estimates from experience provides
an effective method to escape from local minima.

B IBLIOGRAPHICAL AND H ISTORICAL N OTES

TABU SEARCH

HEAVY-TAILED
DISTRIBUTION

Local search techniques have a long history in mathematics and computer science. Indeed,
the Newton–Raphson method (Newton, 1671; Raphson, 1690) can be seen as a very efficient local search method for continuous spaces in which gradient information is available.
Brent (1973) is a classic reference for optimization algorithms that do not require such information. Beam search, which we have presented as a local search algorithm, originated
as a bounded-width variant of dynamic programming for speech recognition in the H ARPY
system (Lowerre, 1976). A related algorithm is analyzed in depth by Pearl (1984, Ch. 5).
The topic of local search was reinvigorated in the early 1990s by surprisingly good results for large constraint-satisfaction problems such as n-queens (Minton et al., 1992) and
logical reasoning (Selman et al., 1992) and by the incorporation of randomness, multiple
simultaneous searches, and other improvements. This renaissance of what Christos Papadimitriou has called “New Age” algorithms also sparked increased interest among theoretical
computer scientists (Koutsoupias and Papadimitriou, 1992; Aldous and Vazirani, 1994). In
the field of operations research, a variant of hill climbing called tabu search has gained popularity (Glover and Laguna, 1997). This algorithm maintains a tabu list of k previously visited
states that cannot be revisited; as well as improving efficiency when searching graphs, this list
can allow the algorithm to escape from some local minima. Another useful improvement on
hill climbing is the S TAGE algorithm (Boyan and Moore, 1998). The idea is to use the local
maxima found by random-restart hill climbing to get an idea of the overall shape of the landscape. The algorithm fits a smooth surface to the set of local maxima and then calculates the
global maximum of that surface analytically. This becomes the new restart point. The algorithm has been shown to work in practice on hard problems. Gomes et al. (1998) showed that
the run times of systematic backtracking algorithms often have a heavy-tailed distribution,
which means that the probability of a very long run time is more than would be predicted if
the run times were exponentially distributed. When the run time distribution is heavy-tailed,
random restarts find a solution faster, on average, than a single run to completion.

Bibliographical and Historical Notes

EVOLUTION
STRATEGY

ARTIFICIAL LIFE

GENETIC
PROGRAMMING

155

Simulated annealing was first described by Kirkpatrick et al. (1983), who borrowed
directly from the Metropolis algorithm (which is used to simulate complex systems in
physics (Metropolis et al., 1953) and was supposedly invented at a Los Alamos dinner party).
Simulated annealing is now a field in itself, with hundreds of papers published every year.
Finding optimal solutions in continuous spaces is the subject matter of several fields,
including optimization theory, optimal control theory, and the calculus of variations. The
basic techniques are explained well by Bishop (1995); Press et al. (2007) cover a wide range
of algorithms and provide working software.
As Andrew Moore points out, researchers have taken inspiration for search and optimization algorithms from a wide variety of fields of study: metallurgy (simulated annealing),
biology (genetic algorithms), economics (market-based algorithms), entomology (ant colony
optimization), neurology (neural networks), animal behavior (reinforcement learning), mountaineering (hill climbing), and others.
Linear programming (LP) was first studied systematically by the Russian mathematician Leonid Kantorovich (1939). It was one of the first applications of computers; the simplex algorithm (Dantzig, 1949) is still used despite worst-case exponential complexity. Karmarkar (1984) developed the far more efficient family of interior-point methods, which was
shown to have polynomial complexity for the more general class of convex optimization problems by Nesterov and Nemirovski (1994). Excellent introductions to convex optimization are
provided by Ben-Tal and Nemirovski (2001) and Boyd and Vandenberghe (2004).
Work by Sewall Wright (1931) on the concept of a fitness landscape was an important precursor to the development of genetic algorithms. In the 1950s, several statisticians,
including Box (1957) and Friedman (1959), used evolutionary techniques for optimization
problems, but it wasn’t until Rechenberg (1965) introduced evolution strategies to solve optimization problems for airfoils that the approach gained popularity. In the 1960s and 1970s,
John Holland (1975) championed genetic algorithms, both as a useful tool and as a method
to expand our understanding of adaptation, biological or otherwise (Holland, 1995). The artificial life movement (Langton, 1995) takes this idea one step further, viewing the products
of genetic algorithms as organisms rather than solutions to problems. Work in this field by
Hinton and Nowlan (1987) and Ackley and Littman (1991) has done much to clarify the implications of the Baldwin effect. For general background on evolution, we recommend Smith
and Szathmáry (1999), Ridley (2004), and Carroll (2007).
Most comparisons of genetic algorithms to other approaches (especially stochastic hill
climbing) have found that the genetic algorithms are slower to converge (O’Reilly and Oppacher, 1994; Mitchell et al., 1996; Juels and Wattenberg, 1996; Baluja, 1997). Such findings
are not universally popular within the GA community, but recent attempts within that community to understand population-based search as an approximate form of Bayesian learning
(see Chapter 20) might help close the gap between the field and its critics (Pelikan et al.,
1999). The theory of quadratic dynamical systems may also explain the performance of
GAs (Rabani et al., 1998). See Lohn et al. (2001) for an example of GAs applied to antenna
design, and Renner and Ekart (2003) for an application to computer-aided design.
The field of genetic programming is closely related to genetic algorithms. The principal difference is that the representations that are mutated and combined are programs rather

156

Chapter 4.

Beyond Classical Search

than bit strings. The programs are represented in the form of expression trees; the expressions
can be in a standard language such as Lisp or can be specially designed to represent circuits,
robot controllers, and so on. Crossover involves splicing together subtrees rather than substrings. This form of mutation guarantees that the offspring are well-formed expressions,
which would not be the case if programs were manipulated as strings.
Interest in genetic programming was spurred by John Koza’s work (Koza, 1992, 1994),
but it goes back at least to early experiments with machine code by Friedberg (1958) and
with finite-state automata by Fogel et al. (1966). As with genetic algorithms, there is debate
about the effectiveness of the technique. Koza et al. (1999) describe experiments in the use
of genetic programming to design circuit devices.
The journals Evolutionary Computation and IEEE Transactions on Evolutionary Computation cover genetic algorithms and genetic programming; articles are also found in Complex Systems, Adaptive Behavior, and Artificial Life. The main conference is the Genetic
and Evolutionary Computation Conference (GECCO). Good overview texts on genetic algorithms are given by Mitchell (1996), Fogel (2000), and Langdon and Poli (2002), and by the
free online book by Poli et al. (2008).
The unpredictability and partial observability of real environments were recognized
early on in robotics projects that used planning techniques, including Shakey (Fikes et al.,
1972) and F REDDY (Michie, 1974). The problems received more attention after the publication of McDermott’s (1978a) influential article, Planning and Acting.
The first work to make explicit use of AND – OR trees seems to have been Slagle’s S AINT
program for symbolic integration, mentioned in Chapter 1. Amarel (1967) applied the idea
to propositional theorem proving, a topic discussed in Chapter 7, and introduced a search
algorithm similar to A ND -O R -G RAPH -S EARCH . The algorithm was further developed and
formalized by Nilsson (1971), who also described AO∗ —which, as its name suggests, finds
optimal solutions given an admissible heuristic. AO∗ was analyzed and improved by Martelli
and Montanari (1973). AO∗ is a top-down algorithm; a bottom-up generalization of A∗ is
A∗ LD, for A∗ Lightest Derivation (Felzenszwalb and McAllester, 2007). Interest in AND – OR
search has undergone a revival in recent years, with new algorithms for finding cyclic solutions (Jimenez and Torras, 2000; Hansen and Zilberstein, 2001) and new techniques inspired
by dynamic programming (Bonet and Geffner, 2005).
The idea of transforming partially observable problems into belief-state problems originated with Astrom (1965) for the much more complex case of probabilistic uncertainty (see
Chapter 17). Erdmann and Mason (1988) studied the problem of robotic manipulation without sensors, using a continuous form of belief-state search. They showed that it was possible
to orient a part on a table from an arbitrary initial position by a well-designed sequence of tilting actions. More practical methods, based on a series of precisely oriented diagonal barriers
across a conveyor belt, use the same algorithmic insights (Wiegley et al., 1996).
The belief-state approach was reinvented in the context of sensorless and partially observable search problems by Genesereth and Nourbakhsh (1993). Additional work was done
on sensorless problems in the logic-based planning community (Goldman and Boddy, 1996;
Smith and Weld, 1998). This work has emphasized concise representations for belief states,
as explained in Chapter 11. Bonet and Geffner (2000) introduced the first effective heuristics

Exercises

EULERIAN GRAPH

REAL-TIME SEARCH

157
for belief-state search; these were refined by Bryce et al. (2006). The incremental approach
to belief-state search, in which solutions are constructed incrementally for subsets of states
within each belief state, was studied in the planning literature by Kurien et al. (2002); several
new incremental algorithms were introduced for nondeterministic, partially observable problems by Russell and Wolfe (2005). Additional references for planning in stochastic, partially
observable environments appear in Chapter 17.
Algorithms for exploring unknown state spaces have been of interest for many centuries.
Depth-first search in a maze can be implemented by keeping one’s left hand on the wall; loops
can be avoided by marking each junction. Depth-first search fails with irreversible actions;
the more general problem of exploring Eulerian graphs (i.e., graphs in which each node has
equal numbers of incoming and outgoing edges) was solved by an algorithm due to Hierholzer
(1873). The first thorough algorithmic study of the exploration problem for arbitrary graphs
was carried out by Deng and Papadimitriou (1990), who developed a completely general
algorithm but showed that no bounded competitive ratio is possible for exploring a general
graph. Papadimitriou and Yannakakis (1991) examined the question of finding paths to a goal
in geometric path-planning environments (where all actions are reversible). They showed that
a small competitive ratio is achievable with square obstacles, but with general rectangular
obstacles no bounded ratio can be achieved. (See Figure 4.20.)
The LRTA∗ algorithm was developed by Korf (1990) as part of an investigation into
real-time search for environments in which the agent must act after searching for only a
fixed amount of time (a common situation in two-player games). LRTA∗ is in fact a special
case of reinforcement learning algorithms for stochastic environments (Barto et al., 1995). Its
policy of optimism under uncertainty—always head for the closest unvisited state—can result
in an exploration pattern that is less efficient in the uninformed case than simple depth-first
search (Koenig, 2000). Dasgupta et al. (1994) show that online iterative deepening search is
optimally efficient for finding a goal in a uniform tree with no heuristic information. Several informed variants on the LRTA∗ theme have been developed with different methods for
searching and updating within the known portion of the graph (Pemberton and Korf, 1992).
As yet, there is no good understanding of how to find goals with optimal efficiency when
using heuristic information.

E XERCISES
4.1

Give the name of the algorithm that results from each of the following special cases:

a. Local beam search with k = 1.
b. Local beam search with one initial state and no limit on the number of states retained.
c. Simulated annealing with T = 0 at all times (and omitting the termination test).
d. Simulated annealing with T = ∞ at all times.
e. Genetic algorithm with population size N = 1.

158

Chapter 4.

Beyond Classical Search

4.2 Exercise 3.16 considers the problem of building railway tracks under the assumption
that pieces fit exactly with no slack. Now consider the real problem, in which pieces don’t
fit exactly but allow for up to 10 degrees of rotation to either side of the “proper” alignment.
Explain how to formulate the problem so it could be solved by simulated annealing.
4.3 In this exercise, we explore the use of local search methods to solve TSPs of the type
defined in Exercise 3.30.
a. Implement and test a hill-climbing method to solve TSPs. Compare the results with optimal solutions obtained from the A∗ algorithm with the MST heuristic (Exercise 3.30).
b. Repeat part (a) using a genetic algorithm instead of hill climbing. You may want to
consult Larrañaga et al. (1999) for some suggestions for representations.
4.4 Generate a large number of 8-puzzle and 8-queens instances and solve them (where possible) by hill climbing (steepest-ascent and first-choice variants), hill climbing with random
restart, and simulated annealing. Measure the search cost and percentage of solved problems
and graph these against the optimal solution cost. Comment on your results.
4.5 The A ND -O R -G RAPH -S EARCH algorithm in Figure 4.11 checks for repeated states
only on the path from the root to the current state. Suppose that, in addition, the algorithm
were to store every visited state and check against that list. (See B READTH -F IRST-S EARCH
in Figure 3.11 for an example.) Determine the information that should be stored and how the
algorithm should use that information when a repeated state is found. (Hint: You will need to
distinguish at least between states for which a successful subplan was constructed previously
and states for which no subplan could be found.) Explain how to use labels, as defined in
Section 4.3.3, to avoid having multiple copies of subplans.
4.6 Explain precisely how to modify the A ND -O R -G RAPH -S EARCH algorithm to generate
a cyclic plan if no acyclic plan exists. You will need to deal with three issues: labeling the plan
steps so that a cyclic plan can point back to an earlier part of the plan, modifying O R -S EARCH
so that it continues to look for acyclic plans after finding a cyclic plan, and augmenting the
plan representation to indicate whether a plan is cyclic. Show how your algorithm works on
(a) the slippery vacuum world, and (b) the slippery, erratic vacuum world. You might wish to
use a computer implementation to check your results.
4.7 In Section 4.4.1 we introduced belief states to solve sensorless search problems. A
sequence of actions solves a sensorless problem if it maps every physical state in the initial
belief state b to a goal state. Suppose the agent knows h∗ (s), the true optimal cost of solving
the physical state s in the fully observable problem, for every state s in b. Find an admissible
heuristic h(b) for the sensorless problem in terms of these costs, and prove its admissibilty.
Comment on the accuracy of this heuristic on the sensorless vacuum problem of Figure 4.14.
How well does A∗ perform?
4.8 This exercise explores subset–superset relations between belief states in sensorless or
partially observable environments.
a. Prove that if an action sequence is a solution for a belief state b, it is also a solution for
any subset of b. Can anything be said about supersets of b?

Exercises

159
b. Explain in detail how to modify graph search for sensorless problems to take advantage
of your answers in (a).
c. Explain in detail how to modify AND – OR search for partially observable problems,
beyond the modifications you describe in (b).
4.9 On page 139 it was assumed that a given action would have the same cost when executed in any physical state within a given belief state. (This leads to a belief-state search
problem with well-defined step costs.) Now consider what happens when the assumption
does not hold. Does the notion of optimality still make sense in this context, or does it require
modification? Consider also various possible definitions of the “cost” of executing an action
in a belief state; for example, we could use the minimum of the physical costs; or the maximum; or a cost interval with the lower bound being the minimum cost and the upper bound
being the maximum; or just keep the set of all possible costs for that action. For each of these,
explore whether A∗ (with modifications if necessary) can return optimal solutions.
4.10 Consider the sensorless version of the erratic vacuum world. Draw the belief-state
space reachable from the initial belief state {1, 2, 3, 4, 5, 6, 7, 8}, and explain why the problem
is unsolvable.
4.11

We can turn the navigation problem in Exercise 3.7 into an environment as follows:

• The percept will be a list of the positions, relative to the agent, of the visible vertices.
The percept does not include the position of the robot! The robot must learn its own position from the map; for now, you can assume that each location has a different “view.”
• Each action will be a vector describing a straight-line path to follow. If the path is
unobstructed, the action succeeds; otherwise, the robot stops at the point where its
path first intersects an obstacle. If the agent returns a zero motion vector and is at the
goal (which is fixed and known), then the environment teleports the agent to a random
location (not inside an obstacle).
• The performance measure charges the agent 1 point for each unit of distance traversed
and awards 1000 points each time the goal is reached.
a. Implement this environment and a problem-solving agent for it. After each teleportation, the agent will need to formulate a new problem, which will involve discovering its
current location.
b. Document your agent’s performance (by having the agent generate suitable commentary
as it moves around) and report its performance over 100 episodes.
c. Modify the environment so that 30% of the time the agent ends up at an unintended
destination (chosen randomly from the other visible vertices if any; otherwise, no move
at all). This is a crude model of the motion errors of a real robot. Modify the agent
so that when such an error is detected, it finds out where it is and then constructs a
plan to get back to where it was and resume the old plan. Remember that sometimes
getting back to where it was might also fail! Show an example of the agent successfully
overcoming two successive motion errors and still reaching the goal.

160

Chapter 4.

Beyond Classical Search

d. Now try two different recovery schemes after an error: (1) head for the closest vertex on
the original route; and (2) replan a route to the goal from the new location. Compare the
performance of the three recovery schemes. Would the inclusion of search costs affect
the comparison?
e. Now suppose that there are locations from which the view is identical. (For example,
suppose the world is a grid with square obstacles.) What kind of problem does the agent
now face? What do solutions look like?
4.12 Suppose that an agent is in a 3 × 3 maze environment like the one shown in Figure 4.19. The agent knows that its initial location is (1,1), that the goal is at (3,3), and that the
actions Up, Down, Left, Right have their usual effects unless blocked by a wall. The agent
does not know where the internal walls are. In any given state, the agent perceives the set of
legal actions; it can also tell whether the state is one it has visited before.
a. Explain how this online search problem can be viewed as an offline search in belief-state
space, where the initial belief state includes all possible environment configurations.
How large is the initial belief state? How large is the space of belief states?
b. How many distinct percepts are possible in the initial state?
c. Describe the first few branches of a contingency plan for this problem. How large
(roughly) is the complete plan?
Notice that this contingency plan is a solution for every possible environment fitting the given
description. Therefore, interleaving of search and execution is not strictly necessary even in
unknown environments.
4.13 In this exercise, we examine hill climbing in the context of robot navigation, using the
environment in Figure 3.31 as an example.
a. Repeat Exercise 4.11 using hill climbing. Does your agent ever get stuck in a local
minimum? Is it possible for it to get stuck with convex obstacles?
b. Construct a nonconvex polygonal environment in which the agent gets stuck.
c. Modify the hill-climbing algorithm so that, instead of doing a depth-1 search to decide
where to go next, it does a depth-k search. It should find the best k-step path and do
one step along it, and then repeat the process.
d. Is there some k for which the new algorithm is guaranteed to escape from local minima?
e. Explain how LRTA∗ enables the agent to escape from local minima in this case.
4.14 Like DFS, online DFS is incomplete for reversible state spaces with infinite paths. For
example, suppose that states are points on the infinite two-dimensional grid and actions are
unit vectors (1, 0), (0, 1), (−1, 0), (0, −1), tried in that order. Show that online DFS starting
at (0, 0) will not reach (1, −1). Suppose the agent can observe, in addition to its current
state, all successor states and the actions that would lead to them. Write an algorithm that
is complete even for bidirected state spaces with infinite paths. What states does it visit in
reaching (1, −1)?

5

ADVERSARIAL SEARCH

In which we examine the problems that arise when we try to plan ahead in a world
where other agents are planning against us.

5.1

G AMES

GAME

ZERO-SUM GAMES
PERFECT
INFORMATION

Chapter 2 introduced multiagent environments, in which each agent needs to consider the
actions of other agents and how they affect its own welfare. The unpredictability of these
other agents can introduce contingencies into the agent’s problem-solving process, as discussed in Chapter 4. In this chapter we cover competitive environments, in which the agents’
goals are in conflict, giving rise to adversarial search problems—often known as games.
Mathematical game theory, a branch of economics, views any multiagent environment
as a game, provided that the impact of each agent on the others is “significant,” regardless
of whether the agents are cooperative or competitive. 1 In AI, the most common games are
of a rather specialized kind—what game theorists call deterministic, turn-taking, two-player,
zero-sum games of perfect information (such as chess). In our terminology, this means
deterministic, fully observable environments in which two agents act alternately and in which
the utility values at the end of the game are always equal and opposite. For example, if one
player wins a game of chess, the other player necessarily loses. It is this opposition between
the agents’ utility functions that makes the situation adversarial.
Games have engaged the intellectual faculties of humans—sometimes to an alarming
degree—for as long as civilization has existed. For AI researchers, the abstract nature of
games makes them an appealing subject for study. The state of a game is easy to represent,
and agents are usually restricted to a small number of actions whose outcomes are defined by
precise rules. Physical games, such as croquet and ice hockey, have much more complicated
descriptions, a much larger range of possible actions, and rather imprecise rules defining
the legality of actions. With the exception of robot soccer, these physical games have not
attracted much interest in the AI community.
1

Environments with very many agents are often viewed as economies rather than games.

161

162

PRUNING

IMPERFECT
INFORMATION

TERMINAL TEST
TERMINAL STATES

